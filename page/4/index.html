<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>码农随笔</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="keywords" content="Linux C C++">
<meta property="og:type" content="website">
<meta property="og:title" content="码农随笔">
<meta property="og:url" content="http://yoursite.com/page/4/index.html">
<meta property="og:site_name" content="码农随笔">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="码农随笔">
  
    <link rel="alternative" href="/atom.xml" title="码农随笔" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" type="text/css" href="/./main.0cf68a.css">
  <style type="text/css">
  
    #container.show {
      background: linear-gradient(200deg,#a0cfe4,#e8c37e);
    }
  </style>
  

  

</head>
</html>
<body>
  <div id="container" q-class="show:isCtnShow">
    <canvas id="anm-canvas" class="anm-canvas"></canvas>
    <div class="left-col" q-class="show:isShow">
      
<div class="overlay" style="background: #4d4d4d"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="" class="js-avatar">
		</a>
		<hgroup>
		  <h1 class="header-author"><a href="/">王宇</a></h1>
		</hgroup>
		
		<p class="header-subtitle">记录一个程序员的学习历程</p>
		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/cpp/">C\C++</a></li>
	        
				<li><a href="/tags/linux/">Linux</a></li>
	        
				<li><a href="/tags/算法/">算法</a></li>
	        
				<li><a href="/tags/数据库/">数据库</a></li>
	        
				<li><a href="/tags/大数据/">大数据</a></li>
	        
				<li><a href="/tags/图形图像/">图形图像</a></li>
	        
				<li><a href="/tags/应用实践/">应用实践</a></li>
	        
				<li><a href="/tags/游记/">游记</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
    		
    			
    			<a q-on="click: openSlider(e, 'innerArchive')" href="javascript:void(0)">所有文章</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'friends')" href="javascript:void(0)">友链</a>
    			
            
    			
    			<a q-on="click: openSlider(e, 'aboutme')" href="javascript:void(0)">关于我</a>
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
		        
					<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col" q-class="show:isShow,hide:isShow|isFalse">
      
<nav id="mobile-nav">
  	<div class="overlay js-overlay" style="background: #4d4d4d"></div>
	<div class="btnctn js-mobile-btnctn">
  		<div class="slider-trigger list" q-on="click: openSlider(e)"><i class="icon icon-sort"></i></div>
	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author js-header-author">王宇</h1>
			</hgroup>
			
			<p class="header-subtitle"><i class="icon icon-quo-left"></i>记录一个程序员的学习历程<i class="icon icon-quo-right"></i></p>
			
			
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
				
			
			
			
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github"><i class="icon-github"></i></a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo"><i class="icon-weibo"></i></a>
			        
						<a class="rss" target="_blank" href="#" title="rss"><i class="icon-rss"></i></a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu"><i class="icon-zhihu"></i></a>
			        
				</div>
			</nav>

			<nav class="header-menu js-header-menu">
				<ul style="width: 70%">
				
				
					<li style="width: 11.11111111111111%"><a href="/">主页</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/cpp/">C\C++</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/linux/">Linux</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/算法/">算法</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/数据库/">数据库</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/大数据/">大数据</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/图形图像/">图形图像</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/应用实践/">应用实践</a></li>
		        
					<li style="width: 11.11111111111111%"><a href="/tags/游记/">游记</a></li>
		        
				</ul>
			</nav>
		</header>				
	</div>
	<div class="mobile-mask" style="display:none" q-show="isShow"></div>
</nav>

      <div id="wrapper" class="body-wrap">
        <div class="menu-l">
          <div class="canvas-wrap">
            <canvas data-colors="#eaeaea" data-sectionHeight="100" data-contentId="js-content" id="myCanvas1" class="anm-canvas"></canvas>
          </div>
          <div id="js-content" class="content-ll">
            
  
    <article id="post-eSpeak安装部署记录" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2013/04/22/eSpeak安装部署记录/">eSpeak安装部署记录</a>
    </h1>
  

        
        <a href="/2013/04/22/eSpeak安装部署记录/" class="archive-article-date">
  	<time datetime="2013-04-22T09:21:40.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2013-04-22</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>一、环境</p>
<p>1、Win7 64位 +  VMware Player 4.0.1 build-528992</p>
<p>2、Open SUSE 11.04 Kernel version ：2.6.37.1-1.1-default</p>
<p>3、gcc g++ version 4.5.1</p>
<p>gdb (7.2-3.3)</p>
<p>  glibc :2.11.3</p>
<p>  make:3.82</p>
<p>  vim version 7.3</p>
<p>  4、下载eSpeak  :</p>
<p>  espeak-1.47.05-source.zip :<a href="http://espeak.sourceforge.net/download.html" target="_blank" rel="noopener">http://espeak.sourceforge.net/download.html</a></p>
<p>  portaudio_v18.zip               :<a href="http://www.portaudio.com" target="_blank" rel="noopener">www.portaudio.com</a></p>
<p>portaudio_v19_20111121.tgz (此版本不兼容espeak)</p>
<p>  二、编译调试</p>
<p>  1、首先安装PortAudio</p>
<p>  eSpeak 支持两种音频框架，一种是PortAudio,另一种是PulseAudio,后者过于复杂，由于时间原因，没有深入调试</p>
<p>  (1) 解包：</p>
<p>  unzip portaudio_v18.zip</p>
<p>  cd poraudio_v18</p>
<p>  (2)查看Linux系统中的音频驱动：</p>
<p>  ll /dev/ | grep ‘audio’</p>
<p>  输出如下：</p>
<p>  rw-rw—- 1 root audio    14,  12 Apr 22 11:17 adsp<br>  crw-rw—- 1 root audio    14,   4 Apr 22 11:17 audio<br>  crw-rw—- 1 root audio    14,   9 Apr 22 11:16 dmmidi<br>  crw-rw—- 1 root audio    14,   3 Apr 22 11:17 dsp<br>  crw-rw—- 1 root audio    14,   2 Apr 22 11:16 midi<br>  crw-rw—- 1 root audio    14,   0 Apr 22 11:17 mixer</p>
<p>  (3) 修改PortAudio 驱动程序</p>
<p>  cd ./pa_unix_oss/</p>
<p>  vim ./pa_unix_osss.c</p>
<p>  133行：#define DEVICE_NAME_BASE            “/dev/dsp”   将此处注释掉，新插入一行：</p>
<p>#define DeVICE_NAME_BASE            “/dev/adsp”</p>
<p>  此处的修改原因是：PortAudio无法打开音频驱动dsp,会导致PortAudio的初始化错误。我尝试了audio依然无法使用。最后尝试使用音频驱动adsp，通过测试，成功运行了PortAudio</p>
<p>  (4)编译</p>
<p>  cd portaudio_v18</p>
<p>  make</p>
<p>  make libsintall</p>
<p>  (5)测试PortAudio</p>
<p>  cd pa_unix_oss</p>
<p>  vim Makefile</p>
<p>  10-29行为PortAudio的测试项目，选择第一个patest_sine.c 。将此行的注释去掉，make编译后运行：</p>
<p>make run (会听到类似噪音的测试音效，太难听了。。)</p>
<p>  至此PortAudio 安装调试成功。</p>
<p>  (6) 版本兼容问题：                      </p>
<p>  如果使用PortAudio V19 ,编译eSpeak时，会出现undefined reference to `Pa_StreamActive’的错误。                </p>
<p>  2、编译安装eSpeak</p>
<p>  (1) 解压： </p>
<p>  unzip espeak-1.47.05-source.zip</p>
<p>  (2) 修改Makefile 同 PortAudio 关联上</p>
<p>  cd ./espeak-1.47.05-source/src</p>
<p>  vim Makefile</p>
<p>  30行：AUDIO = portaudio  注释掉</p>
<p>  31行：AUDIO = portaudio0  注释打开</p>
<p>  53行：LIB_AUDIO=/usr/lib/libportaudio.so.0   注释掉  插入一行</p>
<p>  LIB_AUDIO=/usr/liblibportaudio.so</p>
<p>  如果以上方法认为过于复杂，可以采用链接(link)文件的方法，重要的是在编译eSpeak时，准确的使用PortAudio 的libportaudio.so动态库，即可。</p>
<p>  (3) 编译</p>
<p>  cd ./espeak-1.47.05-source/src</p>
<p>  make</p>
<p>  make install      //执行此命令时注意，在src的上一级目录中，一定要有espeak-data目录</p>
<p>  三、运行和日志</p>
<p>  运行：</p>
<p>  espeak “I am programmer good job”</p>
<p>  执行后可以听到一个男老外的声音，呵呵。。。</p>
<p>  日志：</p>
<p>  打开文件/tmp/espeak.log   可以看到执行时的日志记录</p>
<p>  调试：</p>
<p>  打开debug.h 文件</p>
<p>  4行：//#define DEBUG_ENABLED    去掉注释，编译eSpeak后，可以进入调试模式，但是运行调试的时候会出现Segmentation fault (段错误，通常是非法指针或空指针的问题)</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color5">应用实践</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2013/04/22/eSpeak安装部署记录/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-UNIX环境高级编程-文件及标准IO" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/12/06/UNIX环境高级编程-文件及标准IO/">UNIX环境高级编程-文件及标准IO</a>
    </h1>
  

        
        <a href="/2012/12/06/UNIX环境高级编程-文件及标准IO/" class="archive-article-date">
  	<time datetime="2012-12-06T09:22:58.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-12-06</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>第3章文件I/O</p>
<p>3.1引言 </p>
<p>文件I/O函数–打开文件、读文件、写文件等。UNIX系统中的大多数文件I/O只需用到5个函数：open、read、write、lseek以及close。 </p>
<p>术语不带缓冲指的是每个read和write都调用内核中的一个系统调用。 这些不带缓冲的I/O函数不是ISO C的组成部分，但是，它们是POSIX.1和SingleUNIXSpecification的组成部分</p>
<p>本章将进一步讨论在多个进程间如何共享文件，以及所涉及的内核数据结构：dup、fcntl sysnc  fsysnc ioctl</p>
<p>3.2文件描述 </p>
<p>对于内核而言，所有打开的文件都通过文件描述符引用。文件描述符是一个非负整数。当打开一个现有文件或创建一个新文件时，内核向进程返回一个文件描述符。当读或写一个文件时，使用open或creat返回的文件描述符标识该文件，将其作为参数传递给read或write </p>
<p>按照惯例，UNIX系统shell使用文件描述符0(STDIN_FILENO )与进程的标准输入相关联，文件描述符1(STDOUT_FILENO )与标准输出相关联，文件描述符2(STDERR_FILENO)与标准出错输出相关联。这些常量定义在&lt;unistd.h&gt;中</p>
<p>文件描述符的变化范围0~OPEN_MAX</p>
<p>3.3 open函数 ：打开或创建一个文件 </p>
<p>函数声明：</p>
<p>参数：mode:</p>
<p>O_RDONLY:只读打开</p>
<p>O_WRONLY:只写打开</p>
<p>O_RDWR:读写打开 </p>
<p>O_EXCL:如果同时指定了O_CREAT,而文件已经存在，则会出错。用此可以测试一个文件是否存在，如果不存在，则创建文件，这使测试和创建两者成为一个原子操作</p>
<p>O_TRUNC:如果此文件存在，而且为只写或读写成功打开，则将其长度截短为0</p>
<p>O_NOCTTY:如果pathname指的是终端设备，则不将该设备分配作为此进程的控制终端</p>
<p>O_NONBLOCK:如果pathname指的是一个FIFO、一个块特殊文件或一个字符特殊文件，则此选项为文件的本次打开操作和后续的I/O操作设置为非阻塞模式</p>
<p>O_DSYNC:使每次write等待物理I/O操作完成，但是如果写操作并不影响读取刚写入的数据，则不等待文件属性被更新</p>
<p>O_RSYSC:使每一个以文件描述符作为参数的read操作等待，直至任何对文件同一部分进行的未决写操作都完成</p>
<p>O_SYNC:使每次write等待物理I/O操作完成，包括由write操作引起的文件属性更新所需的I/O.(写时，同步更新文件属性)</p>
<p>返回值：返回的文件描述符一定是最小的未用描述符数值 ,否则返回-1 。 </p>
<p>3.4 create函数 ：创建一个新文件 </p>
<p>函数声明：</p>
<p>参数：同open的参数等效</p>
<p>不足之处以只写方式打开所创建的文件。</p>
<p>返回值：</p>
<p>3.5 close函数 ：关闭一个打开的文件 </p>
<p>函数声明：</p>
<p>3.6 lseek函数 </p>
<p>每个打开的文件都有一个与其相关联的“当前文件偏移量”(currentfileoffset).它通常是一个非负整数，用以度量从文件开始处计算的字节数</p>
<p>按系统默认的情况，当打开一个文件时，除非指定O_APPEND选项，否则该偏移量被设置为0</p>
<p>函数声明：</p>
<p>3.7 read函数 :从打开文件中读数据 </p>
<p>函数声明：</p>
<p>参数：    </p>
<p>返回值：如read成功，则返回读到的字节数，如已到达文件结尾，则返回0 </p>
<p>3.8 write函数 :向打开的文件写数据 </p>
<p>函数声明：</p>
<p>参数：</p>
<p>返回值：其返回值通常与参数n bytes的值相同，否则表示出错。 </p>
<p>3.9 I/O的效率 </p>
<p>程序清单：3-3</p>
<p>它从标准输入读，写至标准输出，这就假定在执行本程序之前，这些标准输入、输出已经由shell安排好</p>
<p>很多应用程序假定标准输入是文件描述符0（STDIN_FILENO），标准输出是文件描述符1（STDOUT_FILENO） </p>
<p>进程终止时，UNIX系统内核会关闭该进程的所有打开的文件描述符，所以本程序没有关闭输入和输出 </p>
<p>对UNIX系统内核而言，文本文件和二进制文件并无区别</p>
<p>**如何选取BUFFSIZE值 ，表3-2</p>
<p>此测试所用的文件系统是Linux ext2文件系统，其块长为4096字节 ，系统CPU时间的最小值出现在BUFFSIZE为4096 </p>
<p>3.10 文件共享 </p>
<p>UNIX系统支持在不同进程间共享打开的文件</p>
<p>内核使用三种数据结构表示打开的文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。</p>
<p>图3-1</p>
<p>图3-2</p>
<p>参考《深入理解linux内核》文件</p>
<p>3.11 原子操作 </p>
<p>[1]添写至一个文件</p>
<p>问题出在逻辑操作“定位到文件尾端处，然后写”上，它使用了两个分开的函数调用。解决问题的方法是使这两个操作对于其他进程而言成为一个原子操作。</p>
<p>UNIX系统提供了一种方法使这种操作成为原子操作，该方法是在打开文件时设置O_APPEND标志。正如前一节中所述，这就使内核每次对这种文件进行写之前，都将进程的当前偏移量设置到该文件的尾端处，于是在每次写之前就不再需要调用lseek</p>
<p>[2]pread和pwrite函数</p>
<p>Single UNIX Specification包含了XSI扩展，该扩展允许原子性定位搜索(seek)和执行I/O</p>
<p>pread和pwrite函数格式：</p>
<p>[3]创建一个文件</p>
<p>一般而言，原子操作(atomicoperation)指的是由多步组成的操作，如果该操作原子地执行，则要么执行完所有步骤，要么一步也不执行，不可能只执行所有步骤的一个子集。        </p>
<p>3.12 dup和dup2函 数：用来复制一个现存的文件描述符</p>
<p>函数定义</p>
<p>图3-3**</p>
<p>复制文件描述符可以用作重定向。复制一个文件描述符，具有两个，关闭一个，另一个不被关闭。复制与打开同一个文件，获得文件描述符的区别是，复制具有同一个文件表，而打开具有不同的文件表</p>
<p>3.13 sync、fsync和fdatasync函数 </p>
<p>当将数据写入文件时，内核通常先将该数据复制到其中一个缓冲区中，如果该缓冲区尚未写满，则并不将其排入输出队列，而是等待其写满或者当内核需要重用该缓冲区以便存放其他磁盘块数据时，再将该缓冲排入输出队列，然后待其到达队首时，才进行实际的I/O操作。这种输出方式被称为延迟写     </p>
<p>为了保证磁盘上实际文件系统与缓冲区高速缓存中内容的一致性，UNIX系统提供了sync、fsync、fdatasync 三个函数</p>
<p>函数定义：</p>
<p>sync函数只是将所有修改过的块缓冲区排入写队列，然后就返回，它并不等待实际写磁盘操作结束</p>
<p>fsync函数只对文件描述符filesets指定的单一文件起作用，并且等待写磁盘结束，然后返回。</p>
<p>fdatasync函数类似于fsync函数，但它只影响文件的数据部分，而除数据外，fsync还会同步更新文件的属性</p>
<p>3.14 fcntl函数：改变已打开文件的性质</p>
<p>函数定义：</p>
<p>fcntl有5种功能：</p>
<p>复制一个现有的描述符：cmd=F_DUPFD</p>
<p>获得、设置文件描述符：cmd=F_GETFDF_SETFD</p>
<p>获得、设置文件状态标志：cmd=F_GETFLF_SETFL</p>
<p>获得、设置异步I/O所有权：cmd=F_GETOWNF_SETOWN</p>
<p>获得、设置记录锁：cmd=F_GETLKF_SETLKF_SETLKW</p>
<p>程序清单：3-43-5    </p>
<p>3.15 ioctl函数 </p>
<p>函数定义：    </p>
<p>3.16 /dev/fd </p>
<p>较新的系统都提供名为/dev/fd的目录，其目录项是名为0,1,2等的文件，打开文件/dev/fd/n等效于复制描述符n</p>
<p>fd=open(“/dev/fd/0”,mode);等效fd=dup(0);</p>
<p>第4章文件和目录 </p>
<p>4.1引言 </p>
<p>4.2stat、fstat和lstat函数 </p>
<p>函数定义：</p>
<p>stat函数 就返回与此命名文件有关的信息结构</p>
<p>fstat函数 获取已在描述符filedes上打开文件的有关信息</p>
<p>lstat函数 与stat类似，但是当命名的文件是一个符号链接时，lstat返回该符号链接的有关信息</p>
<p>struct stat结构体</p>
<p>4.3文件类型 </p>
<p>普通文件</p>
<p>目录文件</p>
<p>块特殊文件</p>
<p>字符特殊文件</p>
<p>FIFO</p>
<p>套接字</p>
<p>符号链接</p>
<p>4.4设置用户ID和设置组ID </p>
<p>与一个进程相关联的ID有6个或更多，表4-4**</p>
<p>实际用户ID和实际组ID标识我们究竟是谁</p>
<p>有效用户ID，有效阻ID以及附加组ID决定了我们的文件访问权限 </p>
<p>保存的设置用户ID和保存的设置组ID在执行一个程序时包含了有效用户ID和有效阻ID的副本</p>
<p>通常，有效用户ID等于实际用户ID，有效组ID等于实际组ID    </p>
<p>每个文件都有一个所有者和组所有者，所有者由stat结构中的st_uid成员表示，组所有者则由st_gid成员表示</p>
<p>4.5文件访问权限 </p>
<p>所有文件类型都有访问权限，很多人认为只有普通文件有访问权限，这是一种误解 </p>
<p>每个文件有9个访问限位，可将它们分为三类,见表4-5</p>
<p>chmod(1)命令用于修改这9个权限位</p>
<p>使用方式汇总：</p>
<p>第一个规则是，我们用名字打开任一类型的文件时，对该名字中包含的每一个目录，包括它可能隐含的当前工作目录都应具有执行权限 。例如：打开文件：/usr/include/stdio.h需要对目录/、/usr和/usr/include具有执行权限</p>
<p>对于一个文件的读权限决定了我们是否能够打开该文件进行读操作</p>
<p>对于一个文件的写权限决定了我们是否能够打开该文件进行写操作</p>
<p>为了在open函数中对一个文件指定O_TRUNC标志，必须对该文件具有写权限</p>
<p>为了在一个目录中创建一个新文件，必须对该目录具有写权限和执行权限</p>
<p>为了在一个目录中删除一个现有文件，必须对该目录具有写权限和执行权限 </p>
<p>如果用6个exec函数中的任何一个执行某个文件，都必须对该文件具有执行权限。</p>
<p>进程每次打开、创建或删除一个文件时，内核就进行文件访问权限测试 ：</p>
<p>(1)若进程的有效用户ID是0（超级用户）,则允许访问</p>
<p>(2)若进程的有效用户ID等于文件的所有者ID，那么：若所有者适当的访问权限被设置，则允许访问，否则拒绝访问。</p>
<p>(3)若进程的有效组ID或进程的附加组ID之一等于文件的组ID，那么：若组适当的访问权限被设置，则允许访问，否则拒绝访问。</p>
<p>(4)若其他用户适当的访问权限位被设置，则允许访问，否则拒绝访问</p>
<p>4.6新文件和目录的所有权 </p>
<p>新文件的用户ID设置为进程的有效用户ID</p>
<p>(1)新文件的组ID可以是进程的有效组ID</p>
<p>(2)新文件的组ID可以是它所在目录的组ID</p>
<p>4.7access函数 </p>
<p>当用open函数打开一个文件时，内核以进程的有效用户ID和有效组ID为基础执行其访问权限测试。有时，进程也希望按其实际用户ID和实际组ID来测试其访问能力 </p>
<p>access函数是按实际用户ID和实际组ID进行访问权限测试的 </p>
<p>函数定义：表4-6</p>
<p>4.8umask函数： 为进程设置文件模式创建屏蔽字，并返回以前的值(屏蔽权限) </p>
<pre><code>函数定义：



进程创建一个新文件或新目录时，就一定会使用文件模式创建屏蔽字



4.9chmod和fchmod函数:更改现有文件的访问权限 

函数定义：



chmod函数在指定的文件上进程操作，而fchmod函数则对已打开的文件进行操作

为了改变一个文件的权限位，进程的有效用户ID必须等于文件的所有者ID，或者该进程必须具有超级用户权限



4.10粘住位 

4.11chown、fchown和lchown函数：更改文件的用户ID和组ID 

函数定义：



4.12文件长度 

stat结构成员st_size表示以字节为单位的文件长度。此字段只对普通文件、目录文件和符号链接有意义 

大多数UNIX系统提供字段st_balsize和st_blocks.其中，第一个是对文件I/O较合适的块长度，第二个是所分配的实际512字节数量

文件中的空洞：是由所设置的偏移量超过文件尾端，并写了某些数据后造成的 

4.13文件截短 

需要在文件尾端处截去一些数据以缩短文件。 

函数定义：



4.14文件系统 

为了说明文件链接的概念，先要介绍UNIX文件系统的基本结构。同时，了解i节点和指向i节点的目录项之间的区别也是很有益的。

我们可以把一个磁盘分成一个或多个分区。每个分区可以包含一个文件系统。图4-1** 



i节点是固定长度的记录项，它包含有关文件的大部分信息

图：4-2较详细的柱面组的i节点和数据块



节点号相同，不同文件名

图：4-3




4.15link、unlink、remove和rename 

任何一个文件可以有多个目录项指向其i节点，创建一个指向现有文件的链接的方法是使用link函数

函数定义：



删除一个现有的目录项，可以调用unlink函数：

函数定义：



remove函数解除对一个文件或目录的链接

函数定义：



4.16符号链接 

符号链接是指向一个文件的间接指针，它与上一节所述的硬链接有所不同，硬链接直接指向文件的i节点。引入符号链接的原因是为了避开硬链接的一些限制： 

硬链接通常要求链接和文件位于同一文件系统中

只有超级用户才能创建指向目录的硬链接

对符号链接以及它指向何种对象并无任何文件系统限制，任何用户都可创建指向目录的符号链接。符号链接一般用于将一个文件或整个目录结构移到系统中的另一个位置    

4.17synlink和readlink函数： 创建和读取符号链接 

函数定义：



4.18文件的时间 

对每个文件保持有三个时间字段，表4-10

注意修改时间(st_time)和更改状态时间(st_ctime)之间的区别。修改时间是文件内容最后一次被修改的时间。更改状态时间是该文件的i节点最后一次被修改的时间

4.19utime函数： 一个文件的访问和修改时间可以用utime函数更改

函数定义：



4.20mkdir和rmdir函数： 创建和删除目录 

函数定义：



4.21读目录 

对某个目录具有访问权限的任一用户都可读该目录，但是，为了防止文件系统产生混乱，只有内核才能写目录

函数定义：



4.22chdir、fchdir和getcmd函数: 更改获得当前目录 

每个进程都有一个当前工作目录，此目录是搜索所有相对路径名的起点

函数定义：



4.23设备特殊文件 

st_dev和st_rdev这两个字段经常引起混淆，有关规则：

每个文件系统所在的存储设备都由其主、次设备号表示。设备号所用的数据类型是基本系统数据类型dev_t.主设备号标识设备驱动程序，有时编码为与通信的外设板；此设备号标识特定的子设备

我们通常可以使用两个宏即major和minor来访问主、次设备号，大多数实现都定义了这两个宏

系统中与每个文件名关联的st_dev值是文件系统的设备号，该文件系统包含了这一文件名以及其对应的i节点

只有字符特殊文件和块特殊文件才有st_rdev值，此值包含实际设备的设备号

4.24文件访问权限位小结 

表4-12文件访问权限位小结

第5章标准I/O库 

5.1引言 

5.2流和FILE对象 

所有I/O函数都是针对文件描述符的。当打开一个文件时，即返回一个文件描述符，然后该文件描述符就用于后续的I/O操作。而对于标准I/O库，它们的操作则是围绕流进行的。当用标准I/O库打开或创建一个文件时，我们已使一个流与一个文件相关联。 

对于ASCII字符集，一个字符用一个字节表示.对于国际字符集，一个字符可用多个字节表示。标准I/O文件流可用于单字节或多字节(&quot;宽&quot;)字符集。流的定向决定了所读、字符集是单字节还是多字节。当一个流最初被创建时，它并没有定向。如若在未定向的数据流上使用一个多字节I/O函数，则将该流的定向设置为宽定向的。若在为定向的流上使用一个单字节I/O流函数，则将该流的定向设置为字节定向的。只有两个函数可以改变流的定向。freopen函数清除一个流的定向；fwide函数设置流的定向 

函数定义：



当打开一个流时，标准I/O函数fopen返回一个指向FIFE对象 的指针。该对象通常是一个结构，它包含了标准I/O库为管理流所需要的所有信息。包括：用于实际I/O的文件描述符，指向用于该流缓冲区的指针、缓冲区的长度、当前在缓冲区中的字符数以及出错标志等等。

5.3标准输入、标准输出和标准出错 

对一个进程预定义了三个流 ，并且这三个流可以自动地被进程使用，它们是：标准输入、标准输出和错误输出 。

文件描述符：STDIN_FILENO STDOUT_FILENO STDERR_FILENO 

标准I/O流通过预定义文件指针stdinstdout和stderr加以引用&lt;stdio.h&gt;

5.4缓冲 

标准I/O库提供缓冲的目的是尽可能减少使用read和write调用的次数 

标准I/O提供了三个类型的缓冲 ：

(1)全缓冲 ：在填满标准I/O缓冲区后才进行实际I/O操作。对于驻留在磁盘上的文件通常是由标准I/O库实施全缓冲的。在一个流上执行第一次I/O操作时，相关标准I/O函数通常调用malloc获得需使用的缓冲区。

术语冲洗（flush）：说明标准I/O缓冲区的写操作。缓冲区可由标准I/O例程自动冲洗，或者可以调用fflush冲洗一个流。

flush有两种意思：

在标准I/O库方面，flush意味着将缓冲区的内容写到磁盘上。

在终端驱动程序方面，flush表示丢弃已经存在缓冲区中的数据

(2)行缓冲 ：当在输入和输出中遇到换行符时，标准I/O库执行I/O操作。

行缓存的两个限制：

因为标准I/O库用来收集每一行的缓冲区的长度是固定的，所以只要填满了缓冲区，那么即使还没有写一个换行符，也进行I/O操作。

任何时候只要通过标准I/O库要求从一个不带缓冲区的流，或者一个行缓冲区的流得到输入数据，那么就会造成冲洗所有行缓冲区输出流。

(3)不带缓冲 ：标准I/O库不对字符进行缓冲存储

标准出错流stderr通常是不带缓冲区的，这就使得出错信息可以尽快显示出来，而不管它们是否有一个换行符

IOS C要求缓冲特征：

当且仅当标准输入和标准输出并不涉及交互设备时，它们才是全缓冲的。 

标准出错绝不会是全缓冲的

标准出错是不带缓冲的 

如若是涉及终端设备的其他流，则它们是行缓冲的；否则是全缓冲的 

两个更改缓冲区类型函数定义：



setbuf函数打开或关闭缓冲机制

setvbuf可以精确地制定缓冲区的类型，mode：

_IOFBF全缓冲

_IOLBF行缓冲

_IONBF不带缓冲

fflush:强制冲洗流

函数定义：



5.5打开流

函数定义：



fopen打开一个指定的文件 

freopen在一个指定的流上打开一个指定的文件，如若该流已经打开，则先关闭该留。若该流已经定向，则freopen清楚该定向。此函数一般用于将一个指定的文件打开为一个预定义的流：标准输入、标准输出和标准出错

fdopen获取一个现有的文件描述符，并是一个标准的I/O流与该描述符相结合。此函数常用于创建管道和网络通信通道函数返回的描述符。

表5-2



表5-3



fclose函数定义：



当一个进程正常终止时，则所有带未写缓冲数据的标准I/O流都会被冲洗，所有打开的标准I/O流都会被关闭 

5.6读和写流 

一旦打开了流，则可在三种不同类型的非格式化I/O中进行选择 ，对其进行读写操作：

(1)每次一个字符的I/ O，一次读和写一个字符，如果流是带缓冲的，则标准I/O函数会处理所有缓冲。

(2)每次一行的I/O ，如果想要一次读或写一行，则使用fgets和fputs。每行都以一个换行符结束。当调用fgets时，应说明能处理的最大行数

(3)直接I/O, fread和fwrite函数支持这种类型的I/O，每次I/O操作读或写某种数量的对象，而每个对象具有指定的长度。这两个函数常用于从二进制文件中每次读或写一个结构。

输入函数

可用于一次读一个字符

函数定义：



函数getchar等价于getc(stdin)。前两个函数的区别是getc可被实现为宏，而fgetc不能实现为宏。这意味着：

(1)getc的参数不应道具有副作用的表达式

(2)因为fgetc()一定是一个函数，所以可以得到其地址。这就允许将fgetc的地址作为一个参数传递给另一个函数。

(3)调用fgetc所需的时间很可能长于调用getc，因为调用函数所需的时间长于调用宏。 

这三个函数在返回下一个字符时，会将其unsigned char类型转换为int类型。说明为不带符号的理由是，如果最高位为1也不会使返回值为负。要求整数返回值的理由是，这样就可以返回所以可能的返回值再加上一个出错或已到达文件尾端的指示值。在&lt;stdio.h&gt;中的常量EOF被要求是一个负值，其值经常是-1.

注意，不管是出错还是到达文件尾端，这三个函数都返回同样的值，为了区分这两种不同的情况，必须调用ferror和feof

函数定义：



从流中读取数据以后，可以调用ungetc将字符再压回流中

函数定义：



压送回流中的字符以后又可以从流中读出，但读出字符的顺序与压送回的顺序相反。应当了解，虽然ISOc允许实现支持任何次数的回送，但它要求实现提供一次只送回一个字符。我们不能期望一次能送回多个字符。

输出函数

函数定义：



与输入函数一样，putchar(c)等效于putc(c,stdin),putc可以实现为宏，fputc不能实现为宏

5.7每次一行I/O 

两个函数实现每次输入一行的功能：

函数定义：



这两个函数都制定了缓冲区的地址，读入的行将送入其中。gets从标准输入读，而fgets则从指定的流中读。

对于fgets必须制定缓冲区的长度n。此函数一直读到下一个换行符为止，但是不超过n-1个字符，读入的字符被送到缓冲区。该缓冲区以null字符结尾。如若该行的字符数超过n-1,则fgets只返回一个不完整的行，但是，缓冲区总是以null结尾。对fgets的下一次调用会继续读入该行。

gets是一个不推荐使用的函数。其问题是调用者在使用gets时不能指定缓冲区的长度。这样就可能造成缓冲区溢出，写到缓冲区之后的存储空间中，从而产生不可预料的后果。 

gets与fgets另一个区别是，gets并不将换行符存入缓冲区中。

即使IOSC要求实现提供gets，但请使用fgets，而不要使用gets。

fputs和puts提供每次输入一行的功能：

函数定义：



fputs将一个以null符终止的字符串写到指定的流、尾端的终止符null不写出。注意，这并不一定是每次输出一行，因为它并不要求每次在null之前一定是一个换行符。通常，在null之前是一个换行符，但并不要求总是如此。

puts将一个以null符终止的字符串写到标准输出，终止符不写出。但是，puts然后又将一个换行符写到标准输出。

puts并不像它所对应的gets那样不安全，但是我们还是应该避免使用它，以免需要记住它在最后是否添加了一个换行符。

如果总是使用fgets和fputs，那么就会熟知在每行终止处我们必须自己处理换行符

5.8标准I/O的效率 

程序清单：5-15-1

系统CPU时间几乎相同，原因是所有这些程序对内核提出的读、写请求数基本相同。注意，使用标准I/O的一个好处是无需考虑缓冲及最佳I/O长度的选择。在使用fgets时需要考虑最佳行长，但是与选择最佳I/O长度比较，这要方便的多。 

使用getc和putc的版本与使用fgetc和fputc的版本在文本空间长度方面大体相同。？？

5.9二进制I/O 

函数定义：



(1)读或写一个二进制数组：例如,将浮点组的第2-5个元素写至一个文件中

float data[10];

if(fwrite(&amp;data[2],sizeof(float),4,fp)!=4) perror(&quot;fwriteerror!&quot;);

(2)读或写一个结构，例如，

struct{

    short count;

    long total;

    char name[NAMESIZE];

}item;</code></pre><p>if((fwrite(&amp;item,sizeof(item),1,fp))!=1) perror(“fwriteerror!”);</p>
<p>fread和fwrite返回读或写的对象数，对于读，如果出错或到达文件尾端，则返回数字可以少于nobj(n)。在这种情况下，应该调用ferror或feof以判断究竟应该属于哪一种情况。对于写，如果返回值少于所要求的nobj,则出错。    </p>
<p>使用二进制I/O的基本问题是，它只能用于读在同一系统上已写的数据。</p>
<p>5.10定位流 </p>
<p>有三种方法定位I/O流： </p>
<p>(1)ftell和fseek函数，这两个函数自V7以来就存在了，但是它们都假定文件的位置可以存放在一个长整型中。</p>
<p>(2)ftello和fseeko函数，SingleUNIXSpecification引入了它们，可以使文件的偏移量不必一定使用长整型，它们使用了off_t数据类型替代了长整型。</p>
<p>(3)fgetpos和fsetpos函数，这两个函数是由IOSC引入的。它们使用一个抽象数据类型fpos_t记录文件的位置。这种数据类型可以定义为记录一个文件位置所需的长度。 </p>
<p>函数定义：</p>
<p>对于一个二进制文件，其文件位置指示器是从文件开始位置开始度量,并以字节为计量单位。ftell用于二进制文件时，其返回值就是这个字节的位置。</p>
<p>SET_SET:表示从文件的开始位置开始</p>
<p>SET_CUR:表示从文件的当前位置开始</p>
<p>SET_END:表示从文件的尾端开始</p>
<p>5.11格式化I/O </p>
<p>(1)格式化输出：执行格式化输出处理的是4个函数</p>
<p>函数定义：</p>
<p>printf将格式化数据写到标准输出</p>
<p>fprintf写至指定的流</p>
<p>sprintf将格式化的字符送入数组buf中，它在该数组的尾端自动加一个null字节，但该字节不包含在返回值中。</p>
<p>注意，sprintf函数可能造成由buf指定的缓冲区的溢出。调用者有责任确保缓冲区足够大。为了解决这种缓冲区问题，引入了snprintf函数，在该函数中，缓冲区长度是一个显示参数，超过缓冲区尾端写入的任何字符都会被丢失。如果缓冲区足够大，snprintf函数就会返回写入缓冲区的字符数。</p>
<p>转换说明以字符%开始，除转换说明外，格式字符中的其他字符将按原样，不经任何修改的复制输出。</p>
<p>一个转换说明格式有4个可选部分 ：</p>
<p>%<a href="说明转换的最小字段宽度。如果转换的字符较少，则用空格填充它。字符宽度是一个非负十进制数，或是一个型号(*)">flags</a><a href="说明参数长度：表5-6">precision</a>convtype</p>
<p>宽度和精度字段两者皆可为*</p>
<p>convtype:不是可选。它控制如何解释参数:表5-7</p>
<p>下列4中printf族的变体类：</p>
<p>函数定义：</p>
<p>(2)格式化输入:三个scanf函数</p>
<p>函数定义：    </p>
<p>一个转换说明有三个可选部分： </p>
<p>%<a href="说明转换的最小字段宽度。如果转换的字符较少，则用空格填充它。字符宽度是一个非负十进制数，或是一个型号(*)">*</a><a href="说明参数长度：表5-6">lenmodifier</a>convtype </p>
<p>可选的前导星号(*)用于抑制转换。按照转换说明的其余部分对输入进行转换，但转换的结果并不存放在参数中。</p>
<p><a href="说明参数长度：表5-6">lenmodifier</a>要用转换结果初始化的参数大小。由printf函数族支持的长度修饰符同样得到scanf函数族的支持</p>
<p>5.12实现细节 </p>
<p>标准I/O库最终都要调用I/O例程。每个标准I/O流都有一个与其相关的文件描述符，可以对一个流调用fileno函数以获其描述符</p>
<p>函数定义：</p>
<p>为了了解你所使用的系统的标准I/O库的实现，最好从头文件&lt;stdio.h&gt; 开始</p>
<p>5.13临时文件 </p>
<p>IOS C标准I/O库提供了两个函数以帮助创建临时文件：</p>
<p>函数定义：</p>
<p>tempnam函数产生一个与现有文件名不同的一个有效路径名字符串</p>
<p>tmpfile创建一个临时二进制文件(类型wb+),在关闭该文件或程序结束时将自动删除这种文件</p>
<p>5.14标准I/O的替代软件 </p>
<p>标准I/O库并不完善。 </p>
<p>标准I/O库的一个不足之处是效率不高 ，这与它需要复制的数据有关。当时每次一行函数fgets和fputs时，通常需要复制两次数据：一次是在内核和标准I/O缓冲之间，第二次是在标准I/O缓冲区和用户程序中的行缓冲区之间。快速I/O库(AT&amp;Tfio（3）) 避免了这一点。其方法是使读一行的函数返回指向该行的指针，而不是将该行复制到另一个缓冲区中</p>
<p>Korn和Vo[1991] 说明了标准I/O库的另一个替代版本：sfio推广了I/O流，使其不仅可以代表文件，也可以代表存储区：可以编写处理模块，并以栈方式将其压入I/O流，这样就可以改变一个流的操作；较好的异常处理等。</p>
<p>许多标准I/O库的实现可用于C函数库中，这种C函数库是为内存较小的系统（如嵌入式）设计的</p>
<p>第6章系统数据文件和信息 </p>
<p>6.1引言 </p>
<p>UNIX系统的正常运行需要大量与系统有关的数据文件 ，例如：口令文件/etc/passwd组文件/etc/group就是经常由多种程序使用的两个文件</p>
<p>由于历史原因，这些数据文件都是ASCII文本文件 ，并且使用标准I/O库读这些文件</p>
<p>6.2口令文件 </p>
<p>/etc/passwd文件格式注意 ：</p>
<p>通常有一个用户名为root的登录项，其用户ID是0(超级用户)</p>
<pre><code>加密口令字段包括了一个占位字符

口令文件项中的某些字段可能是空的

shell字段包括了一个可执行程序名，它被用作该用户的登录shell。若字段为空，则取系统默认值，通常是/bin/sh。阻止一个用户登录时，此字段为：/dev/null;阻止登录其他的两种方法：/bin/false和/bin/true

使用nobody用户名的目的是，使任何人都可登录至系统

提供finger(1)命令的某些UNIX系统支持注释字段中的附加信息

POSIX定义了两个获取口令文件项的函数:getpwuid()getpwnam()

函数定义：</code></pre><p>查看整个口令文件：getpwent() setpwent() endpwent()</p>
<pre><code>函数定义：



6.3阴影口令 

加密口令是经单向加密算法处理过的用户口令副本。因为此算法是单向的，所以不能从加密口令猜测到原来的口令。 

难以获得原始资料，现在，某些系统将加密口令存放在另一个通常称为阴影口令(shadowpassword)的文件中,该文件至少要包括用户名和加密口令（etc/shadow）

阴影口令文件不应是一般用户可以读取的。但有少数几个程序需要存取加密口令，例如：login(1)和passwd(1)这些程序常常是设置用户ID为root的程序 

另一组函数可用于访问阴影口令文件：

函数定义：



6.4组文件

&lt;grp.h&gt;/etc/group    

POSIX定义的函数来查看组名或数值组ID

函数定义



需要搜索组文件，则需要使用另外几个函数：

函数定义



6.5附加组ID 

在V7中，每个用户在任何时候都只属于一个组。4.2BSD引入了附加组ID(supplementary groupID)的概念，我们不仅可以属于口令文件记录项中组ID所对应的组，也可以属于多达16个另外的组。文件访问权限检查相应被修改为：不仅将进程的有效组ID与文件的组ID相比较，而且也将所有附件组ID与文件组ID相比较。

使用附加组的优点是不必显示地经常更改组。一个用户会参加多个项目，因此也就要同时属于多个组。 

获取和设置附加组ID，三个函数：

函数定义



6.6实现的区别 

表6-4



6.7其他数据文件 </code></pre><p>BSD网络软件有一个记录各网络服务器所提供服务的数据文件(/etc/services),有一个记录协议信息的数据文件(/etc/protoclols),还有一个则是记录网络信息的数据文件(/etc/networks)</p>
<pre><code>一般情况下，对于每个文件至少有三个函数：

(1)get函数

(2)set函数

(3)end函数

6.8登录账号记录 

大多数UNIX系统都提供下列两个数据文件：utmp文件，它记录当前登录进系统的各个用户；wtmp文件，它跟踪各个登录和注销事件

6.9系统标识 

POSIX定义了uname函数 ，它返回与当前主机和操作系统有关的信息

函数定义：



BSD派生的系统提供了gethostname函数，它返回主机名，该名字通常就是TCP/IP网络上主机的名字

函数定义:



6.10时间和日期例程 

time函数返回当前时间和日期：

函数定义



与time函数相比，gettimeofday提供了更高的分辨率（最高为微妙级）这对某些应用很重要

函数定义



localtime和gettime之间的区别是：localtime将日历时间转换成本地时间，而gettime将日历时间转换为国际时间

函数定义



函数mktime以本地时间的年、月、日等作为参数，将其转换为time_t值

函数定义



asctime和ctime函数产生大家都熟悉的26字节的字符串，这与data(1)命令的系统默认输出形式类似

函数定义：



strftime，它是非常复杂的类似printf的时间值函数&lt;Paste&gt;</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/12/06/UNIX环境高级编程-文件及标准IO/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-定是测量" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/11/17/深入理解Linux内核-定是测量/">深入理解Linux内核-定是测量</a>
    </h1>
  

        
        <a href="/2012/11/17/深入理解Linux内核-定是测量/" class="archive-article-date">
  	<time datetime="2012-11-17T09:23:39.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-11-17</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>第六章定时测量 </p>
<p>很多计算机化的活动都是由定时测量(timing measurement)来驱动的，这常常对用户是不可见的。</p>
<p>Linux内核必须完成两种主要的定时测量 ，我们可以对此加以区分：</p>
<p>保存当前的时间和日期 ，以便能通过time()、ftime()和gettimeofday()系统调用把它们返回给用户程序，也可以由内核本身把当前时间作为文件和网络包的时间戳。</p>
<p>维持定时器 ，这种机制能够告诉内核或用户程序某一时间间隔已经过去</p>
<p>定时测量是由基于固定频率振荡器和计数器的几个硬件电路完成的。    </p>
<p>1、时钟和定时器电路 </p>
<p>[1]实时时钟(RTC) </p>
<p>  所有的PC都包含一个叫实时时钟 (Renl Time Clock RTC)的时钟，它是独立于CPU和所有其他芯片的</p>
<p>  即使当PC被切断电源，RTC还继续工作，因为它靠一个小电池或蓄电池供电。COMS RAM和RTC被集成在一个芯片上。 </p>
<p>  RTC能在IRQ8上发出周期性的中断，频率在2-8192Hz之间。也可以对RTC进行编程以使当RTC到达某个特定的值时激活IRQ8线，也就是作为一个闹钟来工作。</p>
<p>  Linux只用RTC来获取时间和日期， 不过通过对/dev/rtc设备文件进行操作，也允许进程对RTC编程。内核通过0x70和0x71I/O端口访问RTC。系统管理员通过执行Unix系统时钟程序可以设置时钟。</p>
<p>[2]时间戳计数器(TSC)</p>
<p>  所有的80x86微处理器都包含一条CLK输入引线，它接收外部振荡器的时钟信号。 </p>
<p>  与可编程间隔定时器传递来的时间测量相比，Linux利用这个寄存器可以获得更精确的时间测量</p>
<p>[3]可编程间隔定时器(PIT) </p>
<p>  可编程间隔定时器(Programmable Interval Timer PIT).PIT的作用类似于微波炉的闹钟，即让用户意识到烹调的时间间隔已经过了。所不同的是，这个设备不是通过振铃，而是发出一个特殊的中断，叫做时钟中断（timerinterupt）来通知内核又一个时间间隔过去了。与闹钟的另一个区别是，PIT永远以内核确定的固定频率不停第发出中断 </p>
<p>  Linux给PC的第一个PIT进行编程，是它以（大约）1000Hz的频率向IRQ0发出时钟中断，即每1ms产生一次时钟中断。这个时间间隔叫做一个节拍(tick),它的长度以纳秒为单位存放在tick_nsec变量中。</p>
<p>  短的节拍产生较高分辨率的定时器，当这种定时器执行同步I/O多路复用(poll()和select()系统调用)时，有助于多媒体的平滑播放和较快的响应时间</p>
<p>  时钟中断的频率取决于硬件体系结构。</p>
<p>  在Linux的代码中，有几个宏产生决定时钟中断频率的常量：</p>
<p>  HZ产生每秒时钟中断的近似个数，也就是时钟中断的频率。在IBM PC上，这个值设置为1000</p>
<p>  CLOCK_TICK_RATE 产生的值为1193182，这个值是8254芯片的内部振荡器频率</p>
<p>  LATCH产生CLOCK_TICK_RATE和HZ的比值再四舍五入后的整数值。这个值用来对PIT编程</p>
<p>  PIT由setup_pit_timer()进行初始化    </p>
<p>  [4]CPU本地定时器 </p>
<p>  CPU本地定时器是一种能够产生单步中断或周期性中断的设备，它类似于可编程间隔定时器，区别： </p>
<p>  APIC计数器是32位，而PIC计数器是16位； 因此，可以对本地定时器编程来产生很低频率的中断</p>
<p>  本地APIC定时器把中断只发送给自己的处理器，而PIT产生一个全局性中断，系统中的任一CPU都可以对其处理。</p>
<p>  APIC定时器是基于总线时钟信号的。每隔1,2,4,8,16,32,64或128总线时钟信号到来时对该定时器进行递减可以实现对其编程的目的。相反，PIT有其自己的内部时钟振荡器，可以更灵活地编程。</p>
<p>[5]高精度事件定时器(HPET) </p>
<p>  高精度事件定时器是由Intel和Microsoft联合开发的一种新型定时器芯片。尽管这种定时器在终端用户机器上还并不普遍，但Linux2.6已经能够支持它们</p>
<p>  [6]ACPI电源管理定时器 </p>
<p>  ACPI电源管理定时器（或称ACPI PMT）是另一种时钟设备，包含在几乎所有基于ACPI的主板上。它的时钟信号拥有大约为3.58MHz的固定频率。该设备实际上是一个简单的计数器， 它在每个时钟节拍到来时增加一次。为了读取计数器的当前值，内核需要访问某个I/O端口，该I/O端口的地址由BIOS在初始化阶段确定</p>
<p>  如果操作系统或者BIOS可以通过动态降低CPU的工作频率或者工作电压来节省电池的电能，那么ACPI电源管理定时器就比TSC更优越。当发生ACPI PMT的频率不会改变。而另一方面，TSC计数器的高频率非常便于测量特别小的时间间隔。</p>
<p>  ACPI 控制CPU的频率，从而控制系统的功耗。</p>
<p>  2、Linux计时体系结构 </p>
<p>  Linux必定执行与定时相关的操作。例如，</p>
<p>  内核周期性地：</p>
<p>  更新自系统启动以来所经过的时间</p>
<p>  更新时间和日期</p>
<p>  确定当前进程在每个CPU上已运行了多长时间，如果已经超过了分配给它的时间，则抢占它。时间片（也叫时限）</p>
<p>  更新资源使用统计数</p>
<p>  检查每个软定时器的时间间隔是否已到。</p>
<p>  Linux的计时体系结构(time keeping architecture)是一组与时间流相关的内核数据结构和函数 </p>
<p>  在单处理器系统上，所有的计时活动都是由全局定时器（可以是可编程间隔定时器也可以是高精度事件定时器）产生的中断触发的</p>
<p>  在多处理器系统上，所有普通的活动（像软定时器的处理）都是由全局定时器产生的中断触发的，而具体CPU的活动是由本地APIC定时器产生的中断触发的。</p>
<p>  [1]计时体系机构的数据结构 </p>
<p>  (1)定时器对象</p>
<p>  为了使用一种统一的方法来处理可能存在的定时器资源，内核使用了”定时器对象”，它是timer_opts类型的一个描述符，该类型由定时器名称和四个标准的方法组成，如表6-1所示：**</p>
<p>  定时器对象中最重要的方法是mark_offset和get_offset.mark_offset方法由时间中断处理程序调用，并以适当的数据结构记录每个节拍到来时的准确时间。get_offset方法使用已记录的值来计算自上一次时钟中断(节拍)以来经过的时间(us为单位).由于这两种方法，使得Linux计时体系结构能够达到子节拍的分辨度，也就是说，内核能够以比节拍周期更高的精度来测定当前的时间，这种操作被称作“定时插补(timerinterpolation)”</p>
<p>  表6-2以优先级顺序列出了80x86体系结构中最常用的定时器对象</p>
<p>  (2)jiffies变量 </p>
<p>  jiffies变量是一个计数器，用来记录自系统启动以来产生的节拍总数。每次时钟中断发生时（每个节拍）它便加1.在80x86体系结构中，jiffies是一个32位的变量，因此每隔大约50天它的值会回绕(wraparound)到0，这对Linux服务器来说是一个相对较短的时间间隔。不过，由于使用了time_after、time_afer_eq、time_before和time_before_eq四个宏，内核干净利索地处理了jiffies变量的益出。</p>
<p>  在80x86系统中，jiffies变量通过连接器被换算成一个64位计数器的低32位，这个64位的计数器被称作jiffies64.在1ms为一个节拍的情况下，jiffies_64变量将会在数十亿年后才发生回绕，所以我们可以放心地假定它不会溢出。</p>
<p>  (3)xtime变量 </p>
<p>  xtime变量存放当前时间和日期；它是一个timespec类型的数据结构，该结构有两个字段：</p>
<p>  tv_sec：存放自1970年1月1日(UTC)午夜以来经过的秒数</p>
<p>  tv_nsec:存放自上一秒开始经过的纳秒数</p>
<p>  xtime变量通常是每个节拍更新一次，也就是说，大约每秒更新1000次。用户程序从xtime变量获得当前时间和日期。内核也经常引用它                </p>
<p>  [2]单处理器系统上的计时体系结构 </p>
<p>  在单处理器系统上，所有与定时有关的活动都是由IRQ线0上的可编程间隔定时器产生的中断触发的。</p>
<p>  （1）初始化阶段：time_init(),操作参见p236-237</p>
<p>  （2）时钟中断处理程序：timer_interrupt(),步骤参见p237-238</p>
<p>  [3]多处理器系统上的计时体系结构    </p>
<p>  多处理器系统可以依赖两种不同的时钟中断源：可编程间隔定时器或高精度事件定时器产生的中断，以及CPU本地定时器产生的中断。</p>
<p>  在linux2.6中，PIT或HPET产生的全局时钟中断触发不涉及具体CPU的活动，比如处理器软定时器和保持系统时间的更新。相反，一个CPU本地时间中断触发涉及本地CPU的计时活动，例如监视当前进程的运行时间和更新资源使用统计数</p>
<p>  （1）初始化阶段</p>
<p>  （2）全局时钟中断处理程序</p>
<p>  （3）本地时钟中断处理程序</p>
<p>  3、更新时间和日期 </p>
<p>  用户程序从xtime变量中获得当前时间和日期。 内核必须周期性地更新该变量，才能使它的值保持相当的精确</p>
<p>  全局时钟中断处理程序调用update_times() 函数更新xtime 变量的值</p>
<p>  4、更新系统统计数 </p>
<p>  内核在与定时相关的其他任务中必须周期性地收集若干数据用于：</p>
<p>  检查运行进程的CPU资源限制</p>
<p>  更新与本地CPU工作负载有关的统计数</p>
<p>  计算平均系统负载</p>
<p>  监管内核代码</p>
<p>  [1]更新本地CPU统计数 </p>
<p>  update_process_times()步骤：参考p241-242</p>
<p>  [2]记录系统负载</p>
<p>  任何Unix内核都要记录系统进行了多少CPU活动。这些统计数据由各种管理实用程序来使用（如top）。用户输入uptime命令后可以看到一些统计数据：如相对于最后1分钟、5分钟、15分钟的“平均负载”。在单处理器系统上，值0意味着没有活跃的进程（除了swapper进程0）在运行，而值1意味着一个单独的进程100%占有100，值大于1说明几个运行着的进程共享CPU</p>
<p>  update_times()在每个节拍都要调用calc_load()函数来计算处于TASK_RUNNING或TASK_UNINTERRUPTIBALE状态的进程数，并用这个数据更新平均系统负载。</p>
<p>  [3]监管内核代码</p>
<p>  Linux包含一个被称为read profiler的最低要求的代码监管器，Linux开发者用其发现内核在内核态的什么地方花费时间。监管器确定内核的“热点”(hotspot)–执行最频繁的内核代码片段。确定内核“热点”是非常重要的，因为这可以指出应当进一步优化的内核函数。</p>
<p>  监管器基于非常简单的蒙特卡洛算法：在每次时钟中断发生时，内核确定该中断是否发生在内核态：如果是，内核从堆栈取回中断发生前的eip寄存器的值，并用这个值揭示中断发生前内核正在做什么。最后，采样数据积聚在“热点”上。</p>
<p>  profile_tick()函数为代码监管器采集数据。这个函数在单处理器系统上是由do_timer_interrupt()调用的（即全局时钟中断处理程序调用的），在多处理器系统上是由smp_local_timer_interrupt()函数调用的（即本地时钟中断处理程序调用的）</p>
<p>  为了激活代码监管器，在Linux内核启动时必须传递字符串参数”profile=N” ,这里2的N次方，表示要监管的代码段的大小。采集的数据可以从/proc/profile文件中读取。可以通过修改这个文件来重置计数器；在多处理器系统上，修改这个文件还可以改变抽样频率。不过，内核开发者并不直接访问/proc/profile文件，而是用readprofile系统命令</p>
<p>  Linux2.6内核还包含了另一个监管器，叫做oprofile .比起readprofile,oprofile除了更灵活、更可定制外，还能用于发现内核代码、用户态应用程序以及系统库中的热点。当使用oprofile时，profile_tick()调用timer_notify()函数来收集这个新监管器所使用的数据。</p>
<p>  [4]检查非屏蔽中断(NMI)监视器 </p>
<p>  在多处理器系统上，Linux为内核开发者还提供了另外一种功能：看门狗系统 （watchdogsystem），这对于探测引起系统冻结的内核bug可能相当有用。为了激活这样的看门狗，必须在内核启动时传递nmi_watchdog参数 </p>
<p>  看门狗基于本地和I/O APIC一个巧妙的硬件特性：它们能在每个CPU上产生周期性的NMI中断。因为NMI中断是不能用汇编语言指令cli屏蔽的，所以，即使禁止中断，看门狗也能检测到死锁</p>
<p>  因而，一旦每个时钟节拍到来，所有的CPU，不管其正在做什么，都开始执行NMI中断处理程序；该中断处理程序又调用do_nmi()。这个函数获得CPU的逻辑号n，然后检查irq_stat数组第n项的apic_timer_irqs字段。如果该CPU字段工作正常，那么，第n项的值必定不同于在前一个NMI中断中读出的值。当CPU正常运行时，第n项的apic_timer_irq字段就会被本地时钟中断处理程序增加，如果计数器没有被增加，说明本地时钟中断处理程序在整个时钟节拍期间根本就没有被执行。</p>
<p>  当NMI中断处理程序检测到一个CPU冻结时，就会敲响所有的钟，它把引起恐慌的信息记录在系统日志文件中，转储该CPU寄存器的内容和内核栈的内容，最后杀死当前进程。这就为内核开发者提供了发现错误的机会 </p>
<p>  5、软定时器和延迟函数 </p>
<p>  定时器是一种软件功能，即允许在将来的某个时刻，函数在给定的时间间隔用完时被调用 。</p>
<p>  超时（time-out）表示与定时器相关的时间间隔已经用完的那个时刻</p>
<p>  相对来说，实现一个定时器并不难。每个定时器都包含一个字段，表示定时器将需要多长时间才能到期。这个字段的初值就是jiffies的当前值加上合适的节拍数。这个字段的值不再改变。每当内核检查定时器时，就把这个到期字段值和当前这一刻jiffies的值相比较，当jiffies大于或等于这个字段存放的值时，定时器到期。</p>
<p>  Linux考虑两种类型的定时器， 即动态定时器 (dynamic timer)和间隔定时器 (internal timer).第一种类型由内核使用，而间隔定时器可以由进程的用户态创建</p>
<p>  这里是有关Linux定时器的警告：因为对定时器函数的检查总是由可延迟函数进行，而可延迟函数被激活以后很长时间才能被执行，因此，内核不能确保定时器函数正好在定时期间开始执行，而只能保证在适当的时间执行它们，或者假定延迟到几百毫秒之后执行它们。因此，对于必须严格遵守定时时间的那些实时应用而言，定时器并不适合。</p>
<p>  除了软定时器外，内核还使用了延迟函数，它执行一个紧凑的指令循环直到指令的时间间隔用完 </p>
<p>  [1]动态定时器</p>
<p>  (1)动态定时器与竞争条件</p>
<p>  (2)动态定时器的数据结构</p>
<p>  (3)动态定时器处理</p>
<p>  (4)动态定时器应用之一:nanosleep()系统调用</p>
<p>  [2]延迟函数</p>
<p>  当内核需要等待一个较短的时间间隔–比方说，不超过几毫秒时，就无需使用软定时器。</p>
<p>  在这种情况下，内核使用udelay()和ndelay()函数：前者接收一个微妙级的时间间隔作为它的参数，并在指定的延迟结束后返回；后者与前者类似，但是指定延迟的参数是纳秒级的</p>
<p>  6、与定时测量相关的系统调用 </p>
<p>  [1]time()和gettimeofday()系统调用 </p>
<p>  time()系统调用被gettimeofday()取代，但是，为了保持向后兼容，Linux中还包含它们。另一个被广泛使用的函数ftime()不再作为一个系统调用执行，它返回从1970年1月1日午夜(UTC)开始所走过的秒数与前1秒内锁走过的毫秒数。</p>
<p>  do_gettimeofday()动作：参考：p253</p>
<p>  拥有root权限的用户态下的进程可以用stime()和settimeofday()中任意一种系统调用来修改当前日期和时间</p>
<p>  [2]adjtimex()系统调用</p>
<p>  尽管时钟的走动确保了所有的系统最终都会从恰当的时间离开，但是，突然改变时间既是一种管理的失误也是一种危险的行为。</p>
<p>  调整互连PC的时钟以使所存取文件的inode中的时间标记值都保持一致</p>
<p>  [3]settimer()和alerm()系统调用 </p>
<p>  Linux允许用户态的进程激活一种叫做间隔定时器的特殊定时器，这种定时器引起了Unix信号被周期性地发送到进程。也可能激活一个间隔定时器以便在指定的延时后它仅发送一个信号。因此，间隔定时器由以下两个方面来刻画。</p>
<p>  发送信号所必需的频率，或者如果只需要产生一个信号，则频率为空</p>
<p>  在下一个信号被产生以前所剩余的时间</p>
<p>  7、与POSIX定时器相关的系统调用 </p>
<p>  POSIX1003.1b标准为用户态程序引入一种新型软定时器，尤其是针对多线程和实时应用程序。这些定时器被称作POSIX定时器。</p>
<p>  要执行每个POSIX定时器，必须向用户态程序提供一些POSIX时钟，也就是说，虚拟时间预定义了分辨率和属性。只要应用程序想使用POSIX定时器，它就创建一个新的定时器资源并指定一个现存的POSIX时钟来作为定时基准。参考表：6-3</p>
<p>  POSIX定时器比传统间隔定时器更灵活、更可靠。它们之间有两个显著区别 ：</p>
<p>  当传统间隔定时器到期时，内核会发送一个SIGALRM信号给进程来激活定时器。而当一个POSIX定时器到期时，内核可以发送各种信号给整个线程应用程序，也可以发送给单个指定的线程。内核还能在应用程序的某个线程上强制执行一个通告器函数，或者甚至什么也不做</p>
<p>  如果一个传统间隔定时器到期了很多次但用户态进程不能接收SIGALRM信号（例如由于信号被阻塞或者进程不处于运行态），那么只有第一个信号被接收到，其他所有SIGALRM信号都丢失了。对于POSIX定时器来说会发生同样的情况，但进程可以调用timer_getoverrun()系统调用来得到自第一个信号产生以来定时器到期的次数</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/11/17/深入理解Linux内核-定是测量/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-UNIX环境高级编程-基础及标准" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/11/07/UNIX环境高级编程-基础及标准/">UNIX环境高级编程-基础及标准</a>
    </h1>
  

        
        <a href="/2012/11/07/UNIX环境高级编程-基础及标准/" class="archive-article-date">
  	<time datetime="2012-11-07T09:23:13.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-11-07</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>第1章UNIX基础知识 </p>
<p>1.1引言 </p>
<p>所有操作系统都需要向它们运行的程序提供各种服务。通常这些服务包含执行新程序、打开文件、读文件、分配存储区、以及获得当前时间等 。本章为不熟悉UNIX的程序设计人员简要介绍UNIX提供的各种服务。</p>
<p>1.2UNIX体系结构 </p>
<p>在严格意义上，可将操作系统定义为一种软件，它控制计算机硬件资源，提供程序运行环境，我们称此软件为内核（kernel），它相对较小 ，位于环境的中心。图1-1**</p>
<p>内核的接口被称为系统调用 </p>
<p>shell是一种特殊的应用程序，它为运行其他应用程序提供了一个接口。 </p>
<p>在广义上，操作系统包括了内核和一些其他软件，这些软件使得计算机能够发挥作用，并给予计算机以独有的特性。这些软件包括系统实用程序（system utilities）应用软件、shell以及公用函数库等  </p>
<p>1.3登录</p>
<p>(1)登录名 </p>
<p>/etc/passwd文件中查看登录名 </p>
<p>格式：登录名：加密口令:数值用户ID(205):数值组ID(105):注释字段:起始目录（/home/sar）:shell程序（/bin/ksh） </p>
<pre><code>sar:x:205:105:StephenRago:/home/sar:/bin/ksh

(2)shell 

shell是一个命令解释器，它读取用户输入，然后执行命令 。表1-1

1.4文件和目录 

1、文件系统 

UNIX文件系统是目录和文件组成的一种层次结构，目录的起点为根(root),其名字是一个字符/。目录(directory)是一个包含许多目录项的文件，在逻辑上，可以认为每个目录项都包含一个文件名，同时还包含说明该文件属性的信息。文件属性是指文件类型、文件大小、文件所有者、文件权限以及文件最后的修改时间等。stat和fstat函数返回包含所有文件属性的一个信息结构

2、文件名 </code></pre><p>目录中的各个名字为文件名(file name)</p>
<p>  创建新目录时会自动创建两个文件名：.(称为点)和..(称为点一点)。点指当前目录，点一点则指父目录。在最高层次的根目录中，点一点与点相同 </p>
<p>  3、路径名 </p>
<p>  一个或多个以斜线分隔的文件名序列构成路径名，以斜线开头的路径名称为绝对路径名，否则称为相对路径名 </p>
<p>  程序清单1-1</p>
<p>  4、工作目录</p>
<p>  每个进程都有一个工作目录，有时称其为当前工作目录。进程可以用chdir函数更改其工作目录。 </p>
<p>  5、起始目录</p>
<p>  登录时，工作目录设置为起始目录，该起始目录从口令文件中相应用户的登录项中取得。</p>
<p>  1.5输入和输出 </p>
<p>  1、文件描述符 </p>
<p>  文件描述符通常是一个小的非负整数，内核用它标识一个特定进程正在访问的文件。当内核打开一个已有文件或创建一个新文件时，它返回一个文件描述符，在读、写文件时，就可使用它 </p>
<p>  2、标准输入、标准输出和标准出错 </p>
<p>按惯例，每当运行一个新程序时，所有shell都为其打开三个文件描述符：标准输入(standard input)、标准输出(standard output)、标准错误(standard error) </p>
<p>  3、不用缓冲的I\O </p>
<p>  函数open、read、write、lseek以及close提供了不用缓冲的I/O.这些函数都使用文件描述符。 </p>
<p>  4、标准I/O</p>
<p>  标准I/O函数提供一种对不用缓冲I/O函数的带缓冲的接口。使用标准I/O函数可以无需担心如何选择最佳的缓冲区大小。使用标准I/O函数的另一个优点是简化了对输入行的处理 </p>
<p>  1.6程序和进程 </p>
<p>  1、程序 </p>
<p>  程序是存放在磁盘上、处于某个目录中的一个可执行文件 </p>
<p>  2、进程和进程ID </p>
<p>  程序的执行实例被称为进程 </p>
<p>  UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID（processID ）</p>
<p>  3、进程控制 </p>
<p>  有三个用于进程控制的主要函数:fork、exec、waitpid </p>
<p>  程序清单1-5</p>
<p>  4、线程和线程ID </p>
<p>  在一个进程内的所有线程共享同一地址空间、文件描述符、栈及与进程相关的属性。</p>
<p>  线程也用ID标识，但是，线程ID只在它所属进程内起作用 </p>
<p>  1.7出错处理 </p>
<p>  当UNIX函数出错时，常常返回一个负值 ，而且整形变量errno通常被设置为含有附加信息的一个值。</p>
<p>  文件&lt;errno.h&gt;中定义了符号errno以及可以赋予它的各种常量，这些常量都以字符E开头</p>
<p>  在linux中，出错常量在errno(3)手册页中列出</p>
<p>  对于errno应当知道两条规则 。</p>
<p>  第一条规则是：如果没有出错，则其值不会被一个例程清除。因此，仅当函数的返回值指明出错时，才检验其值。</p>
<p>  第二条规则是：任一函数都不会将error值设置为0，在&lt;errno.h&gt;中定义的所有常量都不为0 </p>
<p>  C标准定义了两个函数，它们帮助打印错误信息</p>
<p>#include&lt;string.h&gt;</p>
<p>  char*strerror(interrnum);</p>
<p>#include&lt;stdio.h&gt;</p>
<p>  voidperror(constchar*msg); </p>
<p>  出错恢复：</p>
<p>  可将在&lt;errno.h&gt;中定义的各种出错分成致命性和非致命性的两类。对于致命性的错误，无法执行恢复动作，而对于非致命性的错误，有时可以较妥善地进行处理。大多数非致命性出错在本质上是暂时的    </p>
<p>  1.8用户标识 </p>
<p>  1、用户ID</p>
<p>  口令文件登录项中的用户ID(userID)是个数值，它向系统标识各个不同的用户。系统管理员在确定一个用户的登录名的同时，确定其用户ID。用户不能更改其用户ID。通常每个用户有一个唯一的用户ID</p>
<p>用户ID为0的用户为根(root)或超级用户(superuser)</p>
<p>  2、组ID </p>
<p>  口令文件等录项也包括用户的组ID(groupID),它是一个数值。组ID也是由系统管理员在指定用户登录名时分配的</p>
<p>  组文件将组名映射为数字组ID，它通常是/etc/group</p>
<p>  3、附加组ID </p>
<p>  允许一个用户属于另外的组    </p>
<p>  1.9信号 </p>
<p>  信号(signal)是通知进程已发生某种事情的一种技术 </p>
<p>  1.10时间值 </p>
<p>  (1)日历时间</p>
<p>  (2)进程时间，也称为CPU时间 </p>
<p>  1.11系统调用和库函数 </p>
<p>  所有的操作系统都提供多种服务的入口点，程序由此向内核请求服务。这些入口点称为:系统调用 </p>
<p>  第2章UNIX标准化及实现</p>
<p>  2.1引言</p>
<p>  2.2UNIX标准化 </p>
<p>  2.2.1ISO C </p>
<p>  1986年下半年，C程序设计语言的ANSI标准X3.159-1989得到批准。此标准已被采纳为国际标准ISO/IEC9899:1990。ANSI是美国国家标准学会(American National Standards Institute) ,它在国际标准化组织(International Organization for Standardization,ISO)中是代表美国的成员。IEC是国际电子技术委员会（International Electrotechnal Commission）的缩写 </p>
<p>  ISO C标准现在由ISO/IEC的C程序设计语言国际标准化工作组维护和开发，该工作组被称为ISO/IECJTC1/SC22/WG14简称WG14.ISO C标准的意图是提供C程序的可移植性，使其能适合于大量不同的操作系统，而不只是UNIX系统。此标准不仅定义了C程序设计语言的语法和语义，还定义了其标准库[ISO1999第7章；Plauger1992;Kernighan及Ritchie1988中的附录B]，所以该标准是很重要的。</p>
<p>  在1999年，ISO C标准被更新为ISO/IEC9899:1999</p>
<p>  gcc对ISO C标准1999版本的当前符合程度的总结可见：<a href="http://www.gnu.org/software/gcc/c99status.html" target="_blank" rel="noopener">http://www.gnu.org/software/gcc/c99status.html</a></p>
<p>  ISO C库分成24个区，参见表2-1*** </p>
<p>  2.2.2IEEE POSIX </p>
<p>POSIX是一系列由IEEE（Institude of Electricaland Electronics Engineers,电气与电子工程师协会） 制定的标准。POSIX指的是可移植的操作系统接口(Portable OPerating SystemInterface) </p>
<p>  由于1003.1标准定义了一个接口(interface)而不是一种实现(implementation),所以并不区分系统调用和库函数。标准中的所有例程都称为函数。</p>
<p>  标准是不断演变的，1003.1标准也不例外，最终的文档作为IEEEStd.1003.1-1990正式出版[IEEE1990],这也就是国际标准ISO/IEC9945-1:1990。</p>
<p>  表2-2、表2-3、以及表2-4总结了POSIX.1指定的必须和可选的头文件 。因为POSIX.1包括ISOC标准库函数，所以它还需要表2-1中列出的头文件。这4个表总结了本书所讨论的4种UNIX系统实现中包括的头文件</p>
<p>  POSIX.1标准现由称为Austion Group(<a href="http://www.opengroup.org/austin)的开发工作组维护" target="_blank" rel="noopener">http://www.opengroup.org/austin)的开发工作组维护</a></p>
<p>  2.2.3Single UNIX Specification </p>
<p>Single UNIX Specification(单一UNIX规范)是POSIX.1标准的一个超集，定义了一些附加的接口，这些接口扩展了基本的POSIX.1规范所提供的功能。相应的系统接口全集被称为X/Open系统接口(XSI,X/OpenSystemInterface)</p>
<p>  XSI还定义了实现必须支持POSIX.1的哪些可选部分才能认为是遵循XSI的</p>
<p>  由OpenGroup发布</p>
<p>  2.2.4FIPS </p>
<p>  含义是联邦信息处理标准(Federal Information Processmation Standard),它由美国政府出版。本书不进一步考虑它。 </p>
<p>  2.3UNIX系统实现 </p>
<p>  各自独立的组织所制定的三个标准：ISO C IEEE POSIX以及Single UNIX Specification,但是标准只是接口的规范。这些标准由制造商采用，然后转变成具体实现</p>
<p>  UNIX的各种版本和变体都起源与在PDP-11系统上运行的UNIX分时系统第6版(1976年)和第7版(1979年)(通常称为V6和V7)。这两个版本是在贝尔实验室以外首先得到广泛应用的UNIX系统，从树上演变出三个分支：</p>
<p>  （1）AT&amp;T分支，从此导出了系统III和系统V（被称为UNIX的商用版本）</p>
<p>  （2）加州大学伯克利分校分支，从此导出4.xBSD实现</p>
<p>  （3）由AT&amp;A贝尔实验室的计算科学研究中心开发的UNIX研究版本，从此导出UNIX分时系统第8、第9版以及于1990年发布的最后一版第10</p>
<p>  2.3.1SVR4 </p>
<p>  SVR4（UNIXSystem V Release4，UNIX系统V第4版）是AT&amp;A的UNIX系统实验室(USL,其前身是AT&amp;A的UNIXSofewareOperation)的产品。 它将下列系统的功能合并到一个一致的操作系统中：</p>
<p>  AT&amp;T的UNIX系统V第3.2版(SVR3.2)、</p>
<p>  Sun Microsystem公司的SunOS操作系统，</p>
<p>  加州大学伯克利分校的4.3BSD版本</p>
<p>  微软的Xenix系统</p>
<p>  SVR4符合POSIX1003.1标准和X/Open Portability Guide第3版(XPG3)标准    </p>
<p>  2.3.2 4.4BSD </p>
<p>  BSD(Berkeley Software Distribution)版是由加州大学伯克利分校的计算机系统研究组(CSRG)研究开发和分发的 </p>
<p>  2.3.3FreeBSD</p>
<p>  FreeBSD的基础是4.4BSD-Lite操作系统。在加州大学伯克利分校的CSRG决定终止其在UNIX操作系统的BSD版本上的研发工作后，并且386BSD项目看起来似乎被忽视了太长的时间，为了继续坚持BSD系统，设立了FreeBSD项目</p>
<p>  2.3.4Linux </p>
<p>  Linux是一种提供丰富的UNIX编程环境的操作系统，在GNU公用许可证指导下，Linux是免费使用的。 </p>
<p>  Linux是由Linus Torvalds 在1991年为替代MINIX而研发的。一位当时名不见经传 人物的努力掀起了澎湃巨浪 ，吸引了遍布全世界的很多软件开发者，自愿地贡献出他们大量的时间来使用和不断地增强Linux</p>
<p>  2.3.5MacOSX </p>
<p>  与其以前的版本相比，MacOSX使用了完全不同的技术，其核心操作系统被称为Darwin ，它基于Mach内核和FreeBSD操作系统的组合。类似于FreeBSD和Linux，Darwin是一个开放源代码项目         </p>
<p>  2.3.6Solaris </p>
<p>  Solaris是由Sun公司开发的UNIX系统版本，它基于SVR4, 并在10余年间由Sun公司的工程师对其进行了不断的增强。它是唯一在商业上取得成功的SVR4后裔</p>
<p>  2.3.7其他UNIX系统</p>
<p>  AIX，IBM版的UNIX系统</p>
<p>  HP-UX，HP版的UNIX系统</p>
<p>  IRIX，Silicon Graphics版的UNIX系统</p>
<p>  UnixWare，SVR4派生的UNIX系统，现由SCO销售</p>
<p>  2.4标准和实现的关系 </p>
<p>  FreeBSD5.2.1 Linux2.4.22 MacOSX10.3和Solaris9.在这4种系统都提供UNIX编程环境。因为所有这4种系统都在不同程度上依从POSIX，所以我们也将重点关注POSIX.1标准所要求的功能，并指出这4中系统的具体实现与POSIX.1之间的差别</p>
<p>  2.5限制 </p>
<p>  UNIX系统实现定义了很多幻数 和常量 ，其中有很多已被硬编码进程序中，或用特定的技术确定。已有若干种可移植的方法用以确定这些幻数和实现定义的限制。这非常有助于软件的可移植性：</p>
<p>（1）编译时限制(例如，短整型的最大值是什么)</p>
<p>（2）运行时限制(例如，文件名可以有多少个字符) </p>
<p>  编译时显示可在头文件中定义，程序在编译时可以包含这些头文件。但是，运行时限制则要求进程调用一个函数以获得这种限制值</p>
<p>  三种限制：</p>
<p>  （1）编译时限制（头文件）</p>
<p>  （2）不与文件或目录相关联的运行时限制（sysconf函数）</p>
<p>（3）与文件或目录相关联的运行时限制(pathconf和fpathconf函数) </p>
<p>  2.5.1ISO C限制 </p>
<p>  ISOC定义的限制都是编译时限制。表2-6列出了文件&lt;limits.h&gt; 中定义的C标准限制 </p>
<p>  2.5.2POSIX限制</p>
<p>  POSIX.1定义了很多涉及操作系统实现限制的常量，不幸的是，这是POSIX.1中最令人迷惑不解的部分之一。我们只关心与基本POSIX.1接口有关的部分。这些限制和常量被分成下列5类：</p>
<p>  (1)不变的最小值：表2-8中的19个常量</p>
<p>  (2)不变值：SSIZE_MAX</p>
<p>  (3)运行时可以增加的值：CHARCLASS_NAME_MAX,COLL_WEIGHTS_MAX,LINE_MAX,NGROPUS_MAX以及RE_DUP_MAX</p>
<p>  (4)运行时不变的值(可能不确定)：ARG_MAX,CHILD_MAX,HOST_NAME_MAX,LOGIN_NAME_MAX,OPEN_MAX,PAGESIZE,RE_DUP_MAX,STREAM_MAXS,SYMLOOP_MAX,TTY_NAME以及TZNAME_MAX</p>
<p>  (5)路径名可变值（可能不确定）：FILESIZEBITS,LINK_MAX,MAX_CANON,MAX_INPUT,NAME_MAX,PATH_MAX,PIPE_BUF以及SYMLINK_MAX</p>
<p>  有些可定义在&lt;limits.h&gt;    </p>
<p>  表2-8</p>
<p>  2.5.3XSI限制 </p>
<p>  (1)不变最小值：表2-9中列出的10个常量</p>
<p>  (2)数值限制：LONG_BIT和WORD_BIT</p>
<p>  (3)运行时不变值，（可能不确定）：ATEXIT_MAX,IOV_MAX以及PAGE_SIZE</p>
<p>  2.5.4sysconf、pathconf和fpathconf函数</p>
<p>  后两个函数之间的差别是一个用路径名作为其参数，另一个则取文件描述符作为参数</p>
<p>  2.5.5不确定的运行时限制 </p>
<p>  观察两种特殊的情况：为一个路径名分配存储区，以及确定文件描述符的数目</p>
<p>  2.6选项 </p>
<p>  表2-5中列出了POSIX.1选项。如果我们要编写一些可移植的应用程序而这些程序与所有得到支持的选项有关，难么就需要一种可移植的方法以决定一种实现是否支持一个给定的选项</p>
<p>  2.7功能测试宏 </p>
<p>  如果在编译一个程序时，希望它只使用POSIX的定义而不使用任何实现定义的限制，那么就需定义常量_POSIX_C_SOURCE</p>
<p>  常量_POSIX_C_SOURCE即_XOPEN_SOURCE被称为功能测试宏(feturetestmacro)。所有功能测试宏都以下划线开始</p>
<p>  2.8基本系统数据类型 </p>
<p>  历史上，某些UNIX系统变量已与某些C数据类型联系在一起</p>
<p>  头文件&lt;sys/types.h&gt;中定义了某些与实现有关的数据类型，它们被称为基本系统数据类型(primitivesystedatatype),它们绝大多数都以_t结尾。表2-16某些常用的基本系统数据类型</p>
<p>  2.9标准之间的冲突 </p>
<p>  就整体而言，这些不同的标准之间配合得相当好。但是我们也很关注它们之间的差别，特别是IOSC标准和POSIX.1之间的差别，而它们之间也确实有些差别</p>
<p>  ISOC定义了函数clock，它返回进程使用的CPU时间，返回值类型是clock_t。为了将此值变换成以秒为单位，将其除以在&lt;time.h&gt;头文件中定义的CLOCKS_PER_SEC。POSIX.1定义了函数times,它返回其调用者以其所有终止子进程的CPU时间以及时钟时间，所有这些值都是clock_t类型值。sysconf函数用来获取每秒钟的滴答数，用于表示times函数的返回值。有一个相同的术语，即每秒钟的滴答数，但ISOC和POSIX.1的定义却不同</p>
<p>  另一个可能产生冲突的领域是：在ISO标准定义函数时，可能没有考虑到POSIX.1的某些要求</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/11/07/UNIX环境高级编程-基础及标准/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-内核同步" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/11/03/深入理解Linux内核-内核同步/">深入理解Linux内核-内核同步</a>
    </h1>
  

        
        <a href="/2012/11/03/深入理解Linux内核-内核同步/" class="archive-article-date">
  	<time datetime="2012-11-03T09:23:52.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-11-03</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>每当读到书中的这一章节时，都使我产生放弃的想法。原因是这章中的内容是我认为最复杂，最难以理解 的一章（对充分理解Linux操作系统，也是非常重要 的一部分）。我是将中断（包括可延迟函数）、信号、系统调用、进程、内存、文件系统，这些部分的内容阅读完成后，在阅读此章的，所以我推荐和我有同样感受的读者，在没有搞清楚其他章节的内容时，可以先放弃这章的阅读。</p>
<p>第五章内核同步 </p>
<p>你可以把内核看作是不断对请求进行响应的服务器，这些请求可能来自在CPU上执行的进程，也可能来自发出中断请求的外部设备。我们用这个类比来强调内核的各个部分并不是严格按照顺序依次执行的，而是采用交错执行的方式。因此，这些请求可能要求竞争条件 ，而我们必须采用适当的同步机制对这种情况进行控制。</p>
<p>1、内核如何为不同的请求提供服务 </p>
<p>我们把内核看作必须满足两种请求的侍者：一种请求来自顾客，另一种轻轻来自数量有限的几个不同的老板。策略 ：</p>
<p>1、老板提出请求时，如果侍者正空闲，则侍者开始为老板服务</p>
<p>2、如果老板提出请求时侍者正在为顾客服务，那么侍者停止为顾客服务，开始为老板服务。</p>
<p>3、如果一个老板提出请求时侍者正在为另一个老板服务，那么侍者停止为第一个老板提供服务，而开始为第二个老板服务，服务完毕再继续为第一个老板服务。</p>
<p>4、一个老板可能命令侍者停止正在为顾客提供的服务。侍者在完成对老板最近请求的服务之后，可能会暂时不理会原来的顾客而去为新选中的顾客服务 </p>
<p>侍者提供的服务对应于CPU处于内核态时所执行的代码。如果CPU在用户态执行，则侍者被认为处于空闲状态。</p>
<p>老板的请求相当于中断，而顾客的请求相当于用户态进程发出的系统调用或异常 </p>
<p>[1]内核抢占 </p>
<p>如果进程执行内核函数时，即它的内核态运行时，允许发生内核切换（被替换的进程是正执行内核函数的进程），这个内核就是抢占的。</p>
<p>抢占内核的主要特点 是：一个在内核态运行的进程，可能在执行内核函数期间被另外一个进程取代 </p>
<p>使内核可抢占的目的是减少用户态进程的分配延迟，即从进程变为可执行状态到它实际开始运行之间的时间间隔。内核抢占对执行及时被调度的任务（如：电影播放器）的进程确实是有好处的，因为它降低了这种进程被另一个运行在内核态的进程延迟的风险 </p>
<p>以下原则告诉我们：只有内核正在执行异常处理程序（尤其是系统调用），而且内核抢占没有被显式地禁用时，才可能抢占内核。</p>
<p>thread_info描述符的preempt_count字段大于0时</p>
<p>1、内核正在执行中断服务例程</p>
<p>2、可延迟函数被禁止（当内核正在执行软中断或tasklet时经常如此）</p>
<p>3、通过把抢占计数器设置为正数而显式地禁用内核抢占</p>
<p>内核抢占会引起不容忽视的开销。因此Linux2.6独具特色地允许用户在编译内核时通过设置选项来禁用或启用内核抢占</p>
<p>[2]什么时候同步是必需的 </p>
<p>当计算的结果依赖于两个或两个以上的交叉内核控制路径的嵌套方式时，可能出现竞争条件。临界区是一段代码，在其他的内核控制路径能够进入临界区前，进入临界区的内核控制路径必须全部执行完这段代码。</p>
<p>交叉内核控制路径使内核开发者的工作变得复杂：他们必须特别小心地识别出异常处理程序、中断处理程序、可延迟函数和内核线程中的临界区。一旦临界区被确定，就必须对其采用适当的保护措施，以确保在任何时刻只有一个内核控制路径处于临界区。</p>
<p>如果是单CPU的系统，可以采取访问共享数据结构时关闭中断的方式来实现临界区，因为只有在开中断的情况下，才可能发生内核控制路径的嵌套。</p>
<p>另外，如果相同的数据结构仅被系统调用服务例程所访问，而且系统中只有一个CPU，就可以非常简单地通过在访问共享数据结构时禁用内核抢占功能来实现临界区。</p>
<p>正如你们所预料的，在多处理器系统中，情况要复杂得多。由于许多CPU可能同时执行内核路径，因此内核开发者不能假设只要禁用内核抢占功能，而且中断、异常和软中断处理程序都没有访问过该数据结构，就能保证这个数据结构能够安全地被访问。</p>
<p>[3]什么时候同步是不必需的 </p>
<p>所有的中断处理程序响应来自PIC的中断并禁用IRQ线。此外，在中断处理程序结束之前，不允许产生相同的中断事件</p>
<p>中断处理程序、软中断和tasklet既不可以被抢占也不能被阻塞，所以它们不可能长时间处于挂起状态。在最坏的情况下，它们的执行将有轻微的延迟，因此在其执行的过程中可能发生其他的中断（内核控制路径的嵌套执行）</p>
<p>执行中断处理的内核控制路径不能被执行可延迟函数或系统调用服务例程的内核控制路径中断</p>
<p>软中断和tasklet不能在一个给定的CPU上交错执行</p>
<p>同一个tasklet不可能同时在几个CPU上执行。</p>
<p>简化的例子：(???)</p>
<p>  中断处理程序和tasklet不必编写成可重入的函数</p>
<p>  仅被软中断和tasklet访问的每CPU变量不需要同步</p>
<p>  仅被一种tasklet访问的数据结构不需要同步</p>
<p>  2、同步原语 </p>
<p>  我们考察一下在避免共享数据之间的竞争条件时，内核控制路径是如何交错执行的。**表5-2列出了Linux内核使用的同步技术。“适用范围”一栏表示同步技术是适用于系统中的所有CPU还是单个CPU</p>
<p>  [1]每CPU变量 </p>
<p>  事实上每一种显式的同步原语都有不容忽视的性能开销。</p>
<p>  最简单也是最重要的同步技术包括把内核变量声明为每CPU变量（per-cpuvariable）每CPU变量主要是数据结构的数组，系统的每个CPU对应数组的一个元素。</p>
<p>  一个CPU不应该访问与其他CPU对应的数组元素，另外，它可以随意读或修改它自己的元素而不用担心出现竞争条件，因为它是唯一有资格这么做的CPU，但是，这也意味着每CPU变量基本上只能在特殊情况下使用，也就是当它确定在系统的CPU上的数据在逻辑上是独立的时候。 </p>
<p>  每CPU的数组元素在主存中被排列以使每个数据结构存放在硬件高速缓存的不同行，因此，对每CPU数组的并发访问不会导致高速缓存行的窃用和实效</p>
<p>  虽然每CPU变量为来自不同CPU的并发访问提供保护，但对来自异步函数（中断处理程序和可延迟函数）的访问不提供保护，在这种情况下需要另外的同步原语。</p>
<p>  总的原则是内核控制路径应该在禁用抢占的情况下访问每CPU变量。</p>
<p>  表5-3每CPU变量的函数和宏</p>
<p>  [2]原子操作 </p>
<p>  若干汇编语言指令具有“读-修改-写”类型–也就是说，它们访问存储器单元两次，第一次读原值，第二次写新值</p>
<p>  假定运行在两个CPU上的两个内核控制路径试图通过执行非原子操作来同时“读-修改-写”同一存储器单元。首先，两个CPU都试图读同一单元，但是存储器仲裁器（对访问RAM芯片的操作进行串行化的硬件电路）插手，只允许其中的一个访问而让另一个延迟。然而，当第一次读操作已经完成后，延迟的CPU从那个存储器单元正好读到同一次被存储器仲裁器串行化，最终，两个写操作都成功。但是，全局的结果是不对的，因为连个CPU写入同一（新）值。因此，两个交错的“读-修改-写”操作成了一个单独的操作。</p>
<p>  避免由于“读-修改-写”指令引起的竞争条件的最容易的办法，就是确保这样的操作在芯片级是原子的。任何一个这样的操作都必须以单个指令执行，中间不能中断，且避免其他的CPU访问同一存储器单元。这些很小的原子操作可以建立在其他更灵活机制的基础之上以创建临界区。 </p>
<p>  在你编写C代码程序时，并不能保证编译器会为a=a+1或甚至像a++这样的操作使用一个原子指令。因此，Linux内核提供了一个专门的atomic_t类型（一个原子访问计数器）和一些专门的函数和宏（参见表5-4）</p>
<p>  [3]优化和内存屏蔽 </p>
<p>  当使用优化的编译器时，你千万不要认为指令会严格按它们在源代码中出现的顺序执行。例如，编译器可能重新安排汇编语言指令以使寄存器以最优的方式使用。此外，现代CPU通常并行地执行若干条指令，且可能重新安排内存访问。这种重新排序可以极大地加速程序的执行 </p>
<p>  然而，当处理同步时，必须避免指令重新排序。如果放在同步原语之后的一条指令在同步原语本身之前执行，事情很快就会变得失控。事实上，所有的同步原语起优化和内存屏蔽的作用。</p>
<p>  优化屏障（optimizationbarrier）原语保证编译程序不会混淆放在原语操作之前的汇编语言指令和放在原语操作之后的汇编语言指令，这些汇编语言指令在C中都有对应的语句 。在Linux中，优化屏障就是barrier()宏。volatile关键字禁止编译器把asm指令与程序中的其他指令重新组合。memory关键字强制编译器假定RAM中的所有内存单元已经被汇编语言指令修改；因此编译器不能使用存放在CPU寄存器中的内存单元的值来优化asm指令前的代码。注意，优化屏障并不保证不使当前CPU把汇编语言指令混在一起执行—这是内存屏障的工作</p>
<p>  内存屏障（memorybarrier）原语确保，在原语之后的操作开始执行之前，原语之前的操作已经完成。因此，内存屏蔽类似于防火墙，让任何汇编语言指令都不能通过。 </p>
<p>  Linux使用六个内存屏障原语，如表5-6所示。这些原语也被当作优化屏障，因为我们必须保证编译程序不在屏障前后移动汇编语言指令。</p>
<p>  “读内存屏障”仅仅作用于从内存读的指令，而“写内存屏障”仅仅作用于写内存的指令。</p>
<p>  [4]自旋锁 </p>
<p>  当内核控制路径必须访问共享数据结构或进入临界区时，就需要为自己获取一把“锁”。由锁机制保护的资源非常类似于限制于房间内的资源，当某个进入房间时，就把门锁上。如果内核控制路径希望访问资源，就试图获取钥匙“打开门”。当且仅当资源空闲时，它才能成功。然后，只要它还想使用这个资源，门就依然锁着。当内核控制路径释放了锁时，门就打开，另一个内核控制路径就可以进入房间。图5-1 </p>
<p>  自旋锁（spinlock）是用来在多处理器环境中工作的一种特殊的锁。如果内核控制路径发现自旋锁“开着”就获取并继续自己的执行。相反，如果内核控制路径发现锁由运行在另一个CPU上的内核控制路径“锁着”，就在周围“旋转”，反复执行一条紧凑的循环指令，直到锁被释放。</p>
<p>  一般来说，由自旋锁所保护的每个临界区都禁止内核抢占的。在单处理器系统上，这种锁本身并不起锁的作用，自旋锁语言仅仅是禁止或启用内核抢占。请注意，在自旋锁忙等期间，内核抢占还是有效的，因此，等待自旋锁释放的进程有可能被更高优先级的进程替代。</p>
<p>  在Linux中，每个自旋锁都用spinlock_t结构 表示，其中包含两个字段：</p>
<p>  slock:该字段表示自旋锁的状态：值为1表示“未加锁”状态，而任何负数和0都表示“加锁”状态</p>
<p>  break_lock:表示进程正在忙等自旋锁</p>
<p>  表5-7自旋锁宏</p>
<p>  (1)具有内核抢占的spin_lock宏</p>
<p>  操作 ：</p>
<p>  1、调用preempt_disable()以禁用内核抢占</p>
<p>  2、调用函数_raw_spin_trylock()，它对自旋锁的slock字段执行原子性的测试和设置操作</p>
<p>  3、如果自旋锁中的旧值是正数，宏结束：内核控制路径已经获得自旋锁</p>
<p>  4、否则，内核控制路径无法获得自旋锁，因此宏必须执行循环一直到其他CPU上运行的内核控制路径释放自旋锁。</p>
<p>  5、如果break_lock字段等于0，则把它设置为1.通过检测该字段，拥有锁并在其他CPU上运行的进程可以知道是否有其他进程在等待这个锁。如果进程把持某个自旋锁时间太长，它可以提前释放锁以使等待相同自旋锁的进程能够继续向前运行</p>
<p>  6、执行等待循环</p>
<p>  7、跳转回到第1步，再次试图获取自旋锁</p>
<p>  (2)非抢占式内核中的spin_lock宏</p>
<p>  如果在内核编译时没有选择内核抢占选项，spin_lock宏就与前面描述的spin_lock宏有很大的区别。在这种情况下，宏生成一个汇编语言程序片段，它本质上等价于下面紧凑的忙等待</p>
<p>  1：lock;decbslp-&gt;slock</p>
<p>  jns3f</p>
<p>  2:pause</p>
<p>  cmpb$0,slp-&gt;slock</p>
<p>  jle2b</p>
<p>  jmp1b</p>
<p>  汇编语言指令decb递减自旋锁的值，该指令是原子的，因为它带有lock字节前缀。随后检测符号标志，如果它被清0，说明自旋锁被设置1（未锁），因此从标记3处继续正常执行（后缀f表示标签是“向前的”，它在程序的后面出现）。否则，在标签2处（后缀b表示，“向后的”标签）执行紧凑循环直到自旋锁出现正值。然后从标签1处开始重新执行，因为不检查其他的处理器是否抢占了锁就继续执行是不安全的。</p>
<p>  (3)spin_unlock宏</p>
<p>  释放以前获得的自旋锁</p>
<p>  [5]读写自旋锁     </p>
<p>  读写自旋锁的引入是为了增加内核的并发能力。只要没有内核控制路径对数据结构进行修改，读写自旋锁就允许多个内核控制路径同时读同一数据结构。如果一个内核控制路径想对这个结构进行写操作，那么它必须首先获取读写锁得写锁，写锁授权独占访问这个资源。当然，允许对数据结构并发读可以提高系统性能。 </p>
<p>  图5-2**</p>
<p>  每个读写自旋锁都是是一个rwlock_t结构，其lock字段是一个32位的字段，分为两个不同的部分：</p>
<p>  24位计数器，表示对受保护的数据结构并发地进行读操作的内核控制路径的数目。这个计数器的二进制补码存放在这个字段的0-23位</p>
<p>  “未锁”标志字段，当没有内核控制路径在读或写时设置该位，否则清0.这个“未锁”标志存放在lock字段的第24位</p>
<p>  (1)为读获取和释放一个锁：read_lock宏</p>
<p>  (2)为写获取和释放一个锁：write_lock宏</p>
<p>  [6]顺序锁 </p>
<p>  当使用读写自旋锁时，内核控制路径发出的执行read_lock或write_lock操作的请求具有相同的优先权：读者必须等待，直到写操作完成。同样地，写者也必须等待，直到读操作完成</p>
<p>  Linux2.6中引入了顺序锁(seqlock)，它与读写自旋锁非常相似，只是它为写者赋予了较高的优先级：事实上，即使在读者正在读的时候也允许写者继续运行。这种策略的好处是写者永远不会等待（除非另外一个写者正在写），缺点是有些时候读者不得不反复多次读相同的数据直到它获得有效的副本 </p>
<p>  每个顺序锁都是包括两个字段的seqlock_t结构 ；一个类型为spinlock_t的lock字段和一个整型的sequence字段，第二个字段是一个顺序计数器</p>
<p>  注意，当读者进入临界区时，不必禁用内核抢占；另一方面，由于写者获取自旋锁，所以它进入临界区时自动禁用内核抢占</p>
<p>  并不是每一种资源都可以使用顺序锁来保护。一般来说，必须在满足下述条件时才能使用顺序锁：</p>
<p>  被保护的数据结构不包括被写者修改和被读者间接引用的指针</p>
<p>  读者的临界区代码没有副作用</p>
<p>  此外，读者的临界区代码应该简短，而且写着应该不常获取顺序锁，否则，反复的读访问会引起严重的开销    </p>
<p>  [7]读-拷贝-更新 </p>
<p>  读-拷贝-更新（RCU）是为了保护在多数情况下被多个CPU读的数据结构而设计的另一种同步技术。RCU允许多个读者和写者并发执行（相对于只允许一个写者执行的顺序锁有了改进）。而且，RCU是不使用锁的，就是说，它不使用被所有CPU共享的锁或计数器，在这一点上与读写自旋锁和顺序锁（由于高速缓存行窃用和失效而有很高的开销）相比，RCU具有更大的优势。        </p>
<p>  关键的思想包括限制RCU的范围，如下：</p>
<p>  1、RCU只保护被动态分配并通过指针引用的数据结构</p>
<p>  2、在被RCU保护的临界区中，任何内核控制路径都不能睡眠</p>
<p>当内核控制路径要读取被RCU保护的数据结构时，执行宏rcu_read_lock()，它等同于preempt_disable()</p>
<p>  我们还可以想象，由于读者几乎不做任何事情来防止竞争条件的出现，所以写者不得不做得更多一些。事实上，当写者要更新数据结构时，它间接引用指针并生成整个数据结构的副本。接下来，写者修改这个副本。一但修改完毕，写者改变指向数据结构的指针，以使它指向被修改后的副本。由于修改指针值的操作是一个原子操作，所以旧副本和新副本对每个读者或写者都是可见的，在数据结构中不会出现数据崩溃。尽管如此，还需要内存屏蔽来保证：只有在数据结构被修改之后，已更新的指针对其他CPU才是可见的。如果把自旋锁与RCU结合起来以禁止写者的并发执行，就隐含地引入了这样的内存屏蔽。然后，使用RCU技术的真正困难在于：写者修改指针时不能立即释放数据结构的旧副本。实际上，写着开始修改时，正在访问数据结构的读者可能还在读旧副本。只有在CPU上的所有（潜在的）读者都执行完宏rcu_read_unlock()之后，才可以释放旧副本。内核要求每个潜在的读者在下面的操作之前执行rcu_read_unlock()宏： </p>
<p>  CPU执行进程切换</p>
<p>  CPU开始在用户态执行</p>
<p>  CPU执行空循环</p>
<p>  对上述每种情况，我们说CPU已经经过了静止状态    </p>
<p>  [8]信号量 </p>
<p>  从本质上说，它们实现了一个枷锁原语，即让等待者睡眠，直到等待的资源变为空闲。</p>
<p>  内核信号量，由内核控制路径使用</p>
<p>  SystemVIPC信号量，由用户态进程使用</p>
<p>  内核信号量类似于自旋锁，因此当锁关闭着时，它不允许内核控制路径继续进行。然而，当内核控制路径试图获取内核信号所保护的忙资源时，相应的进程被挂起。只有在资源被释放时，进程才再次变为可运行的。因此，只有可以睡眠的函数才能获取内核信号量；中断处理程序和可延续函数都不能使用内核信号量。 </p>
<p>  内核信号量是struct semaphore类型 的对象，包含下面这些字段：</p>
<p>  count:存放atomic_t类型的一个值</p>
<p>  wait:存放等待队列链表的地址，当前等待资源的所有睡眠进程都放在这个链表中。当然，如果count大于或等于0,等待队列就为空</p>
<p>  sleepers:存放一个标志，表示是否有一些进程在信号量上睡眠。</p>
<p>  可以用init_MUTEX()和init_MUTEX_LOCKED()函数来初始化互斥访问所需的信号量：这两个宏分别把count字段设置成1（互斥访问的资源空闲）和0（对信号量进行初始化的进程当前互斥访问的资源忙）。宏DECLEAR_MUTEX和DECLARE_MUTEX_LOCKED完成同样的功能，但它们也静态分配semaphore结构的变量。注意也可以把信号量中的count初始化为任意的正数值n,在这种情况下，最多有n个进程可以并发地访问这个资源。    </p>
<p>  (1)获取和释放信号量</p>
<p>  当进程希望释放内核信号量锁时，就调用up()函数</p>
<p>  up()函数增加*sem信号量count字段的值，然后，检查它的值是否大于0. </p>
<p>  当进程希望获取内核信号量锁时，就调用down()函数</p>
<p>  down()函数减少*sem信号量的count字段的值，然后检查该值是否为负。 </p>
<p>  [9]读写信号量 </p>
<p>  读写信号量类似于前面“读写自旋锁”一节描述的读写自旋锁，有一点不同：在信号量再次变为打开之前，等待进程挂起而不是自旋。 </p>
<p>  每个读写信号量都是由rw_semaphore结构描述的</p>
<p>  count:存放两个16位的计数器</p>
<p>  wait_list:指向等待进程的链表</p>
<p>  wait_lock:一个自旋锁，用于保护等待队列链表和rw_semaphore结构本身</p>
<p>  init_rwsem()函数初始化rw_semaphore结构，即把count字段置为0，wait_lock自旋锁置为未锁，而把wait_list置为空链表</p>
<p>  down_read()和down_write()函数分别为读或写获取读写信号量。同样，up_read()和up_write()函数为读或写释放以前获取的读写信号量。down_read_trylock()和down_write_trylock()函数分别类似于down_read()和down_write()函数，但是，在信号量忙的情况下，它们不阻塞进程。最后，函数downgrade_write()自动把写锁转换成读锁。这5个函数的实现代码比较长，但因为它与普通信号量的实现类似，所以容易理解。 </p>
<p>  [10]补充原语 </p>
<p>  Linux2.6还使用了另一种类似于信号量的原语：补充（completion）引入这种原语是为了解决多处理器系统上发生的一种微妙的竞争条件，当进程A分配了一个临时信号量变量，把它初始化为关闭的MUTEX，并把其地址传递给进程B，然后在A之上调用down(),进程A打算一但被唤醒就撤销该信号量。随后，运行在不同CPU上的进程B在同一信号量上调用up()。然而，up()和down()的目前实现还允许这两个函数在同一个信号量上并发执行。因此，进程A可以被唤醒并撤销临时信号量，而进程B还在运行up()函数。结果，up()可能试图访问一个不存在的数据结构 </p>
<p>  当然，也可以改变up()和down()的实现以禁止在同一信号量上并发执行。然而，这种改变可能需要另外的指令，这对于频繁使用的函数来说不是什么好事。</p>
<p>  补充是专门设计来解决以上问题的同步原语.completion数据结构包含一个等待队列头和一个标志 </p>
<p>与up()对应的函数叫做complete()</p>
<p>与down()对应的函数叫wait_for_completion()</p>
<p>  补充原语和信号量之间的真正差别在于如何使用等待队列中包含的自旋锁。在补充原语中，自旋锁用来确保completion()和wait_for_completion()不会并发执行。在信号量中，自旋锁用于避免并发执行的down()函数弄乱信号量的数据结构</p>
<p>  [11]禁止本地中断 </p>
<p>  确保一组内核语句被当作一个临界区处理的主要机制之一就是中断禁止。即使当硬件设备产生了一个IRQ信号时，中断禁止也让内核控制路径继续执行，因此，这就提供了一种有效的方式，确保中断处理程序访问的数据结构页受到保护。然而，禁止本地中断并不保护运行在另一个CPU上的中断处理程序对数据结构的并发访问，因此，在多处理器系统上，禁止本地中断经常与自旋锁结合使用。</p>
<p>  宏local_irq_disable()使用cli汇编语言指令关闭本地CPU上的中断，宏local_irq_enable()使用sti汇编语言指令打开被关闭的中断</p>
<p>  [12]禁止和激活可延续函数 </p>
<p>  可延续函数可能在不可预知的时间执行（实际上是在硬件中断处理程序结束时）。因此，必须保护可延续函数访问的数据结构使其避免竞争条件</p>
<p>  禁止可延迟函数在一个CPU上执行的一种简单方式就是禁止在那个CPU上的中断。因为没有中断处理程序被激活，因此，软中断操作就不能异步地开始。</p>
<p>  内核有时需要只禁止可延续函数而不禁止中断。通过操纵当前thread_info描述符preempt_count字段中存放的软中断计数器，可以在本地CPU上激活或禁止可延续函数。</p>
<p>  3、对内核数据结构的同步访问 </p>
<p>  系统性能可能随所选择同步原语种类的不同而有很大变化。通常情况下，内核开发者采用下述由经验得到的法则：把系统中的并发度保持在尽可能高的程度。 </p>
<p>  系统中的并发度又取决于两个主要因素：</p>
<p>  同时运转的IO设备数</p>
<p>  进行有效的工作的CPU数 </p>
<p>  为了是IO吞吐量最大化，应该使中断禁止保持在很短的时间。</p>
<p>  为了有效地的利用CPU，应该尽可能避免使用基于自旋锁的同步原语。当一个CPU执行紧指令循环等待自旋锁打开时，是在浪费宝贵的机器周期 。就像我们面前所描述的，更糟糕的是：由于自旋锁对硬件高速缓存的影响而使其对系统的整体性能产生不利影响 </p>
<p>  让我们举例说明在下列两种情况下，既可以维持较高的并发度，也可以达到同步</p>
<p>  共享的数据结构时一个单独的整数值，可以把它声明为atomic_t类型并使用原子操作对其更新。原子操作比自旋锁和中断禁止都快， 只有在几个内核控制路径同时访问这个数据结构是速度才会慢下来</p>
<p>  把一个元素插入到共享链表的操作决不是原子的，因为这至少涉及两个指针赋值。不过，内核有时并不用锁或禁止中断就可以执行这种插入操作</p>
<p>  在C语言中，插入链表通过下列指针赋值实现的：</p>
<p>  new-&gt;next=list_element-&gt;next；</p>
<p>  list_element-&gt;next=new; </p>
<p>  第一条指令建立new元素的next指针，但不修改链表。因此，如果中断处理程序在第一条指令和第二条指令执行的中间查看这个链表，看到的就是没有新元素的链表。如果该处理程序在第二条指令执行后查看链表，就会看到有新元素的链表。关键是，在任一种情况下，链表都是一致的且处于未损坏状态。然后，只有在中断处理程序不修改链表的情况下才能确保这种完整性。如果修改了链表，那么在new元素内刚刚设置的next指针就可能变为无效的</p>
<p>  需要加一个写内存屏蔽原语：</p>
<p>  new-&gt;next=list_element-&gt;next;</p>
<p>  wmb();</p>
<p>  list_element-&gt;next=new; </p>
<p>  [1]在自旋锁、信号量及中断禁止之间选择 </p>
<p>  同步原语的选取取决于访问数据结构的内核控制路径的种类，如表5-8所示。记住，只要内核控制路径获得自旋锁（还有读、写锁、顺序锁或RCU“读锁”），就禁用本地中断或本地软中断，自动禁用内核抢占</p>
<p>  表：5-8****</p>
<p>  (1)保护异常所访问的数据结构 </p>
<p>  当一个数据结构仅由异常程序访问时，竞争条件通常是易于理解也易于避免的。最常见的产生同步问题的异常就是系统调用服务例程，在这种情况下，CPU运行在内核态而为用户态程序提供服务。因此，仅由异常访问的数据结构通常表示一种资源，可以分配给一个或多个进程。</p>
<p>  竞争条件可以通过信号量避免，因为信号量原语允许进程睡眠到资源变为可用。注意，信号量工作方式在单处理器系统和多处理器系统上完全相同。</p>
<p>  (2)保护中断所访问的数据结构 </p>
<p>  假定一个数据结构仅被中断处理程序的“上半部分”访问。中断处理程序本身不能同时多次运行 。因此，访问数据结构就无需任何同步原语。</p>
<p>  但是，如果多个中断处理程序访问一个数据结构 ，情况就有所不同了。一个处理程序可以中断另一个处理程序，不同的中断处理程序可以在多个处理器系统上同时运行。没有同步，共享的数据结构就很容易被破坏 。</p>
<p>  在单处理器系统上，必须通过在中断处理程序的所有临界区上禁止中断来避免竞争条件。只能用这种方式进行同步，因为其他的同步原语都不能完成这件事。</p>
<p>  多处理器系统上，避免竞争条件最简单的方法是禁止本地中断，并获取保护数据结构的自旋锁或读、写自旋锁。注意，这些附加的自旋锁不能冻结系统，因为即使中断处理程序发现锁被关闭，在另一个CPU上拥有锁得中断处理程序最终也释放这个锁。</p>
<p>  (3)保护可延迟函数所访问的数据结构 </p>
<p>  只被可延迟函数访问的数据结构需要那种保护呢？这主要取决于可延迟函数的种类。软中断和tasklet本质上有不同的并发度。</p>
<p>  在单处理器系统上不存在竞争条件。这是因为可延迟函数执行总是在一个CPU上串行进行—也就是说，一个可延迟函数不会被另一个可延迟函数中断。因此，根本不需要同步原语。</p>
<p>  在多处理器系统上，竞争条件的确存在，因为几个可延迟函数可以并发运行：表5-10*** </p>
<p>  由软中断访问的数据结构必须受到保护，通常使用自旋锁进行保护，因为同一个软中断可以在两个或多个CPU上并发运行。相反，仅有一种tasklet访问的数据结构不需要保护，因为同种tasklet不能并发运行。但是，如果数据结构被几种tasklet访问，那么，就必须对数据结构进行保护。 </p>
<p>  (4)保护异常和中断访问的数据结构 </p>
<p>  在单处理器系统上，竞争条件的防止是相当简单的，因为中断处理程序不是可重入的且不能被异常中断。只要内核以本地中断禁止访问数据结构，内核在访问数据结构的过程中就不会被中断。不过，如果数据结构正好是被一种中断处理程序访问，那么，中断处理程序不用禁止本地中断就可以自由地访问数据结构。</p>
<p>  在多处理器系统上，我们必须关注异常和中断在其他CPU上的并发执行。本地中断禁止还必须外加自旋锁，强制并发的内核控制路径进行等待，直到访问数据结构的处理程序完成自己的工作。</p>
<p>  (5)保护异常和可延迟函数访问的数据结构</p>
<p>  异常和可延迟函数都访问的数据结构与异常和中断处理程序访问的数据结构处理方式类似。事实上，可延迟函数本质上是由中断的出现激活的，而可延迟函数执行时不可能产生异常。因此，把本地中断禁止与自旋锁结合起来就足够了。</p>
<p>  (6)保护中断和可延迟函数所访问的数据结构</p>
<p>  类似于中断和异常处理程序访问的数据结构：本地中断禁用与自旋锁</p>
<p>  (7)保护异常、中断和可延迟函数所访问的数据结构 </p>
<p>  类似于前面的情况，禁止本地中断和获取自旋锁几乎总是避免竞争条件所必需的。注意，没有必要显式地禁止可延迟函数，因为当中断处理程序终止执行时，可延迟函数才能被实质激活；因此，禁止本地中断中断就做够了。</p>
<p>  4、避免竞争条件的实例 </p>
<p>  [1]引用计数器 </p>
<p>  引用计数器广泛地用在内核中以避免由于资源的并发分配和释放而产生的竞争条件。引用计数器（referencecounter）只不过是一个atomic_t计数器，与特定的资源，如内存页，模块或文件相关。当内核控制路径开始使用资源是就原子地减少计数器的值，当内核控制路径使用完资源时就原子地增加计数器。当引用计数器变为0时，说明该资源未被使用，如果必要，就释放该资源</p>
<p>  [2]大内核锁 </p>
<p>  从2.6.11开始，用一个叫做kernel_sem的信号量来实现大内核锁（在较早的版本中，大内核锁是通过自旋锁来实现的）。但是，大内核锁比简单的信号量要复杂一些。详细内容参见：p225-226</p>
<p>  [3]内存描述符读/写信号量 </p>
<p>  mm_struct类型的每个内存描述符mmap_sem字段中都包含了自己的信号量。由于几个轻量级进程之间可以共享一个内存描述符，因此，信号量保护这个描述符以避免可能产生的竞争条件</p>
<p>  [4]slab高速缓存链表的信号量 </p>
<p>  slab高速缓存描述符链表是通过cache_chain_sem信号量保护的，这个信号量允许互斥地访问和修改该链表</p>
<p>  [5]索引节点的信号量 </p>
<p>  Linux把磁盘文件的信息存放在一种叫做索引节点(inode)的内核对象中。相应的数据结构也包括有自己的信号量，存放在i_sem字段中。</p>
<p>  在文件系统的处理过程中会出现很多竞争条件。实际上，磁盘上的每个文件都是所有用户共有的一种资源，因此所有进程都（可能）会存取文件的内容、修改文件名或文件位置、删除或复制文件等等。</p>
<p>  只要一个程序使用了两个或多个信号量，就存在死锁的可能，因为两个不同的控制路径可能互相死等着释放信号量。一般来说，Linux在信号量请求上很少会发生死锁问题，因为每个内核控制路径通常一次只需要获得一个信号量。然而在有些情况下，内核必须获得两个或更多的信号量锁。索引点信号量倾向于这种情况。例如：在rename()系统调用的服务例程中就会发生这种情况。在这种情况下，操作涉及两个不同的索引节点，因此，必须采用两个信号量。为了避免这样的死锁，信号量的请求按预先确定的地址顺序进行</p>
<hr>
<p>  附录：</p>
<p>  并发，竞争与同步：<br>  并发，竞争和同步的概念，我们假定大家都有所了解，本文不再重申。我们讨论的重点放在什么情况会发生内核并发上？如何防止内核并发？有那些同步方法？以及这些方法的行为有何特点和如何使用它们？</p>
<p>  下面一段描述了上述几个概念之间的大致关系，这种关系在内核中同样适用。</p>
<p>  对于多线程程序的开发者来说，往往会利用多线程访问共享数据，避免繁琐的进程间通讯。但是多线程对共享数据的并发访问有可能产生竞争，使得数据处于不一致 状态，所以需要一些同步方法来保护共享数据。多线程的并发执行是由于线程被抢占式的调度——一个线程在对共享数据访问期间（还未完成）被调度程序中断，将 另一个线程投入运行——如果新被调度的线程也要对这个共享数据进行访问，就将产生竞争。为了避免竞争产生，需要使线程串行地访问共享数据 ，也就是说访问需要同步——在一方对数据访问结束后，另一方才能对同一数据进行访问。</p>
<p>  内核并发原因<br>  上述情况是用户空间并发产生的普遍原因，对于内核来说并发原因也大致类似，但是情况要更多样，也更复杂。</p>
<p>  对于单处理机器来说情况相对简单一些。在2.6版本内核之前，Linux内核是非抢占式的——在内核任务没有执行完之前不能被打断，这样的话，内核中程序并发执行的情况很少，准确地讲只有两种可能：</p>
<p>  一 ：中断发生  ，因为中断执行是异步的，而且中断是在非抢占式内核中打断当前运行内核代码的唯一方法，所以中断显然是可以和其它内核代码并发执行的。因此如果中断操作和被中断的那内核代码都访问同样的内核数据，那么就会发生竞争。</p>
<p>  二 ：睡眠和再调度 , 处于进程上下文（下面会进行讲述）的内核任务可以睡眠（睡眠意味放弃处理器），这时调度程序会调度其它程序去执行（首先执行调度任务队列中的内核任务，然 后执行软中断等，最后从运行队列中选择一个高优先级的用户进程运行）。显然这里也会造成内核并发访问，当睡眠的内核任务和新投入运行的内核任务访问同一共 享数据时，就发生了竞争。请看参考资料 1</p>
<p>  2.6版本的内核变成了抢占式内核——内核可能在任何时刻抢占正在运行的内核代码。所以内核中发生并发执行的情况大大增加了。内核抢占 成为了内核程序并发的又一种可能，所以在开发抢占式内核代码时需要时刻警惕抢占产生的竞争。</p>
<p>  单处理器上的并发是逻辑上的伪并发，事实上所谓并发的内核程序其实是交错地占用处理器。真正的并发执行程序，必须依靠对称多处理器。但无论是逻辑上的并发 还是真正的并发，都会产生竞争，而且它们的处理也是相同的。但是对于对称多处理器来说，由于两个或多个处理器可以在同一时刻执行代码，所以会不可避免地给 内核带来并发可能，如果分别在不同处理器上执行的内核代码同时访问同一共享数据，竞争就产生了。因此，不用说对称多处理 是内核并发的又一种可能。 请看参考资料2</p>
<p>  可以看到随着Linux内核不断演化，在内核对系统支持更加全面，对任务调度更加高效的同时，也给内核带来了更多的并发可能，更容易引起竞争。上面提到的各种并发情况在内核中都必须得到有效的处理，才能确保内核有高稳定性。</p>
<p>  无论是中断产生的并发或是睡眠引起的并发，还是内核抢占引起的并发，要想在内核开发中很好地避免，就必须从本质上了解它们的并发原因。只有在掌握内核任务的调度机制后，才可以真正的达到对并发可能的预测，进而能够采取合适的同步方法——锁——来避免并发。</p>
<p>  下面我们就对任务调度进行讨论。对比并发产生的条件，分析内核中的调度发生的条件。</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/11/03/深入理解Linux内核-内核同步/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-系统调用" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/10/29/深入理解Linux内核-系统调用/">深入理解Linux内核-系统调用</a>
    </h1>
  

        
        <a href="/2012/10/29/深入理解Linux内核-系统调用/" class="archive-article-date">
  	<time datetime="2012-10-29T09:24:02.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-10-29</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>第十一章系统调用</p>
<p>操作系统为在用户态运行的进程与硬件设备进行交互提供了一组接口。优点：</p>
<p>首先这使得编程更加容易，把用户从学习硬件设备的低级编程特性中解放出来。其次这极大地提高了系统的安全性，因为内核在试图满足某个请求之前在接口级就可以检查这种请求的正确性。最后，更重要的是这些接口使得程序更具有可移植性</p>
<p>1、POSIX API和系统调用 </p>
<p>先强调一下应用编程接口（API）与系统调用之不同。前者只是一个函数定义，说明了如何获得一个给定的服务；而后者是通过软中断向内核态发出一个明确的请求。 </p>
<p>Unix系统给程序员提供了很多API的库函数。libc的标准C库所定义的一些API引用了封装例程。通常情况下，每个系统调用对应一个封装例程，而封装例程定义了应用程序使用的API</p>
<p>反之则不然，顺便说一句，一个API没必要对应一个特定的系统调用。首先，API可能直接提供用户态的服务，其次一个单独的API函数可能调用几个系统调用。此外，几个API函数可能调用封装了不同功能的同一个系统调用。</p>
<p>从编程者的观点看，API和系统调用之间的差别是没有关系的：唯一相关的事情就是函数名、参数类型及返回代码的含义。然而，从内核设计者的观点看，这种差别确实有关系，因为系统调用属于内核，而用户态的库函数不属于内核。</p>
<p>大部分封装返回一个整数，其值的含义依赖于相应的系统调用。返回值-1通常表示内核不能满足进程的请求。</p>
<p>每个出错码都定义为一个常量宏。POSIX标准制定了很多出错码的宏名。</p>
<p>include/asm-i386/errno.h</p>
<p>/usr/include/error.h</p>
<p>include/asm-i386/error.h</p>
<p>2、系统调用处理程序及服务例程 </p>
<p>当用户态的进程调用一个系统调用时，CPU切换到内核态并开始执行一个内核态函数。在80x86体系结构中，可以用两种不同的方式调用linux的系统调用。两种方式的最终结果都是跳转到所谓系统调用处理程序的汇编语言函数。</p>
<p>因为内核实现了很多不同的系统调用，因此进程必须传递一个名为系统调用号的参数来识别所需的系统调用，eax寄存器就用作此目的。</p>
<p>所有的系统调用都返回一个整数值。这些返回值与封装例程返回值的约定是不同的。在内核中，正数或0表示系统调用成功结束，而负数表示一个出错条件。在后一种情况下，这个值就是存放在error变量中必须返回给应用程序的负出错码。</p>
<p>系统调用处理程序与其他异常处理程序的结构类似，执行下列操作：</p>
<p>在内核态栈保存大多数寄存器的内容</p>
<p>调用名为系统调用服务例程</p>
<p>退出系统调用处理程序：用保存在内核栈中的值加载寄存器，CPU从内核态切换回到用户态</p>
<p>xyz()系统调用对应的服务例程的名字通常是sys_xyz()。不过也有一些例外    </p>
<p>**图：10-1调用一个系统调用</p>
<p>为了把系统调用号与相应的服务例程关联起来，内核利用了一个系统调用分派表（dispatchtable）</p>
<p>3、进入和退出系统调用 </p>
<p>通过两种不同的方式调用系统调用：</p>
<p>执行int$0x80汇编语言指令，在Linux内核的老版本中，这是从用户态切换到内核态的唯一方式</p>
<p>执行sysenter汇编语言指令。在Inter Pentium II微处理器芯片中引入了这条指令，现在Linux2.6内核支持这条指令。</p>
<p>通过两种不同的方式从系统调用退出，从而使CPU切换回到用户态：</p>
<p>执行iret汇编语言指令</p>
<p>执行sysexit汇编语言指令，它和sysenter指令同时在InterPentiumII微处理器中引入</p>
<p>支持进入内核的两种不同方式并不像看起来那么简单，因为：</p>
<p>内核必须既支持只使用int$0x80指令的旧函数库，同时支持也可以使用sysenter指令的新函数库</p>
<p>使用sysenter指令的标准库必须能处理仅支持int$0x80指令的旧内核</p>
<p>内核和标准库必须既能运行在不包含sysenter指令的旧处理器上，也能运行在包含它的新处理器上</p>
<p>[1]通过int$0x80指令发出系统调用</p>
<p>调用系统调用的传统方法是使用汇编语言指令int</p>
<p>向量128（十六进制0x80）对应于内核入口点。在内核初始化期间调用的函数trap_init()，用下面的方式建立对应于向量128的中断描述符表表型：</p>
<p>set_system_gate(0x80,&amp;system_call);</p>
<p>该调用把下列值存如这个门描述符的相应字段：</p>
<p>SegmentSelecor:内核代码段__KERNEL_CS的段选择符</p>
<p>Offset:指向system_call()系统调用处理程序的指针</p>
<p>Type：置15表示这个异常是一个陷阱，相应的处理程序不禁止可屏蔽中断</p>
<p>当用户态进程发出int$0x80指令时，CPU切换到内核态并开始从地址system_call处开始执行指令    </p>
<p>(1)system_call()</p>
<p>  system_call()函数首先把系统调用号和这个异常处理程序可以用到的所有CPU寄存器保存到相应的栈中，不包括由控制单元已自动保存的eflags、cs、eip、ss和esp寄存器</p>
<p>  随后，这个函数在ebx中存放当前进程的thread_info数据结构的地址，这是通过获得内核栈指针的值并把它取整到4KB或8KB的倍数而完成的</p>
<p>  接下来，system_call()函数检查thread_info结构flag字段的TIF_SYSCALL_TRACE和TIF_SYSCALL_AUDIT标志之一是否被设置为1，也就是检查是否有某一调试程序正在跟踪执行程序对系统调用的调用。如果是这种情况，那么system_call()函数两次调用do_syscall_trace()函数；一次正好在这个系统调用服务例程执行之前，一次在其之后。这个函数停止current,并因此允许调试进程收集关于current的信息</p>
<p>  然后，对用户态进程传递来的系统调用号进行有效性检查。如果这个号大于或等于系统调用分派表中的表项数，系统调用处理程序就终止</p>
<p>  如果系统融调用号无效，该函数就把-ENOSYS值存放在栈中曾保存eax寄存器的单元中。然后跳到resume_userspace,当进程恢复它在用户态的执行时，会在eax中发现一个负的返回码。</p>
<p>最后，调用与eax中所包含的系统调用号对应的特定服务例程：call*sys_call_table(0,%eax,4)</p>
<p>  因此分派表中的每个表项占4个字节，因此首先把系统调用号乘以4，在加上sys_call_table分派的起始地址，然后从这个地址单元获取指向服务例程的指针，内核就找到了要调用的服务例程。</p>
<p>  (2)从系统调用退出</p>
<p>  当系统调用服务例程结束时，system_call()函数从eax获得它的返回值，比并把这个返回值存放在曾保存用户态eax存储器值的那个栈单元的位置上</p>
<p>  然后，system_call()函数关闭本地中断并检查当前进程的thread_info结构中的标志：</p>
<p>  只要有任何一种标志被设置，那么就要在返回用户态之前完成一些工作。</p>
<p>  [2]通过sysenter指令发出系统调用    </p>
<p>  汇编语言指令int由于要执行几个一致性和安全性检查，所以速度较慢，在intel文档中被称为“快速系统调用”的sysenter指令，提供了一种从用户态到内核态的快速切换方法。</p>
<p>  (1)sysenter指令</p>
<p>  汇编语言指令sysenter使用三种特殊的寄存器，它们必须装入下述信息：</p>
<p>  SYSENTER_CS_MSR:内核代码段的段选择符</p>
<p>  SYSENTER_EIP_MSR:内核入口点的线性地址</p>
<p>  SYSENTER_ESP_MSR:内核堆栈指针</p>
<p>  执行sysenter指令时，CPU控制单元：</p>
<p>  把SYSENTGER_CS_MSR的内容拷贝到cs</p>
<p>  把SYSENTGER_EIP_MSR的内容拷贝到eip</p>
<p>  把SYSENTGER_ESP_MSR的内容拷贝到esp</p>
<p>  把SYSENTGER_CS_MSR的内容拷贝到ss</p>
<p>  因此，CPU切换到内核态并开始执行内核入口点的第一条指令</p>
<p>  内核堆栈段与内核数据段是一致的，而且在全局描述符表中，其描述符紧跟在内核代码段的描述符之后；所有第4步把正确的段选择符装入了ss寄存器。</p>
<p>  在内核初始化期间，一旦系统中的每个CPU执行函数enable_sep_cpu()，三个特定与模型的寄存器就由该函数初始化了。enable_sep_cpu()函数执行以下步骤：</p>
<p>  1、把内核代码(<strong>KENNEL</strong>CS)的段选择符写入SYSENTER_CS_MSR寄存器</p>
<p>  2、把下面要说明的函数sysenter_entry()的线性地址写入SYSENTER_CS_EIP寄存器</p>
<p>  3、计算本地TSS末端的线性地址，并把这个值写入SYSENTER_CS_ESP寄存器</p>
<p>  (2)vsyscall页</p>
<p>  只要CPU和Linux内核都支持sysenter指令，标准库libc中的封装函数就可以使用它。</p>
<p>  这个兼容性问题需要非常复杂的解决方案。本质上，在初始化阶段，sysenter_setup()函数建立一个称为vsyscall页得页框，其中包括一个小的EFL共享对象(也就是一个很小的EFL动态链接库)。当进程发出exeve()系统调用而开始执行一个EFL程序时，vsyscall页中的代码就会自动地被链接到进程的地址空间。vsyscall页中的代码使用最有用的指令发出系统调用。</p>
<p>  函数sysenter_setup()为vsyscall页分配一个新页框，并把它的物理地址与FIX_VSYSCLL固定映射的线性地址相关联。然后，函数sysenter_setup()把预先定义好的一个或两个EFL共享对象拷贝到该页中。</p>
<p>  当标准库中的封装例程必须调用系统调用时，都调用__kernel_vsyscall()函数，不管它的实现代码是什么。</p>
<p>  最后一个兼容性问题是由于老版本的Linux内核不支持sysenter指令，在这种情况下，内核当然不建立vsyscall页，而且函数__kernel_vsyscall()不会被链接到用户态进程的地址空间。当新近的标准库识别出这种状况后，就简单地执行int$0x80指令来调用系统调用。</p>
<p>  (3)进入系统调用</p>
<p>  当用sysenter指令发出系统调用时，依次执行下述步骤：</p>
<p>  1、标准库中的封装例程把系统调用号装入eax寄存器，并调用__kernel_vsyscall()函数</p>
<p>  2、函数__kernel_vsyscall()把ebp、edx和ecx的内容保存到用户态堆栈中（系统调用处理程序将使用这些寄存器），把用户栈指针拷贝到ebp中，然后执行sysenter指令</p>
<p>  3、CPU从用户态切换到内核态，内核开始执行sysenter_entry()函数（由SYSENTER_EIP_MSR寄存器指向）</p>
<p>  4、sysenter_entry()汇编语言函数执行下述步骤：</p>
<p>  a、建立内核堆栈指针：</p>
<p>  b、打开本地中断</p>
<p>  c、把用户数据段的段选择符、当前用户栈指针、eflags寄存器、用户代码段的段选择符以及从系统调用退出时要执行的指令的地址保存到内核态堆栈中：</p>
<p>  d、把原来由封装例程传递的寄存器的值恢复到ebp中</p>
<p>  e、通过执行一系列指令调用系统调用处理程序。</p>
<p>  (4)退出系统调用</p>
<p>  当系统调用服务例程结束时，sysenter_enter()函数本质上执行与system_call()函数相同的操作。首先，它从eax获得系统调用系统服务例程的返回码，并将返回码存入内核栈中保存用户态eax寄存器值的位置。然后，函数禁止本地中断，并检查current的thread_info结构中的标志。</p>
<p>  如果有任何标志被设置，那么在返回到用户态之前还需要完成一些工作。最后，汇编语言指令iret从内核堆栈中去取5个参数，这些参数是在sysenter_entry()函数的第4c步被保存到内核堆栈中的，这样CPU切换到用户态并开始执行SYSENTER_RETURN标记处得代码。</p>
<p>  (5)sysexit指令</p>
<p>  sysexit是与sysenter配对的汇编语言指令：它允许从内核态快速切换到用户态。执行这条指令时，CPU控制单元执行下述步骤：</p>
<p>  1、把SYSENTER_CS_MSR寄存器中的值加16所得到的结果加载到cs寄存器</p>
<p>  2、把edx寄存器的内容拷贝到eip寄存器</p>
<p>  3、把SYSENTER_CS_MSR寄存器中的值加24所得到的结果加载到ss寄存器</p>
<p>  4、把ecx寄存器d的内容拷贝到esp寄存器</p>
<p>  因为SYSENTER_CS_MSR寄存器加载的是内核代码的段选择符，cs寄存器加载的是用户代码的段选择符，而ss寄存器加载的是用户数据段的段选择符</p>
<p>  结果，CPU从内核态切换到用户态，并开始执行其地址存放在edx中那些指令</p>
<p>  SYSENTER_RETURN的代码    </p>
<p>  SYSENTER_RETURN标记处的代码存放在vsyscall页中，当通过sysenter进入的系统调用被iret或sysexit指令终止时，该页框中的代码被执行</p>
<p>  4、参数传递 </p>
<p>  系统调用通常也需要输入/输出参数。</p>
<p>  因为system_call()和sysenter_entry()函数是Linux中所有系统调用的公共入口，因此每个系统调用至少有一个参数，即通过eax寄存器传递来的系统调用号。例如，如果一个应用程序调用fork()封装例程，那么在执行int$0x80或sysenter汇编指令之前就把eax寄存器置为2.因此这个寄存器的设置是由libc库中的封装例程进行的，因此程序员通常并不用关心系统调用号。</p>
<p>  很多系统调用确实需要由应用程序明确地专递另外的参数。</p>
<p>  普通C函数的参数传递是通过把参数值写入活动的程序栈（用户态栈或者内核态栈）实现的。因为系统调用是一种横跨用户和内核两大陆地的特殊函数，所以既不能使用用户态栈也不能使用内核态栈。更确切地说，在发出系统调用之前，系统调用的参数被写入CPU寄存器，然后在调用系统调用服务例程之前，内核再把存放在CPU中的参数拷贝到内核态堆栈中，这是因为系统调用服务例程是普通的C函数。</p>
<p>  为什么内核不直接把参数从用户态的栈拷贝到内核态的栈呢？首先，同时操作两个栈是比较复杂的，其次，寄存器的使用使得系统调用处理程序的结构与其他异常处理成的结构类似。</p>
<p>  为了用寄存器传递参数，必须满足两个条件：</p>
<p>  每个参数的长度不能超过寄存器的长度，即32位</p>
<p>  参数的个数不能超过6个（除了eax中传递的系统调用号），因为80x86处理器的寄存器的数量是有限的</p>
<p>  第一个条件总能成立，因为根据POSIX标准，不能存放在32为寄存器中的长参数必须通过指定它们的地址来传递。然而，确实存在多于6个参数的系统调用。在这样的情况下，用一个单独的寄存器指向进程地址空间中这些参数值所在的一个内存区</p>
<p>  用于存放系统调用号和系统调用参数的寄存器是（以字母递增的顺序）：eax(存放系统调用号)ebx、ecx、edx、esi、edi、ebp</p>
<p>  [1]验证参数</p>
<p>  检查的类型既依赖于系统调用，也依赖于特定的参数</p>
<p>  有一种检查对所有的系统调用都是通用的。只要一个参数指定的是地址，那么内核必须检查它是否在这个进程的地址空间之内。有两种可能的方式来执行这种检查：</p>
<p>  验证这个线性地址是否属于进程的地址空间，如果是，这个线性地址所在的线性区就具有正确的访问权限</p>
<p>  仅仅验证这个线性地址是否小于PAGE_OFFSET（即没有落在留给内核的线性地址区间内）</p>
<p>  早期的Linux内核执行第一种检查，但是这是非常费时的</p>
<p>  因此，从Linux2.2内核开始执行第二种检查，这是一种更高效的检查，因为不需要对进程的线性区描述符进行任何扫描。</p>
<p>  接着采用的方法是将真正的检查尽可能向后推迟，也就是说，推迟到分页单元将线性地址转换为物理地址时</p>
<p>  究竟为什么要进行这种粗略检查。事实上，这种粗略的检查是至关重要的，它确保了进程地址空间和内核地址空间都不被非法访问。</p>
<p>  [2]访问进程地址空间</p>
<p>  系统调用服务例程需要非常频繁地读写进程地址空间的数据。Linux包含的一组宏使这种访问更加容易。两个名为get_user()和put_user()的宏。第一个宏用来从一个地址读取1、2、或4个连续字节，而第二个宏用来把这几种大小的内容写入一个地址中</p>
<p>  表10-1：中列出了内核态下用来访问进程地址空间的另外几个函数或宏。</p>
<p>  注意：许多函数或宏的名字前缀有两个下划线（__）。首部没有下划线的函数或宏要用额外的时间对所请求的线性地区间进行有效性检查，而有下划线的则会跳过检查。当内核必须重复访问进程地址空间的同一块线性区时，比较高效的方法是开始时只对该地址检查一次，以后就不用在对该进程区进行检查了。</p>
<p>  [3]动态地址检查：修改代码</p>
<p>  access_ok()宏对系统调用以参数传递来的线性地址的有效性只进行粗略检查。该检查只保证用户态进程不会试图侵扰内核地址空间。但是，由参数传递的线性地址依然可能不属于进程地址空间。在这种情况下，当内核试图使用任何这种错误地址时，将会发生缺页异常。</p>
<p>  内核态引起缺页异常的四种情况：（这些情况必须由缺页异常处理程序来区分）</p>
<p>  1、内核试图访问属于进程地址空间的页，但是，或者是相应的页框不存在，或者是内核试图去写一个只读页。在这些情况下，处理程序必须分配和初始化一个新的页框</p>
<p>  2、内核寻址到属于其地址空间的页，但是相应的页表项还没有被初始化。在这种情况下，内核必须在当前进程页表中适当地建立一些表项</p>
<p>  3、某一内核函数包含编程错误，当这个函数运行时就引起异常；或者，可能由于瞬时的硬件错误引起异常。当这种情况发生时，处理程序必须执行一个内核漏洞。</p>
<p>  4、系统调用服务例程试图读写一个内存区，而该内存区的地址是通过系统调用参数传递来的，但却不属于进程的地址空间。</p>
<p>  通过确定错误的线性地址是否属于进程所拥有的线性地址区间，缺页处理程序可以很容易地识别第一种情况。通过检查相应的主内核页表是否包含一个映射该地址的非空项页可以检测第二种情况。    </p>
<p>  [4]异常表</p>
<p>  决定缺页的来源关键在于内核使用有限的范围访问进程的地址空间，少数函数和宏用来访问进程的地址空间</p>
<p>  把访问进程地址空间的每条内核指令的地址放到一个叫异常表（exceptiontable）的结构中并不用费太多功夫。当在内核态发生缺页异常时，do_page_fault()处理程序检查异常表；如果表中包含产生异常的指令地址，那么这个错误就是由非法的系统调用参数引起的，否则，就是由某一更严重的bug引起的</p>
<p>  每一个异常表的表项是一个exception_tabel_entry结构，它有两个字段：</p>
<p>  insn:访问进程地址空间的指令的线性地址。</p>
<p>  fixup:当存放在insn单元中的指令所触发的缺页异常发生时，fixup就是要调用的汇编语言代码的地址。</p>
<p>  search_exception_tables()函数用来在所有异常表中查找一个指定地址    </p>
<p>  [5]生成异常表和修正代码</p>
<p>  5、内核封装例程 </p>
<p>  尽管系统调用主要由用户态进程使用，但也可以被内核线程调用，内核线程不能使用库函数，为了简化相应封装例程的声明，Linux定义了7个从_syscall0到_syscall6的一组宏</p>
<p>  每个宏名字中的数字0-6对应着系统调用所用的参数个数（系统调用号除外），也可以用这些宏来声明没有包含在libc标准库中的封装例程。然后，不能用这些宏来为超过6个参数的系统调用或产生非标准返回值的系统调用定义封装例程。</p>
<p>  每个宏严格第需要2+2*n个参数，n是系统调用的参数个数。前两个参数指明系统调用的返回值类型的名字；每一对附加参数指明相应的系统调用参数的类型和名字。因此，以fork()系统调用为例，其封装例程可以通过如下语句产生：</p>
<p>_syscall0(int,fork)</p>
<p>  而write()系统调用的封装例程可以通过如下语句产生：</p>
<p>_syscall3(int,write,int,fd,constchar*but,unsignedint,count)</p>
<p>  这个宏展开：</p>
<p>  intwrite(intfd,constchar*buf,unsignedintcount){</p>
<pre><code>。。。</code></pre><p>  }</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/10/29/深入理解Linux内核-系统调用/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-信号" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/10/22/深入理解Linux内核-信号/">深入理解Linux内核-信号</a>
    </h1>
  

        
        <a href="/2012/10/22/深入理解Linux内核-信号/" class="archive-article-date">
  	<time datetime="2012-10-22T09:24:10.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-10-22</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>第十一章信号 </p>
<p>信号用于在用户态进程间通信。内核也用信号通知进程系统所发生的事情。 </p>
<p>1、信号的作用 </p>
<p>信号(signal)是很短的消息，可以被发送到一个进程或一组进程。发送给进程的唯一信息通常是一个数，以此来标识信号。</p>
<p>使用信号的两个主要目的 ：</p>
<p>让进程知道已经发生了一个特定的事件。</p>
<p>强迫进程执行它自己代码中的信号处理程序。 </p>
<p>当然，这两个目的不是互斥的，因为进程经常通过执行一个特定的例程来对某一事件作出反应。</p>
<p>常规信号： 前31个</p>
<p>实时信号： 32-64</p>
<p>实时信号与常规信号有很大的不同，因为它们必须排队以便发送的多个信号能被接收 到。另一方面，同种类型的常规信号并不排队 ；如果一个常规信号被连续发送多次，那么，只有其中的一个发送到接收进程。尽管Linux内核并不使用实时信号，它还是通过几个特定的系统调用完全实现了POSIX标准。</p>
<p>许多系统调用允许程序员发送信号，并决定他们的进程如何响应所接收的信号。</p>
<p>信号的一个重要特点 是它们可以随时被发送给状态经常不可预知的进程 。发送给非运行进程的信号必须由内核保存，直到进程恢复执行。</p>
<p>阻塞一个信号要求信号的传递拖延，直到随后解除阻塞，这使得信号产生一段时间之后才能对其传递这一问题变得更加严重。</p>
<p>内核区分信号传递的两个不同阶段 ：</p>
<p>信号产生 ：</p>
<p>内核更新目标进程的数据结构以表示一个新信号已被发送。</p>
<p>信号传递 ：</p>
<p>内核强迫目标进程通过以下方式对信号做出反应：或改变目标进程的执行状态，或开始执行一个特定的信号处理程序 ，或两者都是。</p>
<p>每个所产生的信号至多被传递一次。信号是可消费资源：一旦它们已传递出去，进程描述符中有关这个信号的所有信息都被取消。</p>
<p>已经产生但还没有传递的信号称为挂起信号(pendingsignal)。任何时候，一个进程仅存在给定类型的一个挂起信号，同一进程同种类型的其他信号不被排队，只被简单地丢弃。但是，实时信号是不同的：同种类型的挂起信号可以有好几个。</p>
<p>信号可以保留不可预知的挂起时间，必须考虑的因素：</p>
<p>信号通常只被当前正运行的进程传递</p>
<p>给定类型的信号可以由进程选择性地阻塞</p>
<p>当进程执行一个信号处理程序的函数时，通常“屏蔽”相应的信号，即自动阻塞这个信号到处理程序结束。因此，所处理的信号的另一次出现不能中断信号处理程序，所以，信号处理函数不必是可重入的 。</p>
<p>内核实现：</p>
<p>记住每个进程阻塞哪些信号</p>
<p>当从内核态切换到用户态时，对任何一个进程都要检查是否有一个信号已到达。这几乎在每个定时中断时都发生</p>
<p>确定是否可以忽略信号。这个发生在下列所有的条件都满足时：</p>
<p>目标进程没有被另一个进程跟踪</p>
<p>信号没有被目标进程阻塞</p>
<p>信号被目标进程忽略</p>
<p>处理这样的信号，即信号可能在进程运行期间的任一时刻请求把进程切换到一个信号处理函数，并在这个函数返回以后恢复原来执行的上下文。    </p>
<p>[1]传递信号之前所执行的操作 </p>
<p>进程以三种方式对一个信号做出应答： </p>
<p>（1）显示地忽略信号 </p>
<p>（2）执行与信号相关的缺省操作 。由内核预定义的缺省操作取决于信号的类型，下列类型：</p>
<p>Terminate:进程被终止（杀死）</p>
<p>Dump:进程被终止(杀死)</p>
<p>Ignore:信号被忽略</p>
<p>Stop:进程被停止，即把进程置为TASK_STOPPED状态</p>
<p>Continue:如果进程被停止，就把它置为TASK_RUNNING状态</p>
<p>（3）通过调用相应的信号处理函数捕获信号 </p>
<p>注意，被对一个信号的阻塞和忽略是不同的：只要信号被阻塞，它就不被传递；只有在信号解除阻塞后才传递它。而一个被忽略的信号总是被传递，只是没有进一步的操作。 </p>
<p>SIGKILL和SIGSTOP信号不可以被显示地忽略、捕获或阻塞，因此，通常必须执行它们的缺省操作。因此，SIGKILL和SIGSTOP允许具有适当特权的用户分别终止并停止任何进程，不管进程执行时采取怎样的防御措施。</p>
<p>如果信号的传递会引起内核杀死一个进程，难么这个信号对该进程就是致命的。SIGKILL信号总是致命的；而且，缺省操作为Terminate的每个信号，以及不被进程捕获的信号对该进程也是致命的。注意，如果一个被进程所捕获的信号，其对应的信号处理函数终止了这个进程，那么这个信号就不是致命的，因为进程自己选择了终止，而不是被内核杀死。</p>
<p>[2]POSIX信号和多线程应用 </p>
<p>POSIX1003.1标准对多线程应用的信号处理有一些严格的要求 ：</p>
<p>信号处理程序必须在多线程应用的所有线程之间共享；不过，每个线程必须有自己的挂起信号掩码和阻塞信号掩码。</p>
<p>POSIX库函数kill()和sigqueue()必须向所有的多线程应用而不是某个特殊的线程发送信号。所有由内核产生的信号同样如此。</p>
<p>每个发送给多线程应用的信号仅传送给一个线程，这个线程是由内核在从不会阻塞该信号的线程中随意选择出来的</p>
<p>如果向多线程应用发送了一个致命的信号，那么内核将杀死该应用的所有线程，而不仅仅是杀死接收信号的那个线程。</p>
<p>Linux内核2.6把多线程应用实现为一组属于同一个线程组的轻量级进程。</p>
<p>如果一个挂起信号被发送给了某个特定进程，那么这个信号是私有的；如果被发送给了整个线程组，它就是共享的</p>
<p>[3]与信号相关的数据结构 </p>
<p>对系统中的每个进程来说，内核必须跟踪什么信号当前正在挂起或被屏蔽，以及每个线程组是如何处理所有信号的。为了完成这些操作，内核使用几个处理器描述符可存取的数据结构：参考图11-1***</p>
<p>(1)信号描述符和信号处理程序描述符 </p>
<p>进程描述符signal字段指向信号描述符(signaldescriptor)–一个signal_struct 类型的结构，用来跟踪共享挂起信号。</p>
<p>除了信号描述符以外，每个进程还引用一个信号处理程序描述符(signal handler deseriplor),它是一个sighand_struct 类型的结构，用来描述每个信号必须怎样被线程组处理</p>
<p>(2)sigaction数据结构</p>
<p>一些体系结构把特性赋给仅对内核可见的信号。因此，信号的特性存放在k_sigaction结构中，k_sigaciton结构既包含对用户态进程所隐藏的特性，也包含大家熟悉的sigaction结构，该结构保存了用户态进程能看见的所有特性。实际上，在80x86平台上，信号的所有特性对用户态的进程都是可见的。因此,k_sigaction结构只不过简化为类型为sigaction的单个sa结构。字段：</p>
<p>sa_handler:指定要执行操作的类型。它的值可以是指向信号处理程序的一个指针,SIG_DFL（即值0，指定执行缺省操作），或者SIG_IGN（即值1，指定忽略信号）</p>
<p>sa_flags:是一个标志集，指定必须怎样处理信号。</p>
<p>sa_mask:类型为sigset_t的变量，指定当运行信号处理程序时要屏蔽的信号</p>
<p>(3)挂起信号队列 </p>
<p>有几个系统调用能产生发送给整个线程组的信号，如kill()和rt_sigqueueinfo() ，而其他的一些则产生发送给特定进程的信号，如tkill()和tgkill()</p>
<p>  为了跟踪当前的挂起信号是什么，内核把两个挂起信号队列与每个进程相关联：</p>
<p>  共享挂起信号队列，它位于信号描述符的shared_pending字段，存放整个线程组的挂起信号</p>
<p>  私有挂起信号队列，它位于进程描述符的pending字段，存放特定进程的挂起信号</p>
<p>  [4]在信号数据结构上的操作 ：参考p429-430的函数列表 </p>
<p>  2、产生信号 </p>
<p>  很多内核函数都会产生信号：它们完成信号处理第一步的工作，即根据需要更新一个或多个进程的描述符。 它们不直接执行第二步的信号传递操作，而是可能根据信号的类型和目标进程的状态唤醒一些进程，并促使这些进程接收信号。</p>
<p>  当发送给进程一个信号时，这个信号可能来自内核，也可能来自另一个进程。内核通过对如表11-9所示的某个函数进行调用而产生信号</p>
<p>  当一个信号被发往整个线程组时，这个信号可能来自内核，也可能来自另一个进程。内核通过对如表11-10所示的某个函数进行调用而产生信号</p>
<p>  [1]specific_send_sig_info()函数：向指定进程发送信号，步骤：参考p433</p>
<p>  [2]send_signal()函数:在挂起信号队列中插入一个新元素,步骤：参考p434</p>
<p>  [3]group_send_sig_info()函数:向整个线程组发送信号，步骤：参考p435-437 </p>
<p>  3、传递信号 </p>
<p>  为确保进程的挂起信号得到处理内核所执行的操作。</p>
<p>  内核在允许进程恢复用户态下的执行之前，检查进程TIF_SIGPENDING标志的值。每当内核处理完一个中断或异常时，就检查是否存在挂起信号 </p>
<p>  为了处理非阻塞的挂起信号，内核调用do_signal()函数</p>
<p>  通常只是在CPU要返回到用户态时才调用do_signal()函数</p>
<p>  do_signal()函数的核心由重复调用dequeue_signal()函数的循环组成，直到在私有挂起信号队列和共享挂起信号队列中都没有非阻塞的挂起信号时，循环才结束。</p>
<p>  dequeue_singal()函数首先考虑私有挂起信号队列中的所有信号，并从最低编号的挂起信号开始。然后考虑共享队列中的信号。它更新数据结构以表示信号不再是挂起的，并返回它的编号。</p>
<p>  do_signal()函数如何处理每一个挂起的信号，其编号由dequeue_signal()返回。首先，它检查current接收进程是否正受到其他一些进程的监控；在肯定的情况下，do_signal()调用do_notify_parent_cldstop()和schedule()让监控进程知道进程的信号处理。</p>
<p>  然后，do_signal()把要处理信号的k_sigaction数据结构的地址赋给局部变量ka;根据ka的内容可以执行三种操作：忽略信号、执行缺省操作或执行信号处理程序。如果显式忽略被传递的信号，那么do_signal()函数仅仅继续执行循环，并由此考虑另一个挂起信号</p>
<p>  [1]执行信号的缺省操作 </p>
<p>  如果ka-&gt;sa.sa_handler等于SIG_DFL,do_signal()就必须执行信号的缺省操作。唯一的例外是当接收进程是init时，这个信号被丢弃。</p>
<p>  SIGSTOP与其他信号的差异比较微妙：SIGSTOP总是停止线程组，而其他信号只停止不在“孤儿进程组”中的线程组。POSIX标准规定，只要进程组中一个进程有父进程，尽管进程处于不同的进程组中但在同一个会话中，那么这个进程组就不是孤儿。因此，如果父进程死亡，但启动该进程的用户并登录在线，那么该进程组就不是一个孤儿。</p>
<p>  缺省操作为Dump的信号可以在进程的工作目录中创建一个“转储”文件，这个文件列出进程地址空间和CPU寄存器的全部内容</p>
<p>  [2]捕获信号 </p>
<p>  如果信号有一个专门的处理程序，do_signal()就函数必须强迫该处理程序执行。这是通过调用handle_signal()进行的 </p>
<p>  注意do_signal()的处理了一个单独的信号后怎样返回。直到下一次调用do_signal()时才考虑其他挂起的信号。这种方式确保了实时信号将以适当的顺序得到处理</p>
<p>  执行一个信号处理程序是件相当复杂的任务，因此在用户态和内核态之间切换时需要谨慎地处理栈中的内容 。我们将正确地解释这里所承担的任务</p>
<p>  信号处理程序是用户态进程所定义的函数，并包含在用户态的代码段中。handle_signal()函数运行在内核态，而信号处理程序运行在用户态，这就意味着在当前进程恢复“正常”执行之前，它必须首先执行用户态的信号处理程序。此外，当内核打算恢复进程的正常执行时，内核态堆栈不再包含被中断程序的硬件上下文，因此每当从内核态向用户态转换时，内核态堆栈都被清空。而另外一个复杂性是因为信号处理程序可以调用系统调用，在这种情况下，执行了系统调用的服务例程以后，控制权必须返回到信号处理程序而不是到被中断程序的正常代码流。</p>
<p>  linux所采用的解决方法是把保存在内核态堆栈中的硬件上下文拷贝到当前进程的用户态堆栈中。用户态堆栈也以这样的方式被修改，即当信号处理程序终止时，自动调用sigreturn()系统调用把这个硬件上下文拷贝回到内核态堆栈中，并恢复用户态堆栈中原来的内容。</p>
<p>  图11-2说明了有关捕捉一个信号的函数的执行流：</p>
<p>  一个非阻塞的信号发送给一个进程。当中断或异常发生时，进程切换到内核态。</p>
<p>  正要返回到用户态前，内核执行do_signal()函数，</p>
<p>这个函数又依次处理信号（通过调用handle_signal()）和建立用户态堆栈(通过调用setup_frame()或setup_rt_frame())</p>
<p>  当进程又切换到用户态时，因为信号处理程序的起始地址被强制放进程序计数器中，因此开始执行信号处理程序。</p>
<p>  当处理程序终止时，setup_frame()或setup_rt_frame()函数放在用户态堆栈中的返回代码就被执行。这个代码调用sigreturn()或rt_sigrenturn()系统调用，相应的服务例程把正常程序的用户态堆栈硬件上下文拷贝到内核堆栈，并把用户态堆栈恢复到它原来的状态(通过调用restore_sigcongtext()).当这个系统调用结束时，普通进程就因此能恢复自己的执行</p>
<p>  图：11-2***</p>
<p>  (1)建立帧 </p>
<p>为了适当地建立进程的用户态堆栈，handle_signal()函数或者调用setup_frame()或者调用setup_rt_frame()</p>
<p>  setup_frame()函数把一个叫做帧(frame)的数据结构推进用户态堆栈中，这个帧含有处理信号所需要的信息，并确保正确返回到handle_signal()函数</p>
<p>  setup_frame()函数把保存在内核态堆栈的段寄存器内容重新设置成它们的缺省值以后才结束。现在，信号处理程序所有需的信息就在用户态堆栈的顶部。</p>
<p>  (2)检查信号标志 </p>
<p>  建立了用户态堆栈以后,handle_signal()函数检查与信号相关的标志值。如果信号没有设置SA_NODEFER标志，在sigaction表中sa_make字段对应的信号就必须在信号处理程序执行期间被阻塞，然后，handle_signal()返回到do_signal()，do_signal()也立即返回</p>
<p>  (3)开始执行信号处理程序 </p>
<p>  do_signal()返回时，当前进程恢复它在用户态的执行。由于如前所述setup_frame()的准备，eip寄存器指向信号处理程序的第一条指令，而esp指向已推进用户态堆栈顶的帧的第一个内存单元。因此，信号处理程序被执行。</p>
<p>  (4)终止信号处理程序 </p>
<p>  信号处理程序结束时，返回栈顶地址，该地址指向帧的pretcode字段所引用的vsyscall页中的代码。因此，信号编号(即帧的sig字段)被从栈中丢弃，然后调用sigreturn()系统调用</p>
<p>  sys_rt_sigreturn()服务例程把来自扩展帧的进程硬件上下文拷贝到内核态堆栈，并通过从用户态堆栈删除扩展帧以恢复用户态堆栈原来的内容。</p>
<p>  (5)系统调用的重新执行 </p>
<p>  内核并不总是能立即满足系统调用发出的请求，在这种情况发生时，把发出系统调用的进程置为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE状态</p>
<p>  如果进程处于TASK_INTERRUPTIBLE状态，并且某个进程向它发送了一个信号，那么，内核不完成系统调用就把进程置成TASK_RUNNING状态。当切换回用户态时信号被传递给进程。当这种情况发生时，系统调用服务例程没有完成它的工作，但返回EINTR,ERESTARTNOHAND,ERESTART_RESTARTBLOCK,ERESTARTSYS或ERESTARTNOINTR错误码。实际上，这种情况下用户态进程获得的唯一错误码是EINTR,这个错误码表示系统调用还没有执行完。内核内部使用剩余的错误码来指定信号处理程序结束后是否自动重新执行系统调用。</p>
<p>  与未完成的系统调用相关的出错码及这些出错码对信号三种可能的操作产生的影响。</p>
<p>  Terminate:不会自动重新执行系统调用</p>
<p>  Reexecut:内核强迫用户态进程把系统调用号重新装入eax寄存器，并重新执行int$0x80指令或sysenter指令。进程意识不到这种重新执行，因此出错码也不传递给进程。</p>
<p>  Depends:只有被传递信号的SA_RESTART标志被设置，才重新执行系统调用；否则系统调用-EINTER出错码结束</p>
<p>  当传递信号时，内核在试图重新执行一个系统调用前必须确定进程确实发出过这个系统调用。这就是regs硬件上下文的orig_eaz字段起重要作用之处    </p>
<p>  a、重新执行被未捕获信号中断的系统调用</p>
<p>  如果信号被显式地忽略，或者如果它的缺省操作已被强制执行，do_signal()就分析系统调用的出错码，并如表11-11中所说明的那样决定是否重新自动执行未完成的系统调用。如果必须重新开始执行系统调用，那么do_signal()就修改regs硬件上下文，以便在进程返回到用户态时，eip指向int$0x80指令或sysenter指令，且eax包含系统调用号</p>
<p>  b、为所捕获的信号重新执行系统调用</p>
<p>  如果信号被捕获，那么handle_signal()分析出错码，也可能分析sigaction表的SA_RESTART标志来决定是否必须重新执行未完成的系统调用</p>
<p>  如果系统调用必须被重新开始执行，handle_signal()就与do_signal()完全一样地继续执行；否则，它向用户态进程返回一个出错码-ENTR</p>
<p>  4、与信号处理相关的系统调用 </p>
<p>  在用户态运行的进程可以发送和接收信号。这意味着必须定义一组系统调用用来完成这些操作。遗憾的是，由于历史的原因，已经存在几个具有相同功能的系统调用，因此，其中一些系统调用从未被调用。例如：系统调用sys_sigaction()和sys_rt_sigaciton()几乎是相同的，因此C库中封装函数sigaction()调用sys_rt_sigaction()而不是sys_sigaction()。</p>
<p>  [1]kill()系统调用 </p>
<p>  一般用kill(pid,sig) 系统调用向普通进程或多线程应用发送信号，其相应的服务例程是sys_kill()函数</p>
<p>  kill()系统调用能发送任何信号，即使编号在32-64之间的实时信号。kill()系统调用不能确保把一个新的元素加入到目标进程的挂起信号队列，因此，挂起信号的多个实例可能被丢失。实时信号应该当通过rt_siggueueinfo()系统调用进行发送</p>
<p>  [2]tkill和gkill()系统调用 </p>
<p>  tkill()和tgkill() 系统调用向线程组中的指定进程发送信号</p>
<p>  [3]改变信号的操作 </p>
<p>  sigaction(sig,act,oact) 系统调用允许用户为信号指定一个操作。当然，如果没有自定义的信号操作，那么内核执行与传递的信号相关的缺省操作</p>
<p>  [4]检查挂起的阻塞信号 </p>
<p>  sigpending( )系统调用允许进程检查挂起的阻塞信号的集合，也就是说，检查信号被阻塞时已产生的那些信号</p>
<p>  [5]修改阻塞信号的集合 </p>
<p>  sigprocmask() 系统调用允许进程修改阻塞信号的集合。这个系统调用只应用于常规信号</p>
<p>  [6]挂起进程 </p>
<p>  sigsuspend() 系统调用把进程置为TASK_INTERRUPTIBLE状态，当然这是把mask参数指向的位掩码数组所指定的标准信号阻塞以后设置的。只有当一个非忽略、非阻塞的信号发送到进程以后，进程才被唤醒</p>
<p>  [7]实时信号的系统调用 </p>
<p>  系统调用只应用到标准信号，因此，必须引入另外的系统调用来允许用户态进程处理实时信号</p>
<p>实时信号的几个系统调用：rt_sigaction()rt_sigpending()rt_sigprocmask()rt_sigsuspend()</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/10/22/深入理解Linux内核-信号/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-中断和异常" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/10/01/深入理解Linux内核-中断和异常/">深入理解Linux内核-中断和异常</a>
    </h1>
  

        
        <a href="/2012/10/01/深入理解Linux内核-中断和异常/" class="archive-article-date">
  	<time datetime="2012-10-01T09:24:29.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-10-01</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由 王宇 原创并发布 ：</p>
<p>第四章中断和异常 </p>
<p>中断通常被定义为一个事件，该事件改变处理器执行的指令。这样的事件与CPU芯片内外部硬件电路产生的电信号相对应。</p>
<p>中断通常分为同步中断 和异步中断 ：</p>
<p>同步中断是当指令执行时由CPU控制单元 产生的，之所以称为同步，是因为只有在一条指令终止执行后CPU才会发出中断。</p>
<p>异步中断是由其他硬件设备 依照CPU时钟信号随机产生的</p>
<p>在intel微处理器手册中，把同步和异步终端分别称为异常和中断 。当然有时我们也用术语“中断信号 “指着两种类型</p>
<p>中断是由间隔定时器和I/O设备产生的 ，例如，用户的一次按键会引起一个中断</p>
<p>另一方面，异常是由程序的错误产生的，或者是由内核必须处理的异常条件产生的 。第一种情况下，内核通过发送一个每个Unix程序员都熟悉的信号来处理异常。第二种情况下，内核执行恢复异常需要的所有步骤，例如：缺页，或对内核服务的一个请求</p>
<p>I/O设备产生IRQ</p>
<p>1、中断信号的作用 </p>
<p>中断信号提供了一种特殊的方式，使处理器转而去运行正常控制流之外的代码。当一个中断信号到达时，CPU必须停止它当前正在做的事情，并且切换到一个新的活动。 为了做到这一点，就要在内核态堆栈保存程序计数器的当前值，并把与中断类型相关的一个地址放入程序计数器。</p>
<p>中断处理与进程切换有一个明显的差异：由中断或异常处理程序执行的代码不是一个进程。更确切地说，它是一个内核控制路径，代表中断发生时正在运行的进程。 </p>
<p>中断处理是由内核执行的最敏感的任务之一，因为它必须满足下列约束 ：</p>
<p>[1]当内核正打算去完成一些别的事情时，中断随时会到来。因此，内核和目标就是让中断尽可能快地处理完，尽其所能把更多的处理向后推迟 。因此，内核响应中断后需要进行的操作分为两部分：关键而紧急的部分，内核立即执行；其余推迟的部分内核随后执行。</p>
<p>[2]因为中断随时会到来，所以内核可能正在处理其中的一个中断时，另一个中断又发生了。应该尽可能多地允许这种情况发生，因此这能维持更多的I/O设备处于忙状态。因此，中断处理程序必须编写成是相应的内核控制路径能以嵌套的方式执行。 当最后一个内核控制路径终止时，内核必须能恢复被中断进程的执行，或者，如果中断信号已导致了重新调度，内核能切换到另外的进程。</p>
<p>[3]尽管内核在处理前一个中断时可以接受一个新的中断，但在内核代码中还是存在一些临界区 ，在临界区中，中断必须被禁止。必须尽可能地限制这样的临界区，因为根据以前的要求，内核，尤其是中断处理程序，应该在大部分时间内以开中断的方式运行 。 </p>
<p>2、中断和异常 </p>
<p>Intel文档把中断和异常分为以下几类：</p>
<p>中断： </p>
<p>可屏蔽中断 </p>
<p>I/O设备发出的所有中断请求都产生可屏蔽中断。可屏蔽中断可以处于两种状态：屏蔽的或非屏蔽的；一个屏蔽的中断只要还是屏蔽的，控制单元就忽略它。</p>
<p>非屏蔽中断 </p>
<p>只有几个危急事件（如硬件故障）才引起非屏蔽中断。非屏蔽中断总是由CPU辨认。</p>
<p>异常 ：</p>
<p>故障 ：通常可以纠正</p>
<p>陷阱 ：在陷阱指令执行后立即报告；主要用于是为了调试程序。在这种情况下，中断信号的作用是通知调试程序一条特殊指令已被执行。</p>
<p>异常中止 ：发生一个严重的错误</p>
<p>编程异常 ：在编程者发出请求时发生</p>
<p>每个中断和异常是由0-255之间的一个数来标识。因为一些未知的原因，Intel把这个8位的无符号整数叫做一个向量。非屏蔽中断的向量和异常的向量是固定的，而可屏蔽中断的向量可以通过对中断控制器的编程来改变。 </p>
<p>[1]IRQ和中断 </p>
<p>每个能够发出中断请求的硬件设备控制器都有一条名为IRQ的输出线。所有现有的IRQ线都与一个名为可编程中断控制器的硬件电路的输入引脚相连 ，可编程中断控制器执行下列动作：</p>
<p>(1)监视IRQ线，检查产生的信号</p>
<p>(2)如果一个引发信号出现在IRQ线上：</p>
<p>a.把接收到的引发信号转换成对应的向量</p>
<p>b.把这个向量存放在中断控制器的一个I/O端口，从而允许CPU通过数据总线读此向量</p>
<p>c.把引发信号发送到处理器的INTR引脚，即产生一个中断</p>
<p>d.等待，直到CPU通过把这个中断信号写进可编程中断控制器的一个I/O端口来确认它；当这种情况发生时，清INTR线。</p>
<p>(3)返回到第1步</p>
<p>IRQ线是从0开始顺序编号的，因此，第一条IRQ线通常表示成IRQ0.与IRQn并联的Intel的缺省向量是n+32.</p>
<p>可以有选择地禁止每条IRQ线。因此，可以对PIC编程从而禁止IRQ，也就是说，可以告诉PIC停止对给定的IRQ线发布中断，或者激活它们。禁止的中断时丢失不了的，它们一旦被激活，PIC就又把它们发送到CPU。这个特点被大多数中断处理程序使用，因为这允许中断处理程序逐次地处理同一类型的IRQ</p>
<p>有选择地激活/禁止IRQ线不同于可屏蔽中断的全局屏蔽/非屏蔽</p>
<p>[2]高级可编程中断控制器 </p>
<p>为了充分发挥SMP体系结构的并行性，能够把中断传递给系统中的每个CPU至关重要。基于此理由，Intel从PentiumIII开始引入了一种名为I/O高级可编程控制器(I/O Advanced Programmable InterruptController APIC)</p>
<p>图4-1</p>
<p>[3]异常 </p>
<p>80x86微处理器发布了大约20种不同的异常。内核必须为每种异常提供一个专门的异常处理程序。更多信息可以在Intel的技术文档中找到</p>
<p>表4-1由异常处理程序发送的信号</p>
<p>[4]中断描述符表 </p>
<p>中断描述符(Interrupt Descriptor Table IDT)是一个系统表，它与每一个中断或异常向量相关联，每一个向量在表中有相应的中断或异常处理程序的入口地址。 内核在允许中断发生前，必须适当地初始化IDT</p>
<p>图4-2</p>
<p>任务门 (task gate)</p>
<p>当中断信号发生时，必须取代当前进程的那个进程的TSS选择符存放在任务门中。</p>
<p>中断门 (interupt gate)</p>
<p>包含段选择符和中断或异常处理程序的段内偏移量。当控制权转移到一个适当的段时，处理器清IF标志，从而关闭将来会发生的可屏蔽中断</p>
<p>陷阱门 (Trap gate)</p>
<p>与中断门相似，只是控制权传递到一个适当的段时处理器不修改IF标志</p>
<p>Linux利用中断门处理中断，利用陷阱门处理异常 </p>
<p>[5]中断和异常的硬件处理 </p>
<p>操作：参考P145-146 </p>
<p>3、中断和异常处理程序的嵌套执行 </p>
<p>每个中断或异常都会引起一个内核控制路径，或者说代表当前进程在内核态执行单独的指令序列。 例如：当I/O设备发出一个中断时，相应的内核控制路径的第一部分指令就是那些把寄存器的内容保存在内核堆栈的指令，而最后一部分指令就是恢复寄存器内容并让CPU返回到用户态的那些指令</p>
<p>内核控制路径可以任意嵌套 ：一个中断处理程序可以被另一个中断处理程序“中断”，因此引起内核控制路径的嵌套执行，如图4-3所示。其结果是，对中断进行处理的内核控制路径，其最后一部分指令并不总能使当前进程返回到用户态：如果嵌套深度大于1，这些指令将执行上次被打断的内核控制路径,此时的CPU依然运行在内核态</p>
<p>允许内核控制路径嵌套执行必须付出代价，那就是中断处理程序必须永不阻塞，换句话说，中断处理程序运行期间不能发生进程切换。 事实上，嵌套的内核控制路径恢复执行时，需要的所有数据都存放在内核态堆栈中，这个栈毫无疑义的属于当前进程。</p>
<p>事实上，异常要么是由编程错误引起，要么是有调试程序触发。然而，“Page Fault（缺页）”异常发生在内核态。</p>
<p>与异常形成对照的是，尽管处理中断的内核控制路径代表当前进程运行，但由I/O设备产生的中断并不引用当前进程的专有数据结构。事实上，当一个给定的中断发生时，要预测那个进程将会运行是不可能的。</p>
<p>一个中断处理程序即可以抢占其他的中断处理程序，也可以抢占异常处理程序。相反，异常处理程序从不抢占中断处理程序。 在内核态能触发的唯一异常就是刚刚描述的缺页异常。但是，中断处理程序从不执行可以导致缺页得操作。</p>
<p>基于以下两个主要原因，Linux交错执行内核控制路径 ：</p>
<p>为了调高可编程中断控制器和设备控制器的吞吐量。 假定设备控制器在一条IRQ线上产生了一个信号，PIC把这个信号转换成一个外部中断，然后PIC和设备控制器保持阻塞，一直到PIC从CPU处接收到一条应答信息 。由于内核控制路径的交错执行，内核即使正在处理前一个中断，也能发送应答。</p>
<p>为了实现一种没有优先级的中断模型 。因为每个中断处理程序都可以被另一个中断处理程序延缓，因此，在硬件设备之间没必要建立预定义优先级。这就简化了内核代码，提高了内核的可移植性</p>
<p>4、初始化中断描述符表（IDT） </p>
<p>[1]中断门、陷阱门、及系统门 </p>
<p>Intel提供了三种类型的中断描述符，Linux使用与Intel稍有不同的细目分类和术语，把它们分类：</p>
<p>中断门 </p>
<p>用户态的进程不能访问的一个Intel中断门。所有的Linux中断处理程序都通过中断门激活，并全部限制在内核态</p>
<p>系统门 </p>
<p>用户态的进程可以访问的一个Intel陷阱门。通过系统门来激活三个Linux异常处理程序，它们的向量是4,5及128，因此，在用户态下，可以发布intobound及int$0x85三条汇编语言指令</p>
<p>系统中断门 </p>
<p>能够被用户态进程访问的Intel中断门。与向量3相关的异常处理程序是由系统中断门激活的，因此，在用户态可以使用汇编语言指令int3</p>
<p>陷阱门 </p>
<p>用户态的进程不能访问的一个Intel陷阱门。大部分Linux异常处理程序都通过陷阱门来激活。 </p>
<p>任务门 </p>
<p>不能被用户态进程访问的Intel任务门。Linux对“Double fault”异常的处理程序是由任务门激活的</p>
<p>[2]IDT的初步初始化 </p>
<p>当计算机还运行在实模式时，IDT被初始化并由BIOS例程使用。然而，一旦Linux接管，IDT就被移动到RAM的另一个区域，并进行第二次初始化，因此Linux没有利用任何BIOS例程 </p>
<p>IDT存放在idt_table表中，有256个表项 </p>
<p>5、异常处理 </p>
<p>CPU产生的大部分异常都由Linux解释为出错条件。当其中一个异常发生时，内核就向引起异常的进程发送一个信号向它通知一个反常条件。 </p>
<p>但是，在两种情况下，Linux利用CPU异常更有效地管理硬件资源：</p>
<p>“Devicenotavaileble”异常与cr0寄存器的TS标志一起用来把新值装入浮点寄存器。</p>
<p>“PageFault”异常，该异常推迟给进程分配新的页框，直到不能再推迟为止。相应的处理程序比较复杂，因为异常可能表示一个错误条件，页可能不表示一个错误条件</p>
<p>异常处理程序有一个标准的结构，由以下三部分组成</p>
<p>1、在内核堆栈中保存大多数寄存器的内容</p>
<p>2、用高级的C函数处理异常</p>
<p>3、通过ret_from_exception()函数从异常处理程序退出</p>
<p>[1]为异常处理程序保存寄存器的值</p>
<p>[2]进入和离开异常处理程序 </p>
<p>6、中断处理 </p>
<p>给当前进程发送一个Unix信号，这种方法并不适合中断</p>
<p>中断处理依赖于中断类型： </p>
<p>I/O中断： 某些I/O设备需要关注；相应的中断处理程序必须查询设备以确定适当的操作过程</p>
<p>时钟中断： 某种时钟产生一个中断；这种中断告诉内核一个固定的时间间隔已经过去。这些中断大部分是作为I/O中断来处理的</p>
<p>处理器间中断 :多处理器系统中一个CPU对另一个CPU发出一个中断</p>
<p>[1]I/O中断处理 </p>
<p>I/O中断处理程序必须做够灵活以给多个设备同时提供服务。例如在PCI总线的体系结构中，几个设备可以共享同一个IRQ线。这就意味着仅仅中断向量不能说明所有问题，同一个向量43即分配给USB端口，也分配给声卡。</p>
<p>中断处理程序的灵活性是以两种不同的方式实现： </p>
<p>IRQ共享： </p>
<p>中断处理程序执行多个中断服务例程(interrupt servicer outine,ISR),每个ISR是一个与单独设备（共享IRQ线）相关的函数。因为不可能预先知道那个特定的设备产生IRQ，因此，每个ISR都被执行，以验证它的设备是否需要关注；如果是，当前设备产生中断时，就执行需要执行的所有操作</p>
<p>IRQ动态分配： </p>
<p>一条IRQ线在可能的最后时刻才与一个设备驱动程序相关联</p>
<p>当一个中断发生时，并不是所有的操作都具有相同的急迫性。事实上，把所有的操作都放进中断处理程序本身并不合适。需要时间长的、非重要的操作应该推后，因为当一个中断处理程序正在运行时，相应的IRQ线上发出的信号就被暂时忽略。更重要的是，中断处理程序是代表进程执行的，它代表的进程必须总处于TASK_RUNNING状态，否则，就可能出现系统僵死情况。因此，中断处理程序不能执行任何阻塞过程，如磁盘I/O操作。因此，Linux把紧随中断要执行的操作分为三类：</p>
<p>紧急的</p>
<p>非紧急的</p>
<p>非紧急可延迟的</p>
<p>所有的I/O中断处理程序都执行四个相同的基本操作 ：</p>
<p>(1)在内核态堆栈中保存IRQ的值和寄存器的内容。</p>
<p>(2)为正在给IRQ线服务的PIC发送一个应答，这将允许PIC进一步发送中断</p>
<p>(3)执行共享这个IRQ的所有设备的中断服务例程(ISR)</p>
<p>(4)跳到ret_from_intr()的地址终止</p>
<p>**图4-4I/O中断处理 </p>
<p>[2]中断向量 </p>
<p>**表4-2，物理IRQ可以分配给32-238范围内的任何向量。不过，Linux使用向量128实现系统调用。</p>
<p>为IRQ可配置设备选择一条线有三种方式：</p>
<p>设置一些硬件跳接器</p>
<p>安装设备时执行一个实用程序</p>
<p>在系统启动时执行一个硬件协议</p>
<p>内核必须在启动中断前发现IRQ号与I/O设备之间的对应，否则，内核在不知道哪个向量对应哪个设备的情况下，怎么能处理来自这个设备的信号呢？</p>
<p>[3]IRQ数据结构 </p>
<p>每个中断向量都有它自己的irq_desc_t描述符 ，参考表4-4</p>
<p>图4-5IRQ描述符</p>
<p>[4]IRQ在多处理器系统上的分发 </p>
<p>Linux遵循对称多处理器模型(SMP);这就意味着，内核从本质上对任何一个CPU都不应该有偏爱。因而，内核视图以轮转的方式把来自硬件设备的IRQ信号在所有CPU之间分发。因此所有CPU服务于I/O中断的执行时间片几乎相同</p>
<p>简而言之，当硬件设备产生了一个中断信号时，多APIC系统就选择其中一个CPU，并把该信号传递给相应的本地APIC，本地APIC又依次中断它的CPU。这个事件不通报给其他所有的CPU</p>
<p>多APIC系统初始化后无需内核费心。遗憾的是在有些情况下，硬件不能以公平的方式在微处理器之间成功地分配中断，在必要的时候，Linux2.6利用叫做krqd的特殊内核线程来纠正对CPU进行的IRQ的自动分配</p>
<p>内核线程为多APIC系统开发了一种优良特性，叫做CPU的IRQ亲和力</p>
<p>[5]多种类型的内核栈 </p>
<p>如果thread_union结构的大小为8KB，那么当前进程的内核栈被用于所有类型的内核控制路径：异常、中断和可延迟的函数。相反，如果thread_union结构的大小为4KB,内核就使用三种类型的内核栈：异常栈、硬中断请求栈、软中断请求栈</p>
<p>[6]为中断处理程序保存寄存器的值 </p>
<p>当CPU接收一个中断时，就开始执行相应的中断处理程序代码，该代码的地址存放在IDT的相应门中，与其他上下文切换一样，需要保存寄存器这一点给内核开发者留下有点复杂的编码工作，因为寄存器的保存和恢复必须用汇编语言代码，但是，在这些操作内部，又期望处理器从C函数调用的返回。</p>
<p>保存寄存器是中断处理程序做的第一件事情</p>
<p>保存寄存器的值以后，栈顶的地址被存放到eax寄存器中，然后中断处理程序调用do_IRQ（）函数。执行do_IRQ()的ret执行时，控制转到ret_from_intr()</p>
<p>[7]do_IRQ()函数 </p>
<p>调用do_IRQ()函数执行与一个中断相关的所有中断服务例程:操作参考p166</p>
<p>[8]__do_IRQ()函数 </p>
<p>接受IRQ号(通过eax寄存器)和指向pt_regs结构的指针(通过edx寄存器，用户态寄存器的值已经存在其中)作为它的参数</p>
<p>[9]挽救丢失的中断 </p>
<p>在多处理器系统上事情可能不会这么顺利。</p>
<p>假定CPU有一条激活的IRQ线。一个硬件设备出现在这条IRQ线程上，且多APIC系统选择我们的CPU处理中断。在CPU应答中断前，这条IRQ线被另一个CPU屏蔽掉；结果，IRQ_DISABLED标志被设置。随后，我们的CPU开始处理挂起的中断；因此，do_IRQ()函数应答这个中断，然后返回，但没有执行中断服务例程，因为它发现IRQ_DISABLED标志被设置了，因此，在IRQ线禁用之前出现的中断丢失了。</p>
<p>为了应付这种局面，内核用来激活IRQ线的enable_irq()函数先检查是否发生了中断丢失，如果是，该函数就强迫硬件让丢失的中断再产生一次</p>
<p>[10]中断服务例程 </p>
<p>一个中断服务例程(ISR)实现一种特定设备的操作。当中断处理程序必须执行ISR时，它就调用hand_IRQ_event()函数。步骤：参考p170</p>
<p>[11]IRQ线的动态分配 </p>
<p>在激活一个准备利用IRQ线的设备之前，其相应的驱动程序调用request_irq()。这个函数建立一个新的irqaction函数，并用参数值初始化它。然后调用setup_irq()函数把这个描述符插入到适合的IRQ链表。如果setup_irq()返回一个出错码，设备驱动程序中止操作，这意味着IRQ线已有另一个设备所使用，而这个设备不允许中断共享。当设备操作结束时，驱动程序调用free_irq()函数从IRQ链表中删除这个描述符，并释放相应的内存区。</p>
<p>request_irq()</p>
<p>free_irq()</p>
<p>[12]处理器间中断处理 </p>
<p>处理器间中断允许一个CPU向系统中的其他CPU发送中断信号。</p>
<p>Linux定义了三种处理器间中断：</p>
<p>CALL_FUNCTION_VECTOR:发送所有的CPU(不包含发送者)，强制这些CPU运行发送者传递过来的函数。相应的中断处理程序叫做call_function_interrupe()</p>
<p>RESCHEDULE_VECTOR:当一个CPU接收这种类型的中断时，相应的处理程序限定自己来应答中断。</p>
<p>INVALIDATE_TLB_VECTOR:发往所有的CPU(不包含发送者)，强制它们的转换后援缓冲器(TLB)变为无效</p>
<p>处理器间中断处理程序的汇编语言代码是由BUILD_INTERRUPTE宏产生的</p>
<p>7、软中断及tasklet </p>
<p>在由内核执行的几个任务之间有些不是紧急的：在必要情况下它们可以延迟一段时间。把可延迟中断从中断处理程序中抽出来有助于使内核保持较短的响应时间。这对于那些期望它们的中断能在几毫秒内得到处理的“急迫”应用来说是非常重要的 </p>
<p>软中断和tasklet有密切的关系，tasklet是在软中断之上实现。 事实上，出现在内核代码中的术语“软中断(softirq)”常常表示可延迟函数的所有种类。另外一种被广泛使用的术语是“中断上下文”：表示内核当前正在执行一个中断处理程序或一个可延迟的函数。</p>
<p>软中断的分配是静态的（即在编译时定义），而tasklet的分配和初始化可以在运行时进行 （例如：安装一个内核模块时）。</p>
<p>软中断（即便是同一种类型的软中断)可以并发地运行在多个CPU上。 因此，软中断是可重入函数 而且必须明确地使用自旋保护其数据结构。tasklet不必担心这些问题，因为内核对tasklet的执行进行了更加严格的控制。相同类型的tasklet总是被串行地执行， 换句话说就是：不能在两个CPU上同时运行相同类型的taklet .但是，类型不同的tasklet可以在几个CPU上并发执行。tasklet的串行化使tasklet函数不必是可重入的 ，因此简化了设备驱动程序开发者的工作。</p>
<p>（重入即表示重复进入，它意味着这个函数可以被中断）</p>
<p>可延迟函数上可以执行四种操作：</p>
<p>初始化 ：</p>
<p>定义一个新的可延迟函数；这个操作通常在内核自身初始化或加载模块时进行。</p>
<p>激活 ：</p>
<p>标记一个可延迟函数为“挂起”（在可延迟函数的下一轮调度中执行）。激活可以在任何时候进行（即使正在处理中断）</p>
<p>屏蔽 ：</p>
<p>有选择地屏蔽一个可延迟函数，这样，即使它被激活，内核也不执行它。</p>
<p>执行 ：</p>
<p>执行一个挂起的可延迟函数和同类型的其他所有挂起的可延迟函数；执行是在特定的时间进行的。</p>
<p>激活和执行不知何故总是捆绑在一起：由给定CPU激活的一个可延迟函数必须在同一个CPU上执行</p>
<p>软中断： </p>
<p>Linux2.6使用有限个软中断。在很多场合，tasklet是足够用的，且更容易编写，因为tasklet不必是可重入的。</p>
<p>目前只定义了六种软中断 ：表4-9**</p>
<p>一个软中断的下标决定了它的优先级：低下标意味着高优先级，因为软中断函数将从下标0开始执行</p>
<p>[1]软中断所使用的数据结构 </p>
<p>表示软中断的主要数据结构是softirq_veq数组，改数组包含类型为softirq_action 的32个元素。一个软中断的优先级是相应的softeirq_aciton元素的数组内的下标</p>
<p>softirq_action数据结构包含两个字段：指向软中断函数的一个action指针和指向软中断函数需要的通用数据结构的data指针</p>
<p>另外一个关键的字段是32位的preempt_count字段，用它来跟踪内核抢占和内核控制路径的嵌套，该字段存放在每个进程描述符的thread_info字段中</p>
<p>[2]处理软中断 </p>
<p>open_softirq()函数 处理软中断的初始化。它使用三个参数：软中断下标、指向要执行的软中断函数的指针及指向可能由软中断函数使用的数据结构的指针。</p>
<p>raise_softirq()函数 用来激活软件中断，操作：参考p177</p>
<p>[3]do_softirq()函数 </p>
<p>如果在这样的一个检查点(local_softirq_pending()不为0)检测到挂起的软中断，内核就调用do_softirq()来处理它们。操作：参考p178</p>
<p>[4]__do_softirq() </p>
<p><strong>do_softirq()函数读取本地CPU的软中断掩码并执行与每个设置位相关的可延迟函数。由于正在执行一个软中断函数时可能出现新挂起的软中断，所以为了保证可延迟函数的低延迟性，</strong>do_softirq()一直运行到执行完所有挂起的软中断，但是，这种机制可能迫使<strong>do_softirq()运行很长一段时间，因而大大延迟用户态进程的执行。因此，</strong>do_softirq()只做固定次数的循环，然后就返回。如果还有其余挂起的软中断，内核线程ksoftirqd将会在预期的时间内处理它们。</p>
<p>[5]ksoftirqd内核线程 </p>
<p>在最近的内核版中，每个CPU都有自己的ksoftirqd/n内核线程。每个ksoftirqd/n内核线程都运行ksoftirqd()函数·</p>
<p>tasklet: </p>
<p>tasklet是I/O驱动程序中实现可延迟函数的首选方法 。tasklet建立在两个叫做HI_SOFTIRQ 和TASKLET_SOFTIRQ 的软中断之上。几个tasklet可以与同一个软中断相关联，每个tasklet执行自己的函数。两个软中断之间没有真正的区别 ，只不过do_softirq()先执行HI_SOFTIRQ的tasklet,后执行TASKLET_SOFTIRQ的tasklet</p>
<p>tasklet描述符是一个tasklet_struct类型 的数据结构：表4-11**</p>
<p>两个标志：</p>
<p>TASKLET_STATE_SCHED</p>
<p>该标志被设置时，表示tasklet是挂起的（曾被调度执行）；也意味着tasklet描述符被插入到tasklet_vec和task_hi_vec数组的其中国一个链表中</p>
<p>TASKLET_STATE_RUN</p>
<p>该标志设置时，表示tasklet正在被执行，在单处理器系统上不使用这个标志，因为没有必要检查特定的tasklet是否在运行</p>
<p>让我们假定，你正在写一个设备驱动程序，且想使用tasklet，应该做什么呢？首先，你应该分配一个新的tasklet_struct数据结构，并调用tasklet_init()初始化它；该函数接收的参数为tasklet描述符的地址、tasklet函数的地址和它的可选整型参数。</p>
<p>调用tasklet_disable_nosync()或tasklet_disable()可以选择性地禁止tasklet。这两个函数都增加tasklet描述符的count字段，但是后一个函数只有在tasklet函数已经运行的实例结束后才返回。为了重新激活你的tasklet，调用tasklet_enable()</p>
<p>为了激活tasklet,你应该根据自己tasklet需要的优先级，调用tasklet_schedule() 函数或tasklet_hi_schedule()函数，其中每个都执行下列操作：</p>
<p>(1)检查TASKLET_STATE_SCHED标志；如果设置则返回(tasklet已经被调度)</p>
<p>(2)调用local_irq_save保存IF标志的状态并禁用本地中断</p>
<p>(3)在tasklet_vec[n]或tasklet_hi_vec[n]指向的链表的起始处增加tasklet描述符(n表示本地CPU的逻辑号)</p>
<p>(4)调用raise_softirq_irqoff()激活TASKLET_SOFTIRQ或HI_SOFTIRQ类型的软中断</p>
<p>(5)调用local_irq_restor恢复IF标志的状态</p>
<p>让我们看一下tasklet如何执行，软中断函数一旦被激活，就由do_softirq()函数执行。与HI_SOFTIRQ软中断相关的软中断函数叫做tasklet_hi_action(),而与TASKLET_SOFTIRQ相关的函数叫做tasklet_action().这两个函数非常相似，它们都执行下列操作：</p>
<p>(1)禁用本地中断</p>
<p>(2)获得本地CPU的逻辑号n</p>
<p>(3)把tasklet_vec[n]或tasklet_hi_vec[n]指向的链表的地址存入局部变量list</p>
<p>(4)把tasklet_vec[n]或tasklet_hi_vec[n]的值赋为NULL,因此，已调度的tasklet描述符的链表被清空</p>
<p>(5)打开本地中断</p>
<p>(6)对于list指向的链表中的每个tasklet描述符</p>
<p>注意，除非tasklet函数重新激活自己，否则，tasklet的每次激活至多触发tasklet函数的一次执行</p>
<p>8、工作队列 </p>
<p>允许内核函数（非常像可延迟函数）被激活，而且稍后由一种叫做工作者线程 (workerthread)的特殊内核线程来执行。尽管可延迟函数和工作队列非常相似，但是它们的区别还是很大的。主要区别在于：可延迟函数运行在中断上下文中，而工作队列中的函数运行在进程上下文中。 执行可阻塞函数(例如：需要访问磁盘数据块的函数)的唯一方式是在进程上下文中运行。在中断上下文中不可能发生进程切换。可延迟函数的工作队列中的函数都不能访问进程的用户态地址空间。事实上，可延迟函数被执行时不可能有任何正在运行的进程。另一方面，工作队列中的函数是由内核线程来执行的，因此根本不存在它要访问的用户态地址空间</p>
<p>[1]工作队列的数据结构 </p>
<p>workqueue_struct描述符表4-12 </p>
<p>[2]工作队列函数 </p>
<p>creat_workqueue(“foo”)函数 ，返回新创建工作队列的workqueue_struct描述符的地址</p>
<p>queue_work()把函数插入工作队列 ，步骤：参考p184</p>
<p>每个工作者线程在worker_thead()函数内部不断地执行循环操作，因而，线程在绝大多数时间里处于睡眠状态并等待某些工作被插入队列。工作线程一旦被唤醒就调用run_workqueue()函数，该函数从工作者线程的工作列链表中删除所有work_struct描述符并执行相应的挂起函数。由于工作队列函数可以阻塞，因此，可以让工作者线程睡眠，甚至可以让它迁移到另一个CPU上恢复执行</p>
<p>有些时候，内核必须等待工作队列中的所有挂起函数执行完毕。flush_workqueue()函数接收workqueue_struct描述符的地址，并且在工作队列中的所有挂起函数结束之前使调用进程一直处于阻塞状态</p>
<p>[3]预定义工作队列 </p>
<p>在绝大多数情况下，为了运行一个函数而创建整个工作者线程开销太大了 。因此，内核引入叫做events的预定义工作队列，所有的内核开发者都可以随意使用它。预定义工作队列只是一个包括不同内核层函数和I\O驱动程序的标准工作队列，它的workqueue_struct描述符存放在keventd_wq数组中</p>
<p>9、从中断和异常返回 </p>
<p>尽管终止阶段的主要目的很清楚，即恢复某个程序的执行，但是，在这样做之前，还需要考虑几个问题：</p>
<p>内核控制路径并发执行的数量</p>
<p>挂起进程的切换请求</p>
<p>挂起的信号</p>
<p>单步执行模式</p>
<p>[1]入口点</p>
<p>[2]恢复内核控制路径</p>
<p>[3]检查内核抢占</p>
<p>[4]恢复用户态程序</p>
<p>[5]检查重调度标志</p>
<p>[6]处理挂起信号，虚拟8086模式和单步执行</p>

      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/10/01/深入理解Linux内核-中断和异常/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-文件系统" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/23/深入理解Linux内核-文件系统/">深入理解Linux内核-文件系统</a>
    </h1>
  

        
        <a href="/2012/09/23/深入理解Linux内核-文件系统/" class="archive-article-date">
  	<time datetime="2012-09-23T09:24:40.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-09-23</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由  王宇 原创并发布 ：</p>
<p>第十二章虚拟文件系统 </p>
<p>虚拟文件系统所隐含的思想是把表示很多不同种类文件系统的共同信息放入内核 </p>
<p>1、虚拟文件系统(VFS)的作用 </p>
<p>虚拟文件系统(VirtualFilesystem)也可以称之为虚拟文件系统转换(VirtualFilesystemSwitch,VFS),是一个内核软件层，用来处理与Unix标准文件系统相关的所有系统调用，其健壮性表现在能为各种文件系统提供一个通用的接口。 图：12-1</p>
<p>VFS支持的文件系统可以划分为三种主要类型 ：</p>
<p>(1)磁盘文件系统</p>
<p>(2)网络文件系统</p>
<p>(3)特殊文件系统 </p>
<p>[1]通用文件模型 </p>
<p>VFS所隐含的主要思想在于引入了一个通用的文件模型，这个模型能够表示所有支持的文件系统</p>
<p>**通用文件模型对象类型组成： </p>
<p>(1)超级块对象(superblockobject)</p>
<p>  存放已安装文件系统的有关信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件系统控制块</p>
<p>(2)索引点对象(inodeobject)</p>
<p>  存放关于具体文件的一般信息。对基于磁盘的文件系统，这类对象通常对应于存放在磁盘上的文件控制块。每个索引点对象都有一个索引节点号，这个节点好唯一地标识文件系统中的文件。</p>
<p>(3)文件对象(fileobject)</p>
<p>  存放打开文件与进程之间进行交互的有关信息。这类信息仅当进程访问文件期间存在于内核中。</p>
<p>(4)目录项对象(dentryobject)</p>
<p>  存放目录项（也就是文件的特殊名称）与文件进行链接的有关信息。每个磁盘文件系统都以自己特有的方式将该类信息存在磁盘上。 </p>
<p>  图12-2</p>
<p>  说明进程怎样与文件进行交互。三个不同进程已经打开同一个文件，其中两个进程使用同一个硬链接。在这种情况下，其中的每个进程都是用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引节点对象，该索引节点对象标识超级快对象，以及随后的普通磁盘文件。VFS除了能为所有文件系统的实现提供一个通用接口外，还具有另一个与系统性能相关的重要作用。最近最常使用的目录项对象被放在所谓目录项高速缓存的磁盘高速缓存中，以加速从文件路径名到最后一个路径分量的索引节点的转换过程。</p>
<p>  [2]VFS所处理的系统调用 </p>
<p>  表12-1***</p>
<p>  VFS是应用程序和具体文件系统之间的一层。不过在某些情况下，一个文件操作可能由VFS本身去执行，无需调用低层函数。例如，当某个金城关闭一个打开的文件时，并不需要涉及磁盘上的相应文件，因此VFS只需释放对应的文件对象。类似地，当系统调用lseek()修改一个文件指针，而这个文件指针是打开文件与进程交互所涉及的一个属性时，VFS就只需修改对应的文件对象，而不必访问磁盘上的文件，因此，无需调用具体文件系统的函数。从某种意义上说，可以把VFS看成”通用”文件系统，它在必要时依赖某种具体文件系统。</p>
<p>  2、VFS的数据结构 </p>
<p>  每个VFS对象都存放在一个适当的数据结构中，其中包含对象的属性和指向对象方法表的指针。</p>
<p>  [1]超级块对象: </p>
<p>  super_block数据结构,参考表12-2</p>
<p>  所有超级块对象都以双向循环链表的形式链接在一起。链表中第一个元素用super_blocks变量 来表示，而超级块对象的s_list字段存放指向链表相邻元素的指针。</p>
<p>  s_fs_info字段指向属于具体文件系统的超级快信息，假如超级块对象指的是Ext2文件系统，该字段就指向ext2_sb_info数据结构，该结构包括磁盘分配位掩码和其他与VFS的通用文件模型无关的数据。通常，为了效率起见，由s_fs_info字段所指向的数据被复制到内存。任何基于磁盘的文件系统都需要访问和更改自己的磁盘分配位图，以便分配或释放磁盘块。VFS允许这些文件系统直接对内存超级块的s_fs_info字段进行操作，而无需访问磁盘。</p>
<p>  但是，这种方法带来一个新问题：有可能VFS超级块最终不再与磁盘上相应的超级块同步。因此，有必要引入一个s_dirt标志来表示该超级块是否是脏的–那磁盘上的数据是否必须要更新。缺乏同步还会导致产生我们熟悉的一个问题:当一台机器的电源突然断开而用户来不及正常关闭系统时，就会出现文件系统崩溃。我们将会在第十五章的“把脏页写入磁盘”一节中看到，Linux是通过周期性地将所有“脏”的超级块写回磁盘来减少该问题带来的危害。</p>
<p>  与超级块关联的方法就是所谓的超级块操作：由数据结构：super_operations来描述，参考p463-465的函数列表。 </p>
<p>  [2]索引节点对象 </p>
<p>  文件系统处理文件所需要的所有信息都放在一个名为索引节点的数据结构中，文件名可以随时更改，但是索引节点对文件时唯一的，并且随文件的存在而存在</p>
<p>  inode数据结构：参考表12-3 </p>
<p>  与索引节点对象关联的方法也叫索引节点操作：由inode_operations结构来描述，参考p468-469的函数列表</p>
<p>  [3]文件对象 </p>
<p>  文件对象描述进程怎么与一个打开的文件进行交互。文件对象是在文件被打开时创建的，由一个file结构组成。注意，文件对象在磁盘上没有对应的映像，因此file结构中没有设置”脏”字段来表示文件对象是否已被修改。</p>
<p>  存放在文件对象中的主要信息是文件指针，即文件中当前的位置，下一个操作将在该位置发生。由于几个进程可能同时访问同一文件，因此文件指针必须存放在文件对象而不是索引节点对象中。</p>
<p>  file数据结构：参考表12-4 </p>
<p>  file_operations结构：参考p472-474的函数列表 </p>
<p>  [4]目录项对象 </p>
<p>  VFS把每个目录看作由若干子目录和文件组成的一个普通文件。然而一旦目录项被读入内存，VFS就把它转换成基于dentry结构（参考表12-5） 的一个目录项对象，对于进程查找的路径名中的每个分量，内核都为其创建一个目录项对象，内核为跟目录“/”创建一个目录项对象，为根目录下的tmp项创建一个第二级目录项对象，为/tmp目录下的test项创建一个第三极目录项对象。</p>
<p>  注意，目录项对象在磁盘上并没有对应的映像，因此在pentry结构中不包含指出该对象已被修改的字段。目录项对象存放在名为dentry_cache的slab分配器高速缓存中。因此，目录项对象的创建和删除是通过调用kmem_checha_alloc()和kmem_cahce_free()实现的</p>
<p>  每个目录项对象可以处于以下四种状态之一：</p>
<p>  (1)空闲状态</p>
<p>  (2)未使用状态</p>
<p>  (3)正在使用状态</p>
<p>  (4)负状态</p>
<p>  dentry_operation结构：参考p476的函数列表 </p>
<p>  [5]目录项高速缓存 </p>
<p>  由于从磁盘读入一个目录项并构造相应的目录项对象需要花费大量的时间，所以，在完成对目录项对象的操作后，可能后面还要使用它，因此仍在内存中保留它有重要的意义 </p>
<p>  为了最大限度地提高处理这些目录项对象的效率，Linux使用目录项高速缓存，它有两种类型的数据结构组成：</p>
<p>  (1)一个处理正在使用、未使用或负状态的目录项对象的集合</p>
<p>  (2)一个散列表，从中能够快速获取与给定的文件名和目录名对应的目录项对象。同样，如果访问的对象不在目录项高速缓存中，则散列函数返回一个空值。</p>
<p>  [6]与进程相关的文件 </p>
<p>  每个进程都有它自己当前的工作目录和它自己的根目录。这仅仅是内核用来表示进程与文件系统相互作用所必须维护的数据中的两个例子。类型为fs_stuct的整个数据结构就是用于此目的。参考表12-6p478</p>
<p>  files_struct结构表示进程当前打开的文件。参考表12-7p478-479 </p>
<p>  3、文件系统类型 </p>
<p>  文件系统注册–也就是通常在系统初始化期间并且在使用文件系统类型之前必须执行的基本操作。一旦文件系统被注册，其特定的函数对内核就是可用的，因此文件系统类型可以安装在系统的目录树上</p>
<p>  [1]特殊文件系统 </p>
<p>  当网络和磁盘文件系统能够使用户处理存放在内核之外的信息时，特殊文件系统可以为系统程序员和管理员提供一种容易的方式来操作内核的数据结构并实现操作系统的特殊特征</p>
<p>  特殊文件系统不限于物理块设备。然而，内核给每个安装的特殊文件系统分配一个虚拟的块设备，让其主设备号为0而次设备号具有任意值</p>
<p>  [2]文件系统类型注册 </p>
<p>  VFS必须对代码目前已在内核中的所有文件系统的类型进行跟踪。这就是通过进行文件系统类型注册来实现的</p>
<p>  每个注册的文件系统都用一个类型为file_system_type的对象来表示，参考表12-9</p>
<p>  所有文件系统类型的对象都插入到一个单向链表中</p>
<p>  4、文件系统处理 </p>
<p>  Linux也使用系统的根文件系统(system’srootfilesystem):它由内核在引导阶段直接安装，并拥有系统初始化脚本以及最基本的系统程序。</p>
<pre><code>其他文件系统要么由初始化脚本安装，要么由用户直接安装在已安装文件系的目录上。作为一个目录树，每个文件系统都拥有自己的根目录(rootdirectory)。安装文件系统的这个目录称之为安装点(mountpoint)。已安装文件系统属于安装点目录的一个子文件系统。 

[1]命名空间 </code></pre><p>在传统的Unix系统中，只有一个已安装文件系统树：从系统的根文件系统开始，每个进程通过制定合适的路径名可以访问已安装文件系统中的任何文件。从这个方面考虑，Linux2.6更加的精确：每个进程可拥有自己的已安装文件系统树—叫做进程的命名空间(namespace) </p>
<p>  通常大多数进程共享一个命名空间，即位于系统的根文件系统且被init进程使用的已安装文件系统树 </p>
<p>  单进程安装或卸载一个文件系统时，仅修改它的命名空间。因此，所做的修改对共享统一命名空间的所有进程都是可见的，并且也只对它们可见。进程甚至可通过使用Linux特有的pivot_root()系统调用来改变它的命名空间的根文件系统。</p>
<p>  namespace结构：参考表12-11</p>
<p>  [2]文件系统安装 </p>
<p>  大多数传统的类Unix内核中，每个文件系统只能安装一次。然而，Linux有所不同:同一个文件系统被安装多次是可能的。不管一个文件系统被安装了多少次，都仅有一个超级块对象。</p>
<p>  每个描述符是一个具有vfsmount类型的数据结构：参考表12-12p485</p>
<p>  下列函数处理已安装文件系统描述符：</p>
<p>  alloc_vfsmnt(name):分配和初始化一个已安装文件系统描述符</p>
<pre><code>free_vfsmnt(mnt):释放由mnt指向的已安装文件系统描述符

                 lookup_mnt(mnt,dentry)在散列表中查找一个描述符并返回它的地址 

                 [3]安装普通文件系统 

                 mount()系统调用被用来安装一个普通文件系统；

                 do_mount()函数操作过程：参考p488 

                 [4]分配超级快对象 

                 get_sb_bdev()操作过程：参考P490-p491

                 [5]安装根文件系统 

                 安装根文件系统是系统初始化的关键部分

                 (1)阶段1：安装rootfs文件系统 

                 由init_rootfs()和init_mount_tree()函数完成，这两个函数的操作过程：参考p492-493    

                 (2)阶段2：安装实际根文件系统 

                 prepare_namespace()操作过程：参考p493

                 [6]卸载文件系统    

                 umount()操作过程：参考p494

                 5、路径名查找 

                 VFS如何实现路径名查找，也就是说如何从文件路径名导出相应的索引节点。 

                 执行这一任务的标准过程就是分析路径名并把它拆分成一个文件名序列。除了最后一个文件名以外，所有的文件名都必定是目录

                 如果路径名的第一个字符是“/”,那么这个路径名是绝对路径，因此从current-&gt;fs-&gt;root(进程的根目录)所标识的目录开始搜索。否则，路径名是相对路径，因此从current-&gt;fs-&gt;pwd(进程的当前目录)所标识的开始搜索。 

                 在对初始化目录的索引节点进行处理的过程中，代码要检查与第一个名字匹配的目录项，以获得相应的索引节点。然后，从磁盘读出包含那个索引节点的目录文件，并检查与第二个名字匹配的目录项，以获得相应的索引节点。对于包含在路径中的每个名字，这个过程反复执行。 

                 目录项高速缓存极大地加速了这一过程，因为它把最近最常使用的目录项对象保留在内存中。正如我们以前看到的，每个这样的对象是特定目录中的一个文件名与它相应的索引节点相联系。因此在很多情况下，路径名的分析可以避免从磁盘读取中间目录。 

                 但是，事情并不像看起来那么简单，因为必须考虑如下的UNIX和VFS文件系统的特点：

                 对每个目录的访问权必须进行检查，以验证是否允许进程读取这一目录的内容。

                 文件名可能是任意一个路径名对应的符号链接；在这种情况下，分析必须扩展到那个路径名的所有分量

                 符号链接可能导致循环引用；内核必须考虑这个可能性，并能在出现这种情况时将循环终止

                 文件名可能是一个已安装文件系统的安装点。这种情况必须检测到，这样，查找操作必须延伸到新的文件系统

                 路径名查找应该在发出系统调用的进程的命名空间中完成。由具有不同命名空间的两个进程使用的相同路径名，可能制定了不同的文件。

                 path_lookup()函数步骤：参考：p497 



                 [1]标准路径名查找 

                 link_path_walk()函数步骤：参考p498-502

                 [2]父路径名查找 

                 在很多情况下，查找操作的真正目的并不是路径名的最后一个分量的前一个分量。例如，当文件被创建时，最后一个分量表示还不存在的文件的文件名，而路径名中的其余路径指定新链接必须插入的目录。因此，查找操作应当取回最后分量的前一个分量的目录项对象。        

                 当查找操作必须解析的是包含路径名最后一个分量的目录而不是最后一个分量本身时，使用LOOKUP_PARENT标志

                 [3]符号链接的查找

                 符号链接是一个普通文件，其中存放的是另一个文件的路径名。路径名可以包含符号链接，且必须由内核来解析。

                 当前进程的描述符中的link_count字段用来避免一个符号链接指向自己而导致的无休止的递归，每次递归执行前增加这个字段的值，执行之后减少其值。如果该字段的值达到6，整个循环操作就以错误码结束。因此符号链接嵌套的层数不超过5

                 一旦link_path_walk()函数检索到与路径名分量相关的目录项对象，就检查相应的索引节点是否自定义的follow_link方法。如果是，索引节点就是一个符号链接，在原路径名的查找操作进行之前就必须先对这个符号链接进行解释。 

                 do_follow_link()函数步骤：参考p504 

                 6、VFS系统调用的实现 

                 [1]Open()系统调用 </code></pre><p>open()系统调用的服务例程为sys_open函数，该函数接收的参数为：要打开文件的路径名filename、访问模式的一些标志flags,以及如何该文件被创建所需要的许可权限位掩码mode.如果该系统调用成功，就返回一个文件描述符，也就是指向文件对象的指针数组current-&gt;file-&gt;fd中分配给新文件的索引：否则，返回-1参考表12-8(open()系统调用的标志)</p>
<p>  sys_open()函数的操作：参考：p506-507 </p>
<p>  [2]read()和write()系统调用</p>
<p>  sys_read()和sys_write()步骤：参考：p508-509 </p>
<p>  [3]close()系统调用</p>
<p>  操作：参考p509 </p>
<p>  7、文件加锁 </p>
<p>  当一个文件可以被多个进程访问时，就会出现同步问题。 </p>
<p>  Unix系统提供了一种允许进程对一个文件区进行加锁的机制，以使同时访问可以很容易地被避免。</p>
<p>  POSIX标准规定了基于fcntl()系统调用的文件加锁机制。这样就有可能对文件的任意一部分（甚至一个字节）加锁或对整个文件（包含以后要追加的数据）加锁。因为进程可以选择仅仅对文件的一部分加锁，因此，它也可以在文件的不同部分保持对个锁。</p>
<p>  这种锁并不把不知道加锁的其他进程关在外面。与用于保护代码中临界区的信号类似，可以认为这种锁起“劝告”的作用。因此，POSIX的锁被称为劝告锁(advisorylock)；内核只是提供加减锁以及检测是否加锁的操作，但是不提供锁的控制与协调工作。也就是说，如果应用程序对某个文件进行操作时，没有检测是否加锁或者无视加锁而直接向文件写数据，内核是不会加以阻拦控制的，因此，劝告锁，不能阻止进程对文件的操作。而只能依赖于大家自觉的去检测是否加锁然后约束自己的行为，若是不遵守规则也不会报错。 </p>
<p>  传统的BSD变体通过flock()系统调用来实现劝告锁。这个调用不允许进程对文件的一个区字段进行加锁，而只能对整个文件进行加锁。传统的SystemV变体提供了lockf()库函数，它仅仅是fcntl()的一个接口。</p>
<p>  更重要的是，SystemVRelease3引入了强制加锁(mandatorylocking):内核检查open()、read()和write()系统调用的每次调用都不违背在所访问文件上的强制锁。因此，强制锁甚至在非合作的进程之间也被强制加上</p>
<pre><code>不管进程是使用劝告锁还是强制锁，它们都可以使用共享读锁和独占写锁。在文件的某个区字段上，可以有任意多个进程进行读，但在同一时刻只能有一个进程进行写。此外，当其他进程对同一个文件都拥有自己的读锁时，就不可以获得一个写锁。

[1]Linux文件加锁 

Linux支持所有的文件加锁方式：劝告锁和强制锁，以及fcntl()、flock()和lockf()系统调用 

flock()系统调用不管MS_MANDLOCK安装标志如何设置，只产生劝告锁。这是任何类Unix操作系统所期望的系统调用行为。在Linu中，增加了一种特殊的flock()强制锁，以允许对专有的网络文件系统的实现提供适当的支持。这就是所谓的共享模式强制锁；当这个锁被设置时，其他任何进程都不能打开与锁访问模式冲突的文件。不鼓励本地Unix应用程序中使用这个特征，因为这样加锁的源代码是不可移植的 

在linux中还引入了另一种基于fcntl()的强制锁，叫做租借锁 (lease).当一个进程试图打开由租借锁保护的文件时，它照样被阻塞。然而，拥有锁得进程接收到一个信号。一旦该进程得到通知，它应当首先更新文件，以使文件的内容保持一致，然后释放锁。如果拥有者不在预定的时间间隔内这么做，则租借锁由内核自动删除，且允许阻塞的进程继续执行 

进程可以采用以下两种方式获得或释放一个文件劝告锁：

(1)发出flock()系统调用。 传递给它的两个参数为文件描述符fd和指定锁操作的命令。该锁应用于整个文件。

(2)使用fcntl()系统调用。 传递给它的三个参数为文件描述符fd、指定锁操作的命令以及指向flock结构的指针。flock结构中的几个字段允许进程指定要加锁得文件部分。因此进程可以在同一文件的不同部分保持几个锁。

fcntl()和flock()系统调用可以在同一文件上同时使用，但是通过fcntl()加锁的文件看起来与通过flock()加锁的文件不一样，反之亦然。这样当应用程序使用一种依赖于某个库的锁，而该库同时使用另一种类型的锁时，可以避免发生死锁。

处理强制文件锁要更复杂些。步骤如下：

(1)安装文件系统时强制锁时是必需的，可使用mount命令的-omand选项在mount()系统调用中设置MS_MANDLOCK标志。缺省操作是不使用强制锁。

(2)通过设置文件的set-group位(SGID)和清除group-execute许可权位将它们标记为强制锁得候选者。因此当group-execute位为0时，set-group位页没有任何意义，因此内核将这种合并解释成使用强制锁而不是劝告锁

(3)使用fcntl()系统调用获得或释放一个文件锁。

处理租借锁比处理强制锁要容易得多：调用具有F_SETLEASE或F_GETLEASE命令的系统调用fcntl()就足够了。使用另一个带有F_SETSIG命令的fcntl()系统调用可以改变传送给租借锁进程拥有者的信号类型。    

[2]文件锁得数据结构

file_lock数据结构：参考表12-19

[3]FL_FLOCK锁 

FL_LOCK锁总是与一个文件对象相关联，因此有一个打开该文件的进程（或共享同一个打开文件的子进程）来维护。当一个锁被请求或允许时，内核就把进程保持在同一文件对象上的任何其他锁都替换掉。这只发生在进程想把一个已经拥有的读锁改变为一个写锁，或把一个写锁改变为一个读锁时。 

sys_flock()步骤：参考P513-514

flock_lock_file_wait()函数操作：参考P514 

[4]FL_POSIX锁 

FL_POSIX锁总是与一个进程和一个索引节点相关联。当进程死亡或一个文件描述符被关闭时（即使该进程对同一文件打开了两次或复制了一个文件描述符），这种锁会被自动地释放。此外,FL_POSIX锁绝不会被子进程通过fork()继承

fcntl_setlk()函数的操作：参考p516 

第十六章访问文件</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/09/23/深入理解Linux内核-文件系统/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
    <article id="post-深入理解Linux内核-内存" class="article article-type-post  article-index" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2012/09/13/深入理解Linux内核-内存/">深入理解Linux内核-内存</a>
    </h1>
  

        
        <a href="/2012/09/13/深入理解Linux内核-内存/" class="archive-article-date">
  	<time datetime="2012-09-13T09:24:48.000Z" itemprop="datePublished"><i class="icon-calendar icon"></i>2012-09-13</time>
</a>
        
      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>由  王宇 原创并发布 ：</p>
<p>第二章内存寻址 </p>
<p>1、内存地址 </p>
<p>[1]逻辑地址 </p>
<p>每个逻辑地址都由一个段(segment)和偏移量(offset或displacement)组成，偏移量指明了从段开始的地方到实际地址之间的距离 </p>
<p>[2]线性地址 </p>
<p>是一个32为无符号整数，可以用来表示高达4GB的地址 </p>
<p>[3]物理地址 </p>
<p>用于内存芯片级内存单元寻址。它们与从微处理器的地址引脚发送到内存总线上的电信号相对应。物理地址由32位或36位无符号整数表示</p>
<p>内存控制单元（MMU）通过一种称为分段单元的硬件电路把一个逻辑地址转换成线性地址；接着，第二个称为分页单元的硬件电路把线性地址转换成一个物理地址。 参见图：2-1 p41</p>
<p>2、硬件中的分段 </p>
<p>实模式和保护模式</p>
<p>(1)段选择符和段寄存器 </p>
<p>段选择符是一个16位长的字段，称为选择符（SegmentSeletor）    </p>
<p>为了快速方便地找到段选择符，处理器提供段寄存器，段寄存器的唯一目的是存放段选择符。这些段寄存器称为cs,ss,ds,es,fs和gs</p>
<p>(2)段描述符 </p>
<p>每个段由一个8字节的段描述符表示，它描述了段的特征。段描述符放在全局描述符表（GlobalDescriptorTable,GDT）或局部描述符表(LocalDescriptorTable,LDT)中。参考表2-1 p43</p>
<p>Linux中被广泛采用的类型：</p>
<p>代码段描述符</p>
<p>数据段描述符</p>
<p>任务状态段描述符</p>
<p>(3)快速访问段描述符 </p>
<p>每当一个段选择符被装入段寄存器时，相应的段描述符就由内存装入到对应的非编程CPU寄存器。从那时起，针对哪个段的逻辑地址转换就可以不访问主存中的GDT或LDT，处理器只需直接引用存放段描述符的CPU寄存器即可。仅当段寄存器的内容改变时，才有必要访问GDT或LDT</p>
<p>(4)分段单元*** </p>
<p>参考图2-5，显示一个逻辑地址是怎样转换成相应的线性地址的</p>
<p>3、Linux中的分段 </p>
<p>分段和分页某种程度上有点多余：分段给一个进程分配不同的线性地址空间，分页可以把同一线性地址空间映射到不同的物理空间。Linux更喜欢分页方式</p>
<p>Linux进程都使用一对相同的段来对指令和数据寻址。</p>
<p>四个主要的Linux段</p>
<p>用户代码段：__USER_CS</p>
<p>用户数据段:__USER_DS</p>
<p>内核代码段:__KERNEL_CS</p>
<p>内核数据段:__KERNEL_DS </p>
<p>(1)LinuxGDT</p>
<p>(2)LinuxLDT</p>
<p>4、硬件中的分页*** </p>
<p>分页单元(pagingunit)把线性地址转换成物理地址。为了效率起见，线性地址被分成以固定长度为单位的组，称为页(page).页内部连续的线性地址被映射到连续的物理地址中。分页单元把所有的RAM分成固定长度的页框(pageframe)(有时叫做物理页)。每一个页框包含一个页，也就是说一个页框的长度与一个页的长度一致。页框是主存的一部分，因此也是一个存储区域。区分一页和一个页框是很重要的，前者只是一个数据块，可以存放在任何页框或磁盘中</p>
<p>把线性地址映射到物理地址的数据结构称为页表(pagetable).页表存放在主存中，并在启动分页单元之前必须由内核对页表进行适当的初始化</p>
<p>(1)常规分页： </p>
<p>32位的线性地址被分成3个域：（参考图：2-7）</p>
<p>目录：</p>
<p>页表：</p>
<p>偏移量：</p>
<p>二级模式的目的在于减少每个进程页表所需RAM的数量 </p>
<p>每个活动进程必须有一个分配给它的页目录。没有必要马上为进程的所有页表都分配RAM</p>
<p>(2)扩展分页 </p>
<p>80x86微处理器允许页框大小为4MB,内核可以不用中间页表进行地址转换，从而节省内存</p>
<p>(3)硬件保护方案 </p>
<p>段：读，写，执行；页：读，写</p>
<p>(4)常规分页举例 </p>
<p>(5)物理地址扩展(PAE)分页机制</p>
<p>(6)64位系统中的分页 </p>
<p>64位处理器的硬件分页系统都使用了额外的分页级别</p>
<p>(7)硬件高速缓存 </p>
<p>为了缩小CPU和RAM之间的速度不匹配，引入了硬件高速缓存内存。</p>
<p>硬件高速缓存基于著名的局部性原理：最近最常用的相邻地址在最近的将来又被用到的可能性极大</p>
<p>(8)转换后援缓存器（TLB） </p>
<p>用于加快线性地址的转换</p>
<p>5、Linux中的分页 </p>
<p>Linux采用了一种同时适用于32位和64位系统的普通分页模型；2.6.10采用三级分页的模型，2.6.11采用了四级分页模型。（参考图：2-12**）</p>
<p>页全局目录：</p>
<p>页上级目录：</p>
<p>页中间目录：</p>
<p>页表：</p>
<p>页全局目录包含若干页上级目录的地址，页上级目录又依次包含若干页中间目录的地址，而页中间目录又包含若干页表的地址，每一个页表项指向一个页框。线性地址因此被分成五个部分。</p>
<p>Linux通过使“页上级目录”位和“页中间目录”位全为0，从根本上取消了页上级目录和页中间目录字段。</p>
<p>Linux的进程处理很大程度上依赖于分页，事实上，线性地址到物理地址的自动转换使下面的设计目标变的可行</p>
<p>[1]给每个进程分配一块不同的物理地址空间，这确保了可以有效地防止寻址错误</p>
<p>[2]区别页（即一组数据）和页框（即主存中的物理地址）之不同。这就允许存放在某个页框中的一个页，然后保存到磁盘上，以后重新装入这同一页时又可以被装在不同的页框中。这就是虚拟内存机制的基本要素。</p>
<p>(1)线性地址字段 </p>
<p>(2)页表处理</p>
<p>pte_tpmd_tpud_tpgd_t分别描述页表项，页中间目录项，页上级目录和页全局目录项的格式</p>
<p>(3)物理内存布局 </p>
<p>在初始化阶段，内核必须建立一个物理地址映射来指定那些物理地址范围对内核可用而那些不可用</p>
<p>内核将页框记为保留的有：在不可用的物理地址范围内的页框；含有内核代码和已初始化的数据结构的页框。保留页框中的页决不能被动态分配或交换到磁盘上</p>
<p>一般来说，Linux内核安装在RAM中从物理地址：0x00100000开始的地方，页就是说，从第二(第一个被计算机模型保留)个MB开始。所需页框总数依赖于内核的配置方案</p>
<p>(4)进程页表 </p>
<p>进程的线性地址空间分为两部分：</p>
<p>从0x00000000到0xbfffffff的线性地址，无论进程运行在用户态还是内核态都可以寻址</p>
<p>从0x00000000到0xcfffffff的线性地址，只有内核态的进程才能寻址</p>
<p>(5)内核页表：参考第八章 </p>
<p>(6)临时内核页表</p>
<p>(7)当RAM小于896MB时的最终内核页表</p>
<p>(8)当RAM大小在896MB和4096MB之间时的最终内核页表</p>
<p>(9)当RAM大于4096MB时的最终内核页表</p>
<p>(10)固定映射的线性地址</p>
<p>(11)处理硬件高速缓存和TLB </p>
<p>处理硬件高速缓存</p>
<p>处理TLB</p>
<p>第八章内存管理    </p>
<p>RAM的某些部分永久地分配给内存，并用来存放内核代码以及静态内核数据结构，RAM的其余部分称为动态内存，这不仅是进程所需的宝贵资源，也是内核本身所需的宝贵资源。整个系统的性能取决于如何有效地管理动态内存。即尽可能做到当需要时分配，不需要时释放。</p>
<p>1、页框管理   </p>
<p>(1)页描述符 </p>
<p>内核必须记录每个页框当前的状态。内核还必须能够确定动态内存中的页框是否空闲。页框的状态信息保存在一个类型为page的页描述符中。参考表8-1</p>
<p>(2)非一致内存访问(NUMA) </p>
<p>  我们习惯上认为计算机内存是一种均匀、共享的资源。我们期望不管内存单元处于何处，也不管CPU出于何处，CPU对内存单元的访问都需要相同的时间。可惜，这种假设在某些体系结构上并不总是成立。Linux2.6支持非一致内存访问(Non-UniformMemoryAccess,NUMA)模型。 </p>
<p>  我们只关注80x86体系结构。IBM兼容PC使用一致访问内存(UMA)模型</p>
<p>  (3)内存管理区 </p>
<p>  计算机体系结构有硬件的制约，这限制了页框可以使用的方式。Linux内核必须处理80x86体系结构的两种硬件约束：</p>
<p>  [1]ISA总线的直接内存存取(DMA)处理器有一个严格的限制：它们只能对RAM的前16MB寻址</p>
<p>  [2]在具有大容量RAM的现代32位计算机中，CPU不能直接访问所有的物理内存，因为线性地址空间太小</p>
<p>  为了应对这两种限制，划分3个管理区：</p>
<p>  ZONE_DMA:低于16MB的内存页框</p>
<p>  ZONE_NORMAL:高于16MB且低于896MB的内存页框</p>
<p>  ZONE_HIGHMEM:高于等于896MB的内存页框 </p>
<p>  每个内存管理区都有自己的描述符：参考表8-4</p>
<p>  (4)保留的页框池 </p>
<p>  内核为原子内存分配请求保留了一个页框池，只有在内存不足时才使用</p>
<p>  (5)分区页框分配器 </p>
<p>  被称作分区页框分配器(zonedpageframeallocator)的内核子系统，处理对连续页框组的内存分配请求</p>
<p>  伙伴系统</p>
<p>  图：8-2</p>
<p>  (6)请求和释放页框 </p>
<p>  6个函数和宏请求页框：</p>
<p>  alloc_pages(gfp_mask,order);</p>
<p>  alloc_page(gfp_mask);</p>
<p>  __get_free_pages(gfp_mask,order);</p>
<p>  __get_free_page(gfp_mask);</p>
<p>  get_zeroed_page(gfp_mask);</p>
<p>  <strong>get_dma_pages(gft_mask|</strong>GFP_DMA,order);</p>
<p>  4个函数和宏请求页框：</p>
<p>  __free_pages(page,order);</p>
<p>  free_pages(addr,order);</p>
<p>  __free_page(page);</p>
<p>  free_page(addr); </p>
<p>  (7)高端内存页框的内核映射 </p>
<p>  896MB边界以上的页框并不映射在内核线性地址空间，因此，内核不能直接访问它们。这就意味着，返回所分配页框线性地址的页分配器函数不适合于高端内存，即不适合用于ZONE_HIGHMEM内存管理区内的页框</p>
<p>  64位硬件平台不存在这个问题，因为可使用的线性地址空间远大于能安装的RAM大小，简言之，这些体系结构的ZONE_HIGHMEM管理区总是空的。</p>
<p>  内核采用三种不同的机制将页框映射到高端内存；分别叫做：永久内核映射、临时内核映射及非连续内存分配。</p>
<p>  [1]永久内核映射</p>
<p>  永久内核映射允许内核建立高端页框到内核地址空间的长期映射。它们使用主内核页表中一个专门的页表，其地址存放在pkmap_page_table变量中。</p>
<p>  建立永久内核映射可能阻塞当前进程；永久内核映射不能用于中断处理程序和可延迟函数。</p>
<p>  [2]临时内核映射</p>
<p>  建立临时内核映射可以用在中断处理程序和可延迟函数的内部，因此它们从不阻塞当前进程。；缺点：是只有很少的临时内核映射可以同时建立起来</p>
<p>  (8)伙伴系统算法 </p>
<p>  内存应该为分配一组连续的页框而建立一种健壮、高效的分配策略</p>
<p>  开发一种适当的技术来记录现存的空闲连续页框块得情况，以尽量避免为满足对小块的请求而分割大的空闲块</p>
<p>  Linux采用著名的伙伴系统算法来解决外碎片问题。把所有的空闲页框分组为11个块链表，每个块链表分别包含为1,2,4,8,16,32,64,128,256,512和1024个连续的页框。对1024个页框的最大请求对应着4MB大小的连续RAM块。每个块得第一页框的物理地址是该块大小的整数倍。 </p>
<p>  假设要请求一个256个页框的块。算法现在256个页框的链表中检查是否有一个空闲块。如果没有这样的块，算法会查找下一个更大的页框，页就是，在512个页框的链表中找一个空闲块。如果存在这样的块，内核就把256的页框分成两份，一半用作满足请求，另一半插入到256个页框的链表中。如果在512个页框的块链表中页没有找到空闲块，就继续找更大的块–1024个页框的块。如果这样的块存在，内核把1024个页框块的256个页框用作请求，然后从剩余的768个页框中拿512个插入到512个页框链表中，再把最后的256个插入到256个页框的链表中。如果1024个页框的链表还是空的，算法就放弃并发出错信号。以上过程的逆过程就是页框块的释放过程，也是该算法名字的由来。 </p>
<p>  (9)数据结构 </p>
<p>  (10)分配块 </p>
<p>__rmqueue()</p>
<p>  (11)释放块 </p>
<p>__free_pages_bulk()</p>
<p>  (12)每CPU页框高速缓存 </p>
<p>  内核经常请求和释放单个页框。为了提升系统性能，每个内存管理区定义了一个“每CPU”页框高速缓存。所有“每CPU”高速缓存包含一些预先分配的页框，它们被用于满足本地CPU发出的单一内存请求</p>
<p>  每个CPU提供了两个高速缓存：热高速缓存；冷高速缓存</p>
<p>  如果内核或用户态进程在刚分配到页框后就立即向页框写，那么从热高速缓存中获得页框就对系统性能有利；反过来，如果页框将要被DMA操作填充，那么从冷高速缓存中获得页框是方便的</p>
<p>  (13)通过每CPU页框高速缓存分配页框 </p>
<p>  buffered_rmqueue()函数在指定的内存管理区中分配页框</p>
<p>  (14)释放页框到每CPU页框高速缓存</p>
<p>  free_hot_page()和free_cold_page()函数    </p>
<p>  (15)管理区分配器</p>
<p>  (16)释放一组页框</p>
<p>  2、内存区管理 </p>
<p>  内碎片的产生主要是由于请求内存的大小与分配给它的大小不匹配而造成。一种典型的解决方法就是提供按几何分布的内存大小，换句话说，内存区大小取决于2的幂而不取决于所存放的数据大小。这样，不管请求内存的大小是多少，我们都可保证内碎片小于50%。为此内核建立了13个按几何分布的空闲内存区链表，它们的大小从32到131072字节。</p>
<p>  (1)slab分配器 </p>
<p>  算法基于下列前提：</p>
<p>  [1]所存放数据的类型可以影响内存区得分配方式。</p>
<p>  slab分配器概念扩充了这种思想，并把内存区看作对象(object)，这些对象由一组数据结构和几个叫做构造或析构的函数组成。前者初始化内存区，后者回收内存区</p>
<p>  为了避免重复初始化对象，slab分配器并不丢弃已分配的对象，而是释放但把它们保存在内存中。当以后又要请求新的对象时，就可以从内存获取而不用重新初始化。</p>
<p>  [2]内核函数倾向于反复请求同一类型的内存区；slab分配器把那些页框保存在高速缓存中并很快地重新使用它们。    </p>
<p>  [3]在引入的对象大小不是几何分布的情况下，也就是说，数据结构的起始地址不是物理地址值的2的幂次方，事情反倒好办。这可以借助处理器硬件高速缓存而导致较好的性能。</p>
<p>  [4]硬件高速缓存的高性能又是尽可能地限制对伙伴系统分配器调用的另一个理由，因为对伙伴系统函数的每次调用都“弄脏”硬件高速缓存，所以增加了对内存的平均访问时间。</p>
<p>  slab分配器把对象分组放进高速缓存，每个高速缓存都是同种类型对象的一种“储备”    </p>
<p>  包含高速缓存的主存区被划分为多个slab，每个slab由一个或多个连续的页框组成，这些页框中既包含已分配的对象，页包含空闲的对象。 参考图：8-3</p>
<p>  (2)高速缓存描述符 </p>
<p>  每个高速缓存描述符由kmem_cache_t类型的数据结构 来描述的</p>
<p>  (3)slab描述符 </p>
<p>  slab描述符，参考：表8-10</p>
<p>  (4)普通和专用高速缓存</p>
<p>  高速缓存被分为两种类型：普通和专用。普通高速缓存只由slab分配器用于自己的目的，而专用高速缓存由内核的其余部分使用</p>
<p>  在系统初始化期间调用kmem_cache_init()和kmem_cache_sizes_init()来建立普通高速缓存。；专用高速缓存是由kmem_cache_create()函数创建的 </p>
<p>  (5)slab分配器与分区页框分配器的接口 </p>
<p>  当slab分配器创建新的slab时，它依靠分区页框分配器来获得一组连续的空闲页框。</p>
<p>  (6)给高速缓存分配slab </p>
<p>  一个新创建的高速缓存没有包含任何slab,因此也没有空闲的对象：当以下两个条件都为真时，才给高速缓存分配slab:</p>
<p>  已发出一个分配新对象的请求</p>
<p>  高速缓存不包含任何空闲对象</p>
<p>  (7)从高速缓存中释放slab </p>
<p>  在两种条件下才能撤销slab:</p>
<p>  slab高速缓存中有太多的空闲对象。</p>
<p>  被周期性调用的定时器函数确定是否有完全未使用的slab能被释放</p>
<p>  调用：slab_destory()函数撤销一个slab    </p>
<p>  (8)对象描述符 </p>
<p>  每个对象都有类型为kmem_bufctl_t的一个描述符，对象描述符存放在一个数组中，位于相应的slab描述符之后。</p>
<p>  (9)对齐内存中的对象 </p>
<p>  slab分配器所管理的对象可以在内存中进行对齐，也就是说，存放它们的内存单元的起始物理地址是一个给定常量的倍数，通常是2的倍数。这个常量就叫对齐因子</p>
<p>  slab分配器所允许的最大对齐因子是4096，即页框大小。这就意味着通过访问对象的物理地址或线性地址就可以对齐对象 </p>
<p>  (10)slab着色</p>
<p>  在不同的slab内具有相同偏移量的对象最终很可能映射在同一高速缓存行中。高速缓存的硬件可能因此而花费内存周期在同一高速缓存行与RAM内存单元之间来来往往传送两个对象，而其他的高速缓存行并未充分使用。slab分配器通过一种叫做颜色的不同随机数分配给slab</p>
<p>  (11)空闲slab对象的本地高速缓存 </p>
<p>  类似“每CPU页框高速缓存”</p>
<p>  (12)分配slab对象 </p>
<p>  通过调用kmem_cache_alloc() 函数可以获得新对象。</p>
<p>  (13)释放slab对象</p>
<p>  kmem_cache_free() 函数释放一个曾经由slab分配器分配给某个内核函数的对象</p>
<p>  (14)通用对象 </p>
<p>  正如“伙伴系统算法”一节中所描述的那样，如果对存储区的请求不频繁，就用一组普通高速缓存来处理，普通高速缓存中的对象具有几何分布的大小，范围为32-131072字节。调用kmalloc()函数就可以得到这种类型的对象。</p>
<p>  (15)内存池 </p>
<p>  内存池是Linux2.6的一个新特性。基本上讲，一个内存池允许一个内核成分，如块设备子系统，仅在内存不足的紧急情况下分配一些动态内存来使用。</p>
<p>  实际上这些页框只能用于满足中断处理程序或内部临界区发出的原子内存分配请求。而内存池是动态内存的设备，只能被特定的内核成分使用。</p>
<p>  创建一个内存池就像手头存放一些灌装食物作为储备，当没有新鲜食物时就使用开罐器。</p>
<p>  一个内存池常常叠加在slab分配器之上–也就是说，它被用来保存slab对象的储备</p>
<p>  3、非连续内存区管理 </p>
<p>  把内存区映射到一组连续的页框是最好的选择，这样会充分利用高速缓存并获得较低的平均访问时间。不过，如果对内存区的请求不是很频繁，那么通过连续的线性地址来访问非连续的页框这样一种分配模式就会很有意义。这种模式的主要优点是避免了外碎片，而缺点是必须打乱内核页表。显然非连续内存区得大小必须是4096的倍数。</p>
<p>  Linux在几个方面使用非连续内存区，例如：为活动的交换区分配数据结构，为模块分配空间，或者给某个I/O驱动程序分配缓冲区。此外非连续内存区还提供了另一种使用高端内存页框的方法</p>
<p>  (1)非连续内存区的线性地址 </p>
<p>  图8-7:从PAGE_OFFSET开始的线性地址区间</p>
<p>  (2)非连续内存区的描述符</p>
<p>  每个非连续内存区都对应着一个类型为vm_struct的描述符 </p>
<p>  表8-13：</p>
<p>  (3)分配非连续内存区</p>
<p>  vmalloc() 函数给内核分配一个非连续内存区</p>
<p>  (4)释放非连续内存区</p>
<p>  vfree()函 数释放vmalloc()或vmalloc_32()创建的非连续内存区，而vunmap()函数释放vmap()创建的内存区</p>
<p>  第九章进程地址空间 </p>
<p>  内核中的函数以相当直接了当的方式获得动态内存，这是通过调用以下几个函数中的一个达到的：__get_free_pages()或alloc_pages()从分区框分配其中获得页框，kmem_cache_alloc()或kmalloc（）使用slab分配器为专用或通用对象分配块，而vmalloc（）或vmalloc_32()获得一块非连续的内存区。如果所请求的内存区得以满足，这些函数都返回一个页描述符地址或线性地址，即所分配动态内存区的起始地址。 </p>
<p>  使用这些简单方法是基于以下两个原因 ：</p>
<p>  内核是操作系统中优先级最高的成分</p>
<p>  内核信任自己 </p>
<p>  当给用户态进程分配内存时，情况完全不同：</p>
<p>  进程对动态内存的请求被认为是不紧迫的。例如，当进程的可执行文件被装入时，进程并不一定立即对所有的代码页进行访问。类似地，当进程调用malloc()以获得请求的动态内存时，也并不意味着进程很快就会访问所有所获得的内存。因此一般来说，内核总是尽量推迟给用户态进程分配动态内存    </p>
<p>  由于用户进程是不可信任的。因此，内核必须能够随时准备捕捉用户进程引起的所有寻址错误。</p>
<p>  内核使用一种新的资源成功实现了对进程动态内存的推迟分配。当用户态进程请求动态内存时，并没有获得请求的页框，而仅仅获得对一个新的线性地址区间的使用权，而这一线性地址区间就成为进程地址空间的一部分。这一区间叫做“线性区”</p>
<p>  1、进程的地址空间 </p>
<p>  进程的地址空间由允许进程使用的全部线性地址组成。每个进程所看到的线性地址集合是不同的，一个进程所使用的地址与另外一个进程所使用的地址之间没有什么关系。内核可以通过增加或删除某些线性地址区间来动态地修改进程的地址空间。</p>
<p>  起始地址和线性区的长度都必须是4096的倍数</p>
<p>  进程获得新线性区得一些典型情况：</p>
<p>  [1]当用户在控制台输入一条命令时，shell进程创建一个新的进程去执行这个命令。结果是，一个全新的地址空间分配给了新进程</p>
<p>  [2]正在运行的进程有可能决定装入一个完全不同的程序。在这种情况下，进程标识符仍然保持不变，可是再装入这个程序以前所使用的线性区却被释放，并有一组新的线性区被分配给这个进程。</p>
<p>  [3]正在运行的进程可能对一个文件执行“内存映射”，在这种情况下，内核给这个进程分配一个新的线性区来映射这个文件</p>
<p>  [4]进程可能持续向它的用户态堆栈增加数据，直到映射这个堆栈的线性区用完为止。在这种情况下，内核也许会决定扩展这个线性区的大小。</p>
<p>  [5]进程可能创建一个IPC共享线性区来与其他合作进程共享数据。在这种情况下，内核给这个进程分配一个新的线性区以实现这个方案</p>
<p>  [6]进程可能通过调用类似malloc()这样的函数扩展自己的动态区。结果是，内核可能决定扩展给这个堆所分配的线性区。</p>
<p>  2、内存描述符 </p>
<p>  与进程地址空间有关的全部信息都包含在一个叫做内存描述符：mm_struct 参考：表9-2：        </p>
<p>  3、线性区 </p>
<p>  Linux通过类型为vm_aree_struct的对象实现线性区 。</p>
<p>  每个线性区描述符表示一个线性地址区</p>
<p>  当一个新的线性地址区间加入到进程的地址空间时，内核检查一个已经存在的线性区是否可以扩大。如果不能，就创建一个新的线性区。类似地，如果从进程的地址空间删除一个线性地址区间，内核就要调整受影响的线性区大小。这些情况下，调整大小迫使一个线性区被分成两个更小的部分 。参考图9-1</p>
<p>  （1）线性区数据结构 </p>
<p>  参考图：9-2与进程地址空间相关的描述符</p>
<p>  内核频繁执行的一个操作就是查找包含指定线性地址的线性区。由于链表是经过排序的，因此，只要在指定线性地址之后找到一个线性区，搜索就可以结束。</p>
<p>  为了提高效率，Linux2.6把内存描述符存放在叫做红-黑树 的数据结构中：</p>
<p>  红-黑树必须满足下列4条规则：</p>
<p>  [1]每个节点必须或为黑或为红</p>
<p>  [2]树的根必须为黑</p>
<p>  [3]红节点的孩子必须为黑</p>
<p>  [4]从一个节点到后代叶子节点的每个路径都包含相同数量的黑节点。当统计黑节点个数时，空指针也算作黑节点 </p>
<p>  这4条规则确保具有n个内部节点的任何红-黑树其高度最多为2*log(n+1),在红-黑树中搜索一个元素因此而变的非常高效，因为其操作的执行时间与树大小的对数成线性比例。换句话说，双倍的线性区个数只多增加一次循环    </p>
<p>  在红-黑树中插入和删除一个元素也是高效的，因为算法能很快地遍历树以确定插入元素的位置或删除元素的位置。</p>
<p>  为了存放进程的线性区,Linux既使用了链表，也使用了红-黑树</p>
<p>  （2）线性区访问权限</p>
<p>  页与线性区之间的关系：每个线性区都由一组号码连续的页所构成.</p>
<p>  页相关的标志：</p>
<p>  在每个页表项中存放的几个标志，如：Read/Write、Present或User、Supervisor</p>
<p>  存放在每个页描述符flags字段中的一组标志</p>
<p>  第一种标志由80x86硬件用来检查能否执行所请求的寻址类型；第二种标志由Linux用于许多不同的目的。第三种标志，即与线性区得页相关的那些标志，存放在vm_area_struct描述符的vm_flags字段中。参考表：9-5线性区标志    </p>
<p>  线性区描述符所包含的页访问权限可以任意组合</p>
<p>  （3）线性区的处理 </p>
<p>[1]查找给定地址的最邻近区：find_vma()</p>
<p>[2]查找一个与给定的地址区间相重叠的线性区：find_vma_intersection()</p>
<p>[3]查找一个空闲的地址区间：get_unmapped_area()</p>
<p>[4]向内存描述符链表中插入一个线性区：insert_vm_struct() </p>
<p>  （4）分配线性地址区间:do_mmap()</p>
<p>  （5）释放线性地址区间: </p>
<p>do_munmap()</p>
<p>split_vma()</p>
<p>unmap_region()</p>
<p>  4、缺页异常处理程序 </p>
<p>  Linux缺页异常处理程序必须区分一下两种情况：由编程错误所引起的异常，及由引用属于进程地址空间但还尚未分配物理页框的页所引起的异常。参考图9-4;图9-5</p>
<p>  (1)处理地址空间以外的错误地址</p>
<p>  (2)处理地址空间内的错误地址</p>
<p>  (3)请求调页</p>
<p>  “请求调页”指的是一种动态内存分配技术，它把页框的分配推迟到不能在推迟为止，也就是说，一直推迟到进程要访问的页不在RAM中时为止，由此引起一个缺页异常 </p>
<p>  请求调页技术背后的动机是：进程开始运行的时候并不访问其地址空间中的全部地址；事实上，有一部分地址也许永远不被进程使用。此外，程序的局部性原理（参见第二章中的“硬件高速缓存”）保证了在程序执行的每个阶段，真正引用的进程页只有一小部分，因此临时用不着的页所在的页框可以由其他程序来使用。请求调页技术更好地利用空闲内存，从总体上能使系统有更大的吞吐量</p>
<p>  为这一切优点付出的代价是系统额外的开销：由请求调页所引发的每个“缺页”异常必须由内核处理，这将浪费CPU的时钟周期。幸运的是，局部性原理保证了一旦进程开始在一组页上运行，在接下来相当长的一段时间内它会一直停留在这些页上而不去访问其他的页，这样我们就可以认为“缺页”异常是一种稀有事件。</p>
<p>  (4)写时复制 </p>
<p>  内核原样复制父进程的整个地址空间并把复制的那一份分配给子进程。这样做耗时的原因：</p>
<p>  为子进程的页表分配页框</p>
<p>  为子进程的页分配页框</p>
<p>  初始化子进程的页表</p>
<p>  把父进程的页复制到子进程相应的页中</p>
<p>  这种创建地址空间的方法涉及许多内存访问，消耗许多CPU周期，并且完全破坏了高速缓存中的内容。因为许多子进程通过装入一个新的程序开始它们的执行，这样就完全丢弃了所继承的地址空间</p>
<p>  Unix内核采用一种更为有效的方法，称之为写时复制：父进程和子进程共享页框而不是复制页框。然而只要页框被共享，它们就不能被修改。无论父进程还是子进程何时试图写一个共享的页框，就产生一个异常，这时内核就把这个页复制到一个新的页框中并标记为可写。原来的页框仍然是写保护的：当其他进程试图写入时，内核检查写进程是否是这个页框的唯一属主，如果是，就把这个页框标记为对这个进程是可写的。</p>
<p>  (5)处理非连续内存区访问 </p>
<p>  5、创建和删除进程的地址空间 </p>
<p>  (1)创建进程的地址空间 </p>
<p>  当创建一个新的进程时内核调用copy_mm() 函数，这个函数通过建立新进程的所有页表和内存描述符来创建进程的地址空间</p>
<p>  写时复制方法，传统的进程继承父进程的地址空间，只要页是只读的，就依然共享它们。当其中的一个进程试图对某个页进行写时，这个页就被复制一份。一段时间之后，所创建的进程通常获得与父进程不一样的完全属于自己的地址空间</p>
<p>  (2)删除进程的地址空间 </p>
<p>  内核调用exit_mm() 函数释放进程的地址空间</p>
<p>  6、堆的管理 </p>
<p>  每个Unix进程都拥有一个特殊的线性区，这个线性区就是所谓的堆(heap),堆用于满足进程的动态内存请求。</p>
<p>  API：</p>
<p>  malloc(size):请求size个字节的动态内存。如果分配成功，就返回所分配内存单元第一个字节的线性地址</p>
<pre><code>calloc(n,size):请求含有n个大小为size的元素的一个数组，如果分配成功，就把数组元素初始化为0,并返回第一个元素的线性地址

               realloc(ptr,size):改变由前面的malloc()或calloc()分配的内存区字段的大小

                                 free(addr):释放

                                            brk(addr):直接修改堆的大小



                                                      第十五章页高速缓存

                                                      第十七章回收页框 

                                                      1、读写文件

                                                      2、内存映射

                                                      3、直接I/O传递

                                                      4、异步I/O</code></pre>
      

      
    </div>
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<i class="icon-price-tags icon"></i>
		<ul class="article-tag-list">
			 
        		<li class="article-tag-list-item">
        			<a href="javascript:void(0)" class="js-tag article-tag-list-link color1">linux</a>
        		</li>
      		
		</ul>
	</div>

      

      
        <p class="article-more-link">
          <a class="article-more-a" href="/2012/09/13/深入理解Linux内核-内存/">展开全文 >></a>
        </p>
      

      
      <div class="clearfix"></div>
    </div>
  </div>
</article>

<aside class="wrap-side-operation">
    <div class="mod-side-operation">
        
        <div class="jump-container" id="js-jump-container" style="display:none;">
            <a href="javascript:void(0)" class="mod-side-operation__jump-to-top">
                <i class="icon-font icon-back"></i>
            </a>
            <div id="js-jump-plan-container" class="jump-plan-container" style="top: -11px;">
                <i class="icon-font icon-plane jump-plane"></i>
            </div>
        </div>
        
        
    </div>
</aside>




  
  
    <nav id="page-nav">
      <a class="extend prev" rel="prev" href="/page/3/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/5/">Next &raquo;</a>
    </nav>
  


          </div>
        </div>
      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2019 王宇
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		mathjax: false,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		toc_hide_index: true,
		root: "/",
		innerArchive: true,
		showTags: false
	}
</script>

<script>!function(t){function n(e){if(r[e])return r[e].exports;var i=r[e]={exports:{},id:e,loaded:!1};return t[e].call(i.exports,i,i.exports,n),i.loaded=!0,i.exports}var r={};n.m=t,n.c=r,n.p="./",n(0)}([function(t,n,r){r(195),t.exports=r(191)},function(t,n,r){var e=r(3),i=r(52),o=r(27),u=r(28),c=r(53),f="prototype",a=function(t,n,r){var s,l,h,v,p=t&a.F,d=t&a.G,y=t&a.S,g=t&a.P,b=t&a.B,m=d?e:y?e[n]||(e[n]={}):(e[n]||{})[f],x=d?i:i[n]||(i[n]={}),w=x[f]||(x[f]={});d&&(r=n);for(s in r)l=!p&&m&&void 0!==m[s],h=(l?m:r)[s],v=b&&l?c(h,e):g&&"function"==typeof h?c(Function.call,h):h,m&&u(m,s,h,t&a.U),x[s]!=h&&o(x,s,v),g&&w[s]!=h&&(w[s]=h)};e.core=i,a.F=1,a.G=2,a.S=4,a.P=8,a.B=16,a.W=32,a.U=64,a.R=128,t.exports=a},function(t,n,r){var e=r(6);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n){var r=t.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=r)},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n,r){var e=r(126)("wks"),i=r(76),o=r(3).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n,r){var e=r(94),i=r(33);t.exports=function(t){return e(i(t))}},function(t,n,r){t.exports=!r(4)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(2),i=r(167),o=r(50),u=Object.defineProperty;n.f=r(10)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){t.exports=!r(18)(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(14),i=r(22);t.exports=r(12)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(20),i=r(58),o=r(42),u=Object.defineProperty;n.f=r(12)?Object.defineProperty:function(t,n,r){if(e(t),n=o(n,!0),e(r),i)try{return u(t,n,r)}catch(t){}if("get"in r||"set"in r)throw TypeError("Accessors not supported!");return"value"in r&&(t[n]=r.value),t}},function(t,n,r){var e=r(40)("wks"),i=r(23),o=r(5).Symbol,u="function"==typeof o;(t.exports=function(t){return e[t]||(e[t]=u&&o[t]||(u?o:i)("Symbol."+t))}).store=e},function(t,n,r){var e=r(67),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){var e=r(46);t.exports=function(t){return Object(e(t))}},function(t,n){t.exports=function(t){try{return!!t()}catch(t){return!0}}},function(t,n,r){var e=r(63),i=r(34);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(21);t.exports=function(t){if(!e(t))throw TypeError(t+" is not an object!");return t}},function(t,n){t.exports=function(t){return"object"==typeof t?null!==t:"function"==typeof t}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n){var r={}.hasOwnProperty;t.exports=function(t,n){return r.call(t,n)}},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n,r){var e=r(11),i=r(66);t.exports=r(10)?function(t,n,r){return e.f(t,n,i(1,r))}:function(t,n,r){return t[n]=r,t}},function(t,n,r){var e=r(3),i=r(27),o=r(24),u=r(76)("src"),c="toString",f=Function[c],a=(""+f).split(c);r(52).inspectSource=function(t){return f.call(t)},(t.exports=function(t,n,r,c){var f="function"==typeof r;f&&(o(r,"name")||i(r,"name",n)),t[n]!==r&&(f&&(o(r,u)||i(r,u,t[n]?""+t[n]:a.join(String(n)))),t===e?t[n]=r:c?t[n]?t[n]=r:i(t,n,r):(delete t[n],i(t,n,r)))})(Function.prototype,c,function(){return"function"==typeof this&&this[u]||f.call(this)})},function(t,n,r){var e=r(1),i=r(4),o=r(46),u=function(t,n,r,e){var i=String(o(t)),u="<"+n;return""!==r&&(u+=" "+r+'="'+String(e).replace(/"/g,"&quot;")+'"'),u+">"+i+"</"+n+">"};t.exports=function(t,n){var r={};r[t]=n(u),e(e.P+e.F*i(function(){var n=""[t]('"');return n!==n.toLowerCase()||n.split('"').length>3}),"String",r)}},function(t,n,r){var e=r(115),i=r(46);t.exports=function(t){return e(i(t))}},function(t,n,r){var e=r(116),i=r(66),o=r(30),u=r(50),c=r(24),f=r(167),a=Object.getOwnPropertyDescriptor;n.f=r(10)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(24),i=r(17),o=r(145)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n){t.exports={}},function(t,n){t.exports=!0},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(14).f,i=r(8),o=r(15)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(40)("keys"),i=r(23);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(5),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n,r){var e=r(21);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(36),u=r(44),c=r(14).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){n.f=r(15)},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n){t.exports=function(t){if(void 0==t)throw TypeError("Can't call method on  "+t);return t}},function(t,n,r){var e=r(4);t.exports=function(t,n){return!!t&&e(function(){n?t.call(null,function(){},1):t.call(null)})}},function(t,n,r){var e=r(53),i=r(115),o=r(17),u=r(16),c=r(203);t.exports=function(t,n){var r=1==t,f=2==t,a=3==t,s=4==t,l=6==t,h=5==t||l,v=n||c;return function(n,c,p){for(var d,y,g=o(n),b=i(g),m=e(c,p,3),x=u(b.length),w=0,S=r?v(n,x):f?v(n,0):void 0;x>w;w++)if((h||w in b)&&(d=b[w],y=m(d,w,g),t))if(r)S[w]=y;else if(y)switch(t){case 3:return!0;case 5:return d;case 6:return w;case 2:S.push(d)}else if(s)return!1;return l?-1:a||s?s:S}}},function(t,n,r){var e=r(1),i=r(52),o=r(4);t.exports=function(t,n){var r=(i.Object||{})[t]||Object[t],u={};u[t]=n(r),e(e.S+e.F*o(function(){r(1)}),"Object",u)}},function(t,n,r){var e=r(6);t.exports=function(t,n){if(!e(t))return t;var r,i;if(n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;if("function"==typeof(r=t.valueOf)&&!e(i=r.call(t)))return i;if(!n&&"function"==typeof(r=t.toString)&&!e(i=r.call(t)))return i;throw TypeError("Can't convert object to primitive value")}},function(t,n,r){var e=r(5),i=r(25),o=r(91),u=r(13),c="prototype",f=function(t,n,r){var a,s,l,h=t&f.F,v=t&f.G,p=t&f.S,d=t&f.P,y=t&f.B,g=t&f.W,b=v?i:i[n]||(i[n]={}),m=b[c],x=v?e:p?e[n]:(e[n]||{})[c];v&&(r=n);for(a in r)(s=!h&&x&&void 0!==x[a])&&a in b||(l=s?x[a]:r[a],b[a]=v&&"function"!=typeof x[a]?r[a]:y&&s?o(l,e):g&&x[a]==l?function(t){var n=function(n,r,e){if(this instanceof t){switch(arguments.length){case 0:return new t;case 1:return new t(n);case 2:return new t(n,r)}return new t(n,r,e)}return t.apply(this,arguments)};return n[c]=t[c],n}(l):d&&"function"==typeof l?o(Function.call,l):l,d&&((b.virtual||(b.virtual={}))[a]=l,t&f.R&&m&&!m[a]&&u(m,a,l)))};f.F=1,f.G=2,f.S=4,f.P=8,f.B=16,f.W=32,f.U=64,f.R=128,t.exports=f},function(t,n){var r=t.exports={version:"2.4.0"};"number"==typeof __e&&(__e=r)},function(t,n,r){var e=r(26);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(183),i=r(1),o=r(126)("metadata"),u=o.store||(o.store=new(r(186))),c=function(t,n,r){var i=u.get(t);if(!i){if(!r)return;u.set(t,i=new e)}var o=i.get(n);if(!o){if(!r)return;i.set(n,o=new e)}return o},f=function(t,n,r){var e=c(n,r,!1);return void 0!==e&&e.has(t)},a=function(t,n,r){var e=c(n,r,!1);return void 0===e?void 0:e.get(t)},s=function(t,n,r,e){c(r,e,!0).set(t,n)},l=function(t,n){var r=c(t,n,!1),e=[];return r&&r.forEach(function(t,n){e.push(n)}),e},h=function(t){return void 0===t||"symbol"==typeof t?t:String(t)},v=function(t){i(i.S,"Reflect",t)};t.exports={store:u,map:c,has:f,get:a,set:s,keys:l,key:h,exp:v}},function(t,n,r){"use strict";if(r(10)){var e=r(69),i=r(3),o=r(4),u=r(1),c=r(127),f=r(152),a=r(53),s=r(68),l=r(66),h=r(27),v=r(73),p=r(67),d=r(16),y=r(75),g=r(50),b=r(24),m=r(180),x=r(114),w=r(6),S=r(17),_=r(137),O=r(70),E=r(32),P=r(71).f,j=r(154),F=r(76),M=r(7),A=r(48),N=r(117),T=r(146),I=r(155),k=r(80),L=r(123),R=r(74),C=r(130),D=r(160),U=r(11),W=r(31),G=U.f,B=W.f,V=i.RangeError,z=i.TypeError,q=i.Uint8Array,K="ArrayBuffer",J="Shared"+K,Y="BYTES_PER_ELEMENT",H="prototype",$=Array[H],X=f.ArrayBuffer,Q=f.DataView,Z=A(0),tt=A(2),nt=A(3),rt=A(4),et=A(5),it=A(6),ot=N(!0),ut=N(!1),ct=I.values,ft=I.keys,at=I.entries,st=$.lastIndexOf,lt=$.reduce,ht=$.reduceRight,vt=$.join,pt=$.sort,dt=$.slice,yt=$.toString,gt=$.toLocaleString,bt=M("iterator"),mt=M("toStringTag"),xt=F("typed_constructor"),wt=F("def_constructor"),St=c.CONSTR,_t=c.TYPED,Ot=c.VIEW,Et="Wrong length!",Pt=A(1,function(t,n){return Tt(T(t,t[wt]),n)}),jt=o(function(){return 1===new q(new Uint16Array([1]).buffer)[0]}),Ft=!!q&&!!q[H].set&&o(function(){new q(1).set({})}),Mt=function(t,n){if(void 0===t)throw z(Et);var r=+t,e=d(t);if(n&&!m(r,e))throw V(Et);return e},At=function(t,n){var r=p(t);if(r<0||r%n)throw V("Wrong offset!");return r},Nt=function(t){if(w(t)&&_t in t)return t;throw z(t+" is not a typed array!")},Tt=function(t,n){if(!(w(t)&&xt in t))throw z("It is not a typed array constructor!");return new t(n)},It=function(t,n){return kt(T(t,t[wt]),n)},kt=function(t,n){for(var r=0,e=n.length,i=Tt(t,e);e>r;)i[r]=n[r++];return i},Lt=function(t,n,r){G(t,n,{get:function(){return this._d[r]}})},Rt=function(t){var n,r,e,i,o,u,c=S(t),f=arguments.length,s=f>1?arguments[1]:void 0,l=void 0!==s,h=j(c);if(void 0!=h&&!_(h)){for(u=h.call(c),e=[],n=0;!(o=u.next()).done;n++)e.push(o.value);c=e}for(l&&f>2&&(s=a(s,arguments[2],2)),n=0,r=d(c.length),i=Tt(this,r);r>n;n++)i[n]=l?s(c[n],n):c[n];return i},Ct=function(){for(var t=0,n=arguments.length,r=Tt(this,n);n>t;)r[t]=arguments[t++];return r},Dt=!!q&&o(function(){gt.call(new q(1))}),Ut=function(){return gt.apply(Dt?dt.call(Nt(this)):Nt(this),arguments)},Wt={copyWithin:function(t,n){return D.call(Nt(this),t,n,arguments.length>2?arguments[2]:void 0)},every:function(t){return rt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},fill:function(t){return C.apply(Nt(this),arguments)},filter:function(t){return It(this,tt(Nt(this),t,arguments.length>1?arguments[1]:void 0))},find:function(t){return et(Nt(this),t,arguments.length>1?arguments[1]:void 0)},findIndex:function(t){return it(Nt(this),t,arguments.length>1?arguments[1]:void 0)},forEach:function(t){Z(Nt(this),t,arguments.length>1?arguments[1]:void 0)},indexOf:function(t){return ut(Nt(this),t,arguments.length>1?arguments[1]:void 0)},includes:function(t){return ot(Nt(this),t,arguments.length>1?arguments[1]:void 0)},join:function(t){return vt.apply(Nt(this),arguments)},lastIndexOf:function(t){return st.apply(Nt(this),arguments)},map:function(t){return Pt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},reduce:function(t){return lt.apply(Nt(this),arguments)},reduceRight:function(t){return ht.apply(Nt(this),arguments)},reverse:function(){for(var t,n=this,r=Nt(n).length,e=Math.floor(r/2),i=0;i<e;)t=n[i],n[i++]=n[--r],n[r]=t;return n},some:function(t){return nt(Nt(this),t,arguments.length>1?arguments[1]:void 0)},sort:function(t){return pt.call(Nt(this),t)},subarray:function(t,n){var r=Nt(this),e=r.length,i=y(t,e);return new(T(r,r[wt]))(r.buffer,r.byteOffset+i*r.BYTES_PER_ELEMENT,d((void 0===n?e:y(n,e))-i))}},Gt=function(t,n){return It(this,dt.call(Nt(this),t,n))},Bt=function(t){Nt(this);var n=At(arguments[1],1),r=this.length,e=S(t),i=d(e.length),o=0;if(i+n>r)throw V(Et);for(;o<i;)this[n+o]=e[o++]},Vt={entries:function(){return at.call(Nt(this))},keys:function(){return ft.call(Nt(this))},values:function(){return ct.call(Nt(this))}},zt=function(t,n){return w(t)&&t[_t]&&"symbol"!=typeof n&&n in t&&String(+n)==String(n)},qt=function(t,n){return zt(t,n=g(n,!0))?l(2,t[n]):B(t,n)},Kt=function(t,n,r){return!(zt(t,n=g(n,!0))&&w(r)&&b(r,"value"))||b(r,"get")||b(r,"set")||r.configurable||b(r,"writable")&&!r.writable||b(r,"enumerable")&&!r.enumerable?G(t,n,r):(t[n]=r.value,t)};St||(W.f=qt,U.f=Kt),u(u.S+u.F*!St,"Object",{getOwnPropertyDescriptor:qt,defineProperty:Kt}),o(function(){yt.call({})})&&(yt=gt=function(){return vt.call(this)});var Jt=v({},Wt);v(Jt,Vt),h(Jt,bt,Vt.values),v(Jt,{slice:Gt,set:Bt,constructor:function(){},toString:yt,toLocaleString:Ut}),Lt(Jt,"buffer","b"),Lt(Jt,"byteOffset","o"),Lt(Jt,"byteLength","l"),Lt(Jt,"length","e"),G(Jt,mt,{get:function(){return this[_t]}}),t.exports=function(t,n,r,f){f=!!f;var a=t+(f?"Clamped":"")+"Array",l="Uint8Array"!=a,v="get"+t,p="set"+t,y=i[a],g=y||{},b=y&&E(y),m=!y||!c.ABV,S={},_=y&&y[H],j=function(t,r){var e=t._d;return e.v[v](r*n+e.o,jt)},F=function(t,r,e){var i=t._d;f&&(e=(e=Math.round(e))<0?0:e>255?255:255&e),i.v[p](r*n+i.o,e,jt)},M=function(t,n){G(t,n,{get:function(){return j(this,n)},set:function(t){return F(this,n,t)},enumerable:!0})};m?(y=r(function(t,r,e,i){s(t,y,a,"_d");var o,u,c,f,l=0,v=0;if(w(r)){if(!(r instanceof X||(f=x(r))==K||f==J))return _t in r?kt(y,r):Rt.call(y,r);o=r,v=At(e,n);var p=r.byteLength;if(void 0===i){if(p%n)throw V(Et);if((u=p-v)<0)throw V(Et)}else if((u=d(i)*n)+v>p)throw V(Et);c=u/n}else c=Mt(r,!0),u=c*n,o=new X(u);for(h(t,"_d",{b:o,o:v,l:u,e:c,v:new Q(o)});l<c;)M(t,l++)}),_=y[H]=O(Jt),h(_,"constructor",y)):L(function(t){new y(null),new y(t)},!0)||(y=r(function(t,r,e,i){s(t,y,a);var o;return w(r)?r instanceof X||(o=x(r))==K||o==J?void 0!==i?new g(r,At(e,n),i):void 0!==e?new g(r,At(e,n)):new g(r):_t in r?kt(y,r):Rt.call(y,r):new g(Mt(r,l))}),Z(b!==Function.prototype?P(g).concat(P(b)):P(g),function(t){t in y||h(y,t,g[t])}),y[H]=_,e||(_.constructor=y));var A=_[bt],N=!!A&&("values"==A.name||void 0==A.name),T=Vt.values;h(y,xt,!0),h(_,_t,a),h(_,Ot,!0),h(_,wt,y),(f?new y(1)[mt]==a:mt in _)||G(_,mt,{get:function(){return a}}),S[a]=y,u(u.G+u.W+u.F*(y!=g),S),u(u.S,a,{BYTES_PER_ELEMENT:n,from:Rt,of:Ct}),Y in _||h(_,Y,n),u(u.P,a,Wt),R(a),u(u.P+u.F*Ft,a,{set:Bt}),u(u.P+u.F*!N,a,Vt),u(u.P+u.F*(_.toString!=yt),a,{toString:yt}),u(u.P+u.F*o(function(){new y(1).slice()}),a,{slice:Gt}),u(u.P+u.F*(o(function(){return[1,2].toLocaleString()!=new y([1,2]).toLocaleString()})||!o(function(){_.toLocaleString.call([1,2])})),a,{toLocaleString:Ut}),k[a]=N?A:T,e||N||h(_,bt,T)}}else t.exports=function(){}},function(t,n){var r={}.toString;t.exports=function(t){return r.call(t).slice(8,-1)}},function(t,n,r){var e=r(21),i=r(5).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n,r){t.exports=!r(12)&&!r(18)(function(){return 7!=Object.defineProperty(r(57)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){"use strict";var e=r(36),i=r(51),o=r(64),u=r(13),c=r(8),f=r(35),a=r(96),s=r(38),l=r(103),h=r(15)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n,r){var e=r(20),i=r(100),o=r(34),u=r(39)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(57)("iframe"),e=o.length;for(n.style.display="none",r(93).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(63),i=r(34).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(8),i=r(9),o=r(90)(!1),u=r(39)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){t.exports=r(13)},function(t,n,r){var e=r(76)("meta"),i=r(6),o=r(24),u=r(11).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(4)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n){t.exports=function(t,n){return{enumerable:!(1&t),configurable:!(2&t),writable:!(4&t),value:n}}},function(t,n){var r=Math.ceil,e=Math.floor;t.exports=function(t){return isNaN(t=+t)?0:(t>0?e:r)(t)}},function(t,n){t.exports=function(t,n,r,e){if(!(t instanceof n)||void 0!==e&&e in t)throw TypeError(r+": incorrect invocation!");return t}},function(t,n){t.exports=!1},function(t,n,r){var e=r(2),i=r(173),o=r(133),u=r(145)("IE_PROTO"),c=function(){},f="prototype",a=function(){var t,n=r(132)("iframe"),e=o.length;for(n.style.display="none",r(135).appendChild(n),n.src="javascript:",t=n.contentWindow.document,t.open(),t.write("<script>document.F=Object<\/script>"),t.close(),a=t.F;e--;)delete a[f][o[e]];return a()};t.exports=Object.create||function(t,n){var r;return null!==t?(c[f]=e(t),r=new c,c[f]=null,r[u]=t):r=a(),void 0===n?r:i(r,n)}},function(t,n,r){var e=r(175),i=r(133).concat("length","prototype");n.f=Object.getOwnPropertyNames||function(t){return e(t,i)}},function(t,n,r){var e=r(175),i=r(133);t.exports=Object.keys||function(t){return e(t,i)}},function(t,n,r){var e=r(28);t.exports=function(t,n,r){for(var i in n)e(t,i,n[i],r);return t}},function(t,n,r){"use strict";var e=r(3),i=r(11),o=r(10),u=r(7)("species");t.exports=function(t){var n=e[t];o&&n&&!n[u]&&i.f(n,u,{configurable:!0,get:function(){return this}})}},function(t,n,r){var e=r(67),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n){var r=0,e=Math.random();t.exports=function(t){return"Symbol(".concat(void 0===t?"":t,")_",(++r+e).toString(36))}},function(t,n,r){var e=r(33);t.exports=function(t){return Object(e(t))}},function(t,n,r){var e=r(7)("unscopables"),i=Array.prototype;void 0==i[e]&&r(27)(i,e,{}),t.exports=function(t){i[e][t]=!0}},function(t,n,r){var e=r(53),i=r(169),o=r(137),u=r(2),c=r(16),f=r(154),a={},s={},n=t.exports=function(t,n,r,l,h){var v,p,d,y,g=h?function(){return t}:f(t),b=e(r,l,n?2:1),m=0;if("function"!=typeof g)throw TypeError(t+" is not iterable!");if(o(g)){for(v=c(t.length);v>m;m++)if((y=n?b(u(p=t[m])[0],p[1]):b(t[m]))===a||y===s)return y}else for(d=g.call(t);!(p=d.next()).done;)if((y=i(d,b,p.value,n))===a||y===s)return y};n.BREAK=a,n.RETURN=s},function(t,n){t.exports={}},function(t,n,r){var e=r(11).f,i=r(24),o=r(7)("toStringTag");t.exports=function(t,n,r){t&&!i(t=r?t:t.prototype,o)&&e(t,o,{configurable:!0,value:n})}},function(t,n,r){var e=r(1),i=r(46),o=r(4),u=r(150),c="["+u+"]",f="​",a=RegExp("^"+c+c+"*"),s=RegExp(c+c+"*$"),l=function(t,n,r){var i={},c=o(function(){return!!u[t]()||f[t]()!=f}),a=i[t]=c?n(h):u[t];r&&(i[r]=a),e(e.P+e.F*c,"String",i)},h=l.trim=function(t,n){return t=String(i(t)),1&n&&(t=t.replace(a,"")),2&n&&(t=t.replace(s,"")),t};t.exports=l},function(t,n,r){t.exports={default:r(86),__esModule:!0}},function(t,n,r){t.exports={default:r(87),__esModule:!0}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}n.__esModule=!0;var i=r(84),o=e(i),u=r(83),c=e(u),f="function"==typeof c.default&&"symbol"==typeof o.default?function(t){return typeof t}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":typeof t};n.default="function"==typeof c.default&&"symbol"===f(o.default)?function(t){return void 0===t?"undefined":f(t)}:function(t){return t&&"function"==typeof c.default&&t.constructor===c.default&&t!==c.default.prototype?"symbol":void 0===t?"undefined":f(t)}},function(t,n,r){r(110),r(108),r(111),r(112),t.exports=r(25).Symbol},function(t,n,r){r(109),r(113),t.exports=r(44).f("iterator")},function(t,n){t.exports=function(t){if("function"!=typeof t)throw TypeError(t+" is not a function!");return t}},function(t,n){t.exports=function(){}},function(t,n,r){var e=r(9),i=r(106),o=r(105);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){var e=r(88);t.exports=function(t,n,r){if(e(t),void 0===n)return t;switch(r){case 1:return function(r){return t.call(n,r)};case 2:return function(r,e){return t.call(n,r,e)};case 3:return function(r,e,i){return t.call(n,r,e,i)}}return function(){return t.apply(n,arguments)}}},function(t,n,r){var e=r(19),i=r(62),o=r(37);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){t.exports=r(5).document&&document.documentElement},function(t,n,r){var e=r(56);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n,r){var e=r(56);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(60),i=r(22),o=r(38),u={};r(13)(u,r(15)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n,r){var e=r(19),i=r(9);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){var e=r(23)("meta"),i=r(21),o=r(8),u=r(14).f,c=0,f=Object.isExtensible||function(){return!0},a=!r(18)(function(){return f(Object.preventExtensions({}))}),s=function(t){u(t,e,{value:{i:"O"+ ++c,w:{}}})},l=function(t,n){if(!i(t))return"symbol"==typeof t?t:("string"==typeof t?"S":"P")+t;if(!o(t,e)){if(!f(t))return"F";if(!n)return"E";s(t)}return t[e].i},h=function(t,n){if(!o(t,e)){if(!f(t))return!0;if(!n)return!1;s(t)}return t[e].w},v=function(t){return a&&p.NEED&&f(t)&&!o(t,e)&&s(t),t},p=t.exports={KEY:e,NEED:!1,fastKey:l,getWeak:h,onFreeze:v}},function(t,n,r){var e=r(14),i=r(20),o=r(19);t.exports=r(12)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(37),i=r(22),o=r(9),u=r(42),c=r(8),f=r(58),a=Object.getOwnPropertyDescriptor;n.f=r(12)?a:function(t,n){if(t=o(t),n=u(n,!0),f)try{return a(t,n)}catch(t){}if(c(t,n))return i(!e.f.call(t,n),t[n])}},function(t,n,r){var e=r(9),i=r(61).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(8),i=r(77),o=r(39)("IE_PROTO"),u=Object.prototype;t.exports=Object.getPrototypeOf||function(t){return t=i(t),e(t,o)?t[o]:"function"==typeof t.constructor&&t instanceof t.constructor?t.constructor.prototype:t instanceof Object?u:null}},function(t,n,r){var e=r(41),i=r(33);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(41),i=Math.max,o=Math.min;t.exports=function(t,n){return t=e(t),t<0?i(t+n,0):o(t,n)}},function(t,n,r){var e=r(41),i=Math.min;t.exports=function(t){return t>0?i(e(t),9007199254740991):0}},function(t,n,r){"use strict";var e=r(89),i=r(97),o=r(35),u=r(9);t.exports=r(59)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){},function(t,n,r){"use strict";var e=r(104)(!0);r(59)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";var e=r(5),i=r(8),o=r(12),u=r(51),c=r(64),f=r(99).KEY,a=r(18),s=r(40),l=r(38),h=r(23),v=r(15),p=r(44),d=r(43),y=r(98),g=r(92),b=r(95),m=r(20),x=r(9),w=r(42),S=r(22),_=r(60),O=r(102),E=r(101),P=r(14),j=r(19),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(61).f=O.f=Z,r(37).f=X,r(62).f=tt,o&&!r(36)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(13)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){r(43)("asyncIterator")},function(t,n,r){r(43)("observable")},function(t,n,r){r(107);for(var e=r(5),i=r(13),o=r(35),u=r(15)("toStringTag"),c=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],f=0;f<5;f++){var a=c[f],s=e[a],l=s&&s.prototype;l&&!l[u]&&i(l,u,a),o[a]=o.Array}},function(t,n,r){var e=r(45),i=r(7)("toStringTag"),o="Arguments"==e(function(){return arguments}()),u=function(t,n){try{return t[n]}catch(t){}};t.exports=function(t){var n,r,c;return void 0===t?"Undefined":null===t?"Null":"string"==typeof(r=u(n=Object(t),i))?r:o?e(n):"Object"==(c=e(n))&&"function"==typeof n.callee?"Arguments":c}},function(t,n,r){var e=r(45);t.exports=Object("z").propertyIsEnumerable(0)?Object:function(t){return"String"==e(t)?t.split(""):Object(t)}},function(t,n){n.f={}.propertyIsEnumerable},function(t,n,r){var e=r(30),i=r(16),o=r(75);t.exports=function(t){return function(n,r,u){var c,f=e(n),a=i(f.length),s=o(u,a);if(t&&r!=r){for(;a>s;)if((c=f[s++])!=c)return!0}else for(;a>s;s++)if((t||s in f)&&f[s]===r)return t||s||0;return!t&&-1}}},function(t,n,r){"use strict";var e=r(3),i=r(1),o=r(28),u=r(73),c=r(65),f=r(79),a=r(68),s=r(6),l=r(4),h=r(123),v=r(81),p=r(136);t.exports=function(t,n,r,d,y,g){var b=e[t],m=b,x=y?"set":"add",w=m&&m.prototype,S={},_=function(t){var n=w[t];o(w,t,"delete"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"has"==t?function(t){return!(g&&!s(t))&&n.call(this,0===t?0:t)}:"get"==t?function(t){return g&&!s(t)?void 0:n.call(this,0===t?0:t)}:"add"==t?function(t){return n.call(this,0===t?0:t),this}:function(t,r){return n.call(this,0===t?0:t,r),this})};if("function"==typeof m&&(g||w.forEach&&!l(function(){(new m).entries().next()}))){var O=new m,E=O[x](g?{}:-0,1)!=O,P=l(function(){O.has(1)}),j=h(function(t){new m(t)}),F=!g&&l(function(){for(var t=new m,n=5;n--;)t[x](n,n);return!t.has(-0)});j||(m=n(function(n,r){a(n,m,t);var e=p(new b,n,m);return void 0!=r&&f(r,y,e[x],e),e}),m.prototype=w,w.constructor=m),(P||F)&&(_("delete"),_("has"),y&&_("get")),(F||E)&&_(x),g&&w.clear&&delete w.clear}else m=d.getConstructor(n,t,y,x),u(m.prototype,r),c.NEED=!0;return v(m,t),S[t]=m,i(i.G+i.W+i.F*(m!=b),S),g||d.setStrong(m,t,y),m}},function(t,n,r){"use strict";var e=r(27),i=r(28),o=r(4),u=r(46),c=r(7);t.exports=function(t,n,r){var f=c(t),a=r(u,f,""[t]),s=a[0],l=a[1];o(function(){var n={};return n[f]=function(){return 7},7!=""[t](n)})&&(i(String.prototype,t,s),e(RegExp.prototype,f,2==n?function(t,n){return l.call(t,this,n)}:function(t){return l.call(t,this)}))}
},function(t,n,r){"use strict";var e=r(2);t.exports=function(){var t=e(this),n="";return t.global&&(n+="g"),t.ignoreCase&&(n+="i"),t.multiline&&(n+="m"),t.unicode&&(n+="u"),t.sticky&&(n+="y"),n}},function(t,n){t.exports=function(t,n,r){var e=void 0===r;switch(n.length){case 0:return e?t():t.call(r);case 1:return e?t(n[0]):t.call(r,n[0]);case 2:return e?t(n[0],n[1]):t.call(r,n[0],n[1]);case 3:return e?t(n[0],n[1],n[2]):t.call(r,n[0],n[1],n[2]);case 4:return e?t(n[0],n[1],n[2],n[3]):t.call(r,n[0],n[1],n[2],n[3])}return t.apply(r,n)}},function(t,n,r){var e=r(6),i=r(45),o=r(7)("match");t.exports=function(t){var n;return e(t)&&(void 0!==(n=t[o])?!!n:"RegExp"==i(t))}},function(t,n,r){var e=r(7)("iterator"),i=!1;try{var o=[7][e]();o.return=function(){i=!0},Array.from(o,function(){throw 2})}catch(t){}t.exports=function(t,n){if(!n&&!i)return!1;var r=!1;try{var o=[7],u=o[e]();u.next=function(){return{done:r=!0}},o[e]=function(){return u},t(o)}catch(t){}return r}},function(t,n,r){t.exports=r(69)||!r(4)(function(){var t=Math.random();__defineSetter__.call(null,t,function(){}),delete r(3)[t]})},function(t,n){n.f=Object.getOwnPropertySymbols},function(t,n,r){var e=r(3),i="__core-js_shared__",o=e[i]||(e[i]={});t.exports=function(t){return o[t]||(o[t]={})}},function(t,n,r){for(var e,i=r(3),o=r(27),u=r(76),c=u("typed_array"),f=u("view"),a=!(!i.ArrayBuffer||!i.DataView),s=a,l=0,h="Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array".split(",");l<9;)(e=i[h[l++]])?(o(e.prototype,c,!0),o(e.prototype,f,!0)):s=!1;t.exports={ABV:a,CONSTR:s,TYPED:c,VIEW:f}},function(t,n){"use strict";var r={versions:function(){var t=window.navigator.userAgent;return{trident:t.indexOf("Trident")>-1,presto:t.indexOf("Presto")>-1,webKit:t.indexOf("AppleWebKit")>-1,gecko:t.indexOf("Gecko")>-1&&-1==t.indexOf("KHTML"),mobile:!!t.match(/AppleWebKit.*Mobile.*/),ios:!!t.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/),android:t.indexOf("Android")>-1||t.indexOf("Linux")>-1,iPhone:t.indexOf("iPhone")>-1||t.indexOf("Mac")>-1,iPad:t.indexOf("iPad")>-1,webApp:-1==t.indexOf("Safari"),weixin:-1==t.indexOf("MicroMessenger")}}()};t.exports=r},function(t,n,r){"use strict";var e=r(85),i=function(t){return t&&t.__esModule?t:{default:t}}(e),o=function(){function t(t,n,e){return n||e?String.fromCharCode(n||e):r[t]||t}function n(t){return e[t]}var r={"&quot;":'"',"&lt;":"<","&gt;":">","&amp;":"&","&nbsp;":" "},e={};for(var u in r)e[r[u]]=u;return r["&apos;"]="'",e["'"]="&#39;",{encode:function(t){return t?(""+t).replace(/['<> "&]/g,n).replace(/\r?\n/g,"<br/>").replace(/\s/g,"&nbsp;"):""},decode:function(n){return n?(""+n).replace(/<br\s*\/?>/gi,"\n").replace(/&quot;|&lt;|&gt;|&amp;|&nbsp;|&apos;|&#(\d+);|&#(\d+)/g,t).replace(/\u00a0/g," "):""},encodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},encodeBase16forJSON:function(t){if(!t)return t;t=t.replace(/[\u4E00-\u9FBF]/gi,function(t){return escape(t).replace("%u","\\u")});for(var n=[],r=0,e=t.length;e>r;r++)n.push(t.charCodeAt(r).toString(16).toUpperCase());return n.join("")},decodeBase16:function(t){if(!t)return t;t+="";for(var n=[],r=0,e=t.length;e>r;r+=2)n.push(String.fromCharCode("0x"+t.slice(r,r+2)));return n.join("")},encodeObject:function(t){if(t instanceof Array)for(var n=0,r=t.length;r>n;n++)t[n]=o.encodeObject(t[n]);else if("object"==(void 0===t?"undefined":(0,i.default)(t)))for(var e in t)t[e]=o.encodeObject(t[e]);else if("string"==typeof t)return o.encode(t);return t},loadScript:function(t){var n=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(n),n.setAttribute("src",t)},addLoadEvent:function(t){var n=window.onload;"function"!=typeof window.onload?window.onload=t:window.onload=function(){n(),t()}}}}();t.exports=o},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=function(t){for(var n=e(this),r=o(n.length),u=arguments.length,c=i(u>1?arguments[1]:void 0,r),f=u>2?arguments[2]:void 0,a=void 0===f?r:i(f,r);a>c;)n[c++]=t;return n}},function(t,n,r){"use strict";var e=r(11),i=r(66);t.exports=function(t,n,r){n in t?e.f(t,n,i(0,r)):t[n]=r}},function(t,n,r){var e=r(6),i=r(3).document,o=e(i)&&e(i.createElement);t.exports=function(t){return o?i.createElement(t):{}}},function(t,n){t.exports="constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf".split(",")},function(t,n,r){var e=r(7)("match");t.exports=function(t){var n=/./;try{"/./"[t](n)}catch(r){try{return n[e]=!1,!"/./"[t](n)}catch(t){}}return!0}},function(t,n,r){t.exports=r(3).document&&document.documentElement},function(t,n,r){var e=r(6),i=r(144).set;t.exports=function(t,n,r){var o,u=n.constructor;return u!==r&&"function"==typeof u&&(o=u.prototype)!==r.prototype&&e(o)&&i&&i(t,o),t}},function(t,n,r){var e=r(80),i=r(7)("iterator"),o=Array.prototype;t.exports=function(t){return void 0!==t&&(e.Array===t||o[i]===t)}},function(t,n,r){var e=r(45);t.exports=Array.isArray||function(t){return"Array"==e(t)}},function(t,n,r){"use strict";var e=r(70),i=r(66),o=r(81),u={};r(27)(u,r(7)("iterator"),function(){return this}),t.exports=function(t,n,r){t.prototype=e(u,{next:i(1,r)}),o(t,n+" Iterator")}},function(t,n,r){"use strict";var e=r(69),i=r(1),o=r(28),u=r(27),c=r(24),f=r(80),a=r(139),s=r(81),l=r(32),h=r(7)("iterator"),v=!([].keys&&"next"in[].keys()),p="keys",d="values",y=function(){return this};t.exports=function(t,n,r,g,b,m,x){a(r,n,g);var w,S,_,O=function(t){if(!v&&t in F)return F[t];switch(t){case p:case d:return function(){return new r(this,t)}}return function(){return new r(this,t)}},E=n+" Iterator",P=b==d,j=!1,F=t.prototype,M=F[h]||F["@@iterator"]||b&&F[b],A=M||O(b),N=b?P?O("entries"):A:void 0,T="Array"==n?F.entries||M:M;if(T&&(_=l(T.call(new t)))!==Object.prototype&&(s(_,E,!0),e||c(_,h)||u(_,h,y)),P&&M&&M.name!==d&&(j=!0,A=function(){return M.call(this)}),e&&!x||!v&&!j&&F[h]||u(F,h,A),f[n]=A,f[E]=y,b)if(w={values:P?A:O(d),keys:m?A:O(p),entries:N},x)for(S in w)S in F||o(F,S,w[S]);else i(i.P+i.F*(v||j),n,w);return w}},function(t,n){var r=Math.expm1;t.exports=!r||r(10)>22025.465794806718||r(10)<22025.465794806718||-2e-17!=r(-2e-17)?function(t){return 0==(t=+t)?t:t>-1e-6&&t<1e-6?t+t*t/2:Math.exp(t)-1}:r},function(t,n){t.exports=Math.sign||function(t){return 0==(t=+t)||t!=t?t:t<0?-1:1}},function(t,n,r){var e=r(3),i=r(151).set,o=e.MutationObserver||e.WebKitMutationObserver,u=e.process,c=e.Promise,f="process"==r(45)(u);t.exports=function(){var t,n,r,a=function(){var e,i;for(f&&(e=u.domain)&&e.exit();t;){i=t.fn,t=t.next;try{i()}catch(e){throw t?r():n=void 0,e}}n=void 0,e&&e.enter()};if(f)r=function(){u.nextTick(a)};else if(o){var s=!0,l=document.createTextNode("");new o(a).observe(l,{characterData:!0}),r=function(){l.data=s=!s}}else if(c&&c.resolve){var h=c.resolve();r=function(){h.then(a)}}else r=function(){i.call(e,a)};return function(e){var i={fn:e,next:void 0};n&&(n.next=i),t||(t=i,r()),n=i}}},function(t,n,r){var e=r(6),i=r(2),o=function(t,n){if(i(t),!e(n)&&null!==n)throw TypeError(n+": can't set as prototype!")};t.exports={set:Object.setPrototypeOf||("__proto__"in{}?function(t,n,e){try{e=r(53)(Function.call,r(31).f(Object.prototype,"__proto__").set,2),e(t,[]),n=!(t instanceof Array)}catch(t){n=!0}return function(t,r){return o(t,r),n?t.__proto__=r:e(t,r),t}}({},!1):void 0),check:o}},function(t,n,r){var e=r(126)("keys"),i=r(76);t.exports=function(t){return e[t]||(e[t]=i(t))}},function(t,n,r){var e=r(2),i=r(26),o=r(7)("species");t.exports=function(t,n){var r,u=e(t).constructor;return void 0===u||void 0==(r=e(u)[o])?n:i(r)}},function(t,n,r){var e=r(67),i=r(46);t.exports=function(t){return function(n,r){var o,u,c=String(i(n)),f=e(r),a=c.length;return f<0||f>=a?t?"":void 0:(o=c.charCodeAt(f),o<55296||o>56319||f+1===a||(u=c.charCodeAt(f+1))<56320||u>57343?t?c.charAt(f):o:t?c.slice(f,f+2):u-56320+(o-55296<<10)+65536)}}},function(t,n,r){var e=r(122),i=r(46);t.exports=function(t,n,r){if(e(n))throw TypeError("String#"+r+" doesn't accept regex!");return String(i(t))}},function(t,n,r){"use strict";var e=r(67),i=r(46);t.exports=function(t){var n=String(i(this)),r="",o=e(t);if(o<0||o==1/0)throw RangeError("Count can't be negative");for(;o>0;(o>>>=1)&&(n+=n))1&o&&(r+=n);return r}},function(t,n){t.exports="\t\n\v\f\r   ᠎             　\u2028\u2029\ufeff"},function(t,n,r){var e,i,o,u=r(53),c=r(121),f=r(135),a=r(132),s=r(3),l=s.process,h=s.setImmediate,v=s.clearImmediate,p=s.MessageChannel,d=0,y={},g="onreadystatechange",b=function(){var t=+this;if(y.hasOwnProperty(t)){var n=y[t];delete y[t],n()}},m=function(t){b.call(t.data)};h&&v||(h=function(t){for(var n=[],r=1;arguments.length>r;)n.push(arguments[r++]);return y[++d]=function(){c("function"==typeof t?t:Function(t),n)},e(d),d},v=function(t){delete y[t]},"process"==r(45)(l)?e=function(t){l.nextTick(u(b,t,1))}:p?(i=new p,o=i.port2,i.port1.onmessage=m,e=u(o.postMessage,o,1)):s.addEventListener&&"function"==typeof postMessage&&!s.importScripts?(e=function(t){s.postMessage(t+"","*")},s.addEventListener("message",m,!1)):e=g in a("script")?function(t){f.appendChild(a("script"))[g]=function(){f.removeChild(this),b.call(t)}}:function(t){setTimeout(u(b,t,1),0)}),t.exports={set:h,clear:v}},function(t,n,r){"use strict";var e=r(3),i=r(10),o=r(69),u=r(127),c=r(27),f=r(73),a=r(4),s=r(68),l=r(67),h=r(16),v=r(71).f,p=r(11).f,d=r(130),y=r(81),g="ArrayBuffer",b="DataView",m="prototype",x="Wrong length!",w="Wrong index!",S=e[g],_=e[b],O=e.Math,E=e.RangeError,P=e.Infinity,j=S,F=O.abs,M=O.pow,A=O.floor,N=O.log,T=O.LN2,I="buffer",k="byteLength",L="byteOffset",R=i?"_b":I,C=i?"_l":k,D=i?"_o":L,U=function(t,n,r){var e,i,o,u=Array(r),c=8*r-n-1,f=(1<<c)-1,a=f>>1,s=23===n?M(2,-24)-M(2,-77):0,l=0,h=t<0||0===t&&1/t<0?1:0;for(t=F(t),t!=t||t===P?(i=t!=t?1:0,e=f):(e=A(N(t)/T),t*(o=M(2,-e))<1&&(e--,o*=2),t+=e+a>=1?s/o:s*M(2,1-a),t*o>=2&&(e++,o/=2),e+a>=f?(i=0,e=f):e+a>=1?(i=(t*o-1)*M(2,n),e+=a):(i=t*M(2,a-1)*M(2,n),e=0));n>=8;u[l++]=255&i,i/=256,n-=8);for(e=e<<n|i,c+=n;c>0;u[l++]=255&e,e/=256,c-=8);return u[--l]|=128*h,u},W=function(t,n,r){var e,i=8*r-n-1,o=(1<<i)-1,u=o>>1,c=i-7,f=r-1,a=t[f--],s=127&a;for(a>>=7;c>0;s=256*s+t[f],f--,c-=8);for(e=s&(1<<-c)-1,s>>=-c,c+=n;c>0;e=256*e+t[f],f--,c-=8);if(0===s)s=1-u;else{if(s===o)return e?NaN:a?-P:P;e+=M(2,n),s-=u}return(a?-1:1)*e*M(2,s-n)},G=function(t){return t[3]<<24|t[2]<<16|t[1]<<8|t[0]},B=function(t){return[255&t]},V=function(t){return[255&t,t>>8&255]},z=function(t){return[255&t,t>>8&255,t>>16&255,t>>24&255]},q=function(t){return U(t,52,8)},K=function(t){return U(t,23,4)},J=function(t,n,r){p(t[m],n,{get:function(){return this[r]}})},Y=function(t,n,r,e){var i=+r,o=l(i);if(i!=o||o<0||o+n>t[C])throw E(w);var u=t[R]._b,c=o+t[D],f=u.slice(c,c+n);return e?f:f.reverse()},H=function(t,n,r,e,i,o){var u=+r,c=l(u);if(u!=c||c<0||c+n>t[C])throw E(w);for(var f=t[R]._b,a=c+t[D],s=e(+i),h=0;h<n;h++)f[a+h]=s[o?h:n-h-1]},$=function(t,n){s(t,S,g);var r=+n,e=h(r);if(r!=e)throw E(x);return e};if(u.ABV){if(!a(function(){new S})||!a(function(){new S(.5)})){S=function(t){return new j($(this,t))};for(var X,Q=S[m]=j[m],Z=v(j),tt=0;Z.length>tt;)(X=Z[tt++])in S||c(S,X,j[X]);o||(Q.constructor=S)}var nt=new _(new S(2)),rt=_[m].setInt8;nt.setInt8(0,2147483648),nt.setInt8(1,2147483649),!nt.getInt8(0)&&nt.getInt8(1)||f(_[m],{setInt8:function(t,n){rt.call(this,t,n<<24>>24)},setUint8:function(t,n){rt.call(this,t,n<<24>>24)}},!0)}else S=function(t){var n=$(this,t);this._b=d.call(Array(n),0),this[C]=n},_=function(t,n,r){s(this,_,b),s(t,S,b);var e=t[C],i=l(n);if(i<0||i>e)throw E("Wrong offset!");if(r=void 0===r?e-i:h(r),i+r>e)throw E(x);this[R]=t,this[D]=i,this[C]=r},i&&(J(S,k,"_l"),J(_,I,"_b"),J(_,k,"_l"),J(_,L,"_o")),f(_[m],{getInt8:function(t){return Y(this,1,t)[0]<<24>>24},getUint8:function(t){return Y(this,1,t)[0]},getInt16:function(t){var n=Y(this,2,t,arguments[1]);return(n[1]<<8|n[0])<<16>>16},getUint16:function(t){var n=Y(this,2,t,arguments[1]);return n[1]<<8|n[0]},getInt32:function(t){return G(Y(this,4,t,arguments[1]))},getUint32:function(t){return G(Y(this,4,t,arguments[1]))>>>0},getFloat32:function(t){return W(Y(this,4,t,arguments[1]),23,4)},getFloat64:function(t){return W(Y(this,8,t,arguments[1]),52,8)},setInt8:function(t,n){H(this,1,t,B,n)},setUint8:function(t,n){H(this,1,t,B,n)},setInt16:function(t,n){H(this,2,t,V,n,arguments[2])},setUint16:function(t,n){H(this,2,t,V,n,arguments[2])},setInt32:function(t,n){H(this,4,t,z,n,arguments[2])},setUint32:function(t,n){H(this,4,t,z,n,arguments[2])},setFloat32:function(t,n){H(this,4,t,K,n,arguments[2])},setFloat64:function(t,n){H(this,8,t,q,n,arguments[2])}});y(S,g),y(_,b),c(_[m],u.VIEW,!0),n[g]=S,n[b]=_},function(t,n,r){var e=r(3),i=r(52),o=r(69),u=r(182),c=r(11).f;t.exports=function(t){var n=i.Symbol||(i.Symbol=o?{}:e.Symbol||{});"_"==t.charAt(0)||t in n||c(n,t,{value:u.f(t)})}},function(t,n,r){var e=r(114),i=r(7)("iterator"),o=r(80);t.exports=r(52).getIteratorMethod=function(t){if(void 0!=t)return t[i]||t["@@iterator"]||o[e(t)]}},function(t,n,r){"use strict";var e=r(78),i=r(170),o=r(80),u=r(30);t.exports=r(140)(Array,"Array",function(t,n){this._t=u(t),this._i=0,this._k=n},function(){var t=this._t,n=this._k,r=this._i++;return!t||r>=t.length?(this._t=void 0,i(1)):"keys"==n?i(0,r):"values"==n?i(0,t[r]):i(0,[r,t[r]])},"values"),o.Arguments=o.Array,e("keys"),e("values"),e("entries")},function(t,n){function r(t,n){t.classList?t.classList.add(n):t.className+=" "+n}t.exports=r},function(t,n){function r(t,n){if(t.classList)t.classList.remove(n);else{var r=new RegExp("(^|\\b)"+n.split(" ").join("|")+"(\\b|$)","gi");t.className=t.className.replace(r," ")}}t.exports=r},function(t,n){function r(){throw new Error("setTimeout has not been defined")}function e(){throw new Error("clearTimeout has not been defined")}function i(t){if(s===setTimeout)return setTimeout(t,0);if((s===r||!s)&&setTimeout)return s=setTimeout,setTimeout(t,0);try{return s(t,0)}catch(n){try{return s.call(null,t,0)}catch(n){return s.call(this,t,0)}}}function o(t){if(l===clearTimeout)return clearTimeout(t);if((l===e||!l)&&clearTimeout)return l=clearTimeout,clearTimeout(t);try{return l(t)}catch(n){try{return l.call(null,t)}catch(n){return l.call(this,t)}}}function u(){d&&v&&(d=!1,v.length?p=v.concat(p):y=-1,p.length&&c())}function c(){if(!d){var t=i(u);d=!0;for(var n=p.length;n;){for(v=p,p=[];++y<n;)v&&v[y].run();y=-1,n=p.length}v=null,d=!1,o(t)}}function f(t,n){this.fun=t,this.array=n}function a(){}var s,l,h=t.exports={};!function(){try{s="function"==typeof setTimeout?setTimeout:r}catch(t){s=r}try{l="function"==typeof clearTimeout?clearTimeout:e}catch(t){l=e}}();var v,p=[],d=!1,y=-1;h.nextTick=function(t){var n=new Array(arguments.length-1);if(arguments.length>1)for(var r=1;r<arguments.length;r++)n[r-1]=arguments[r];p.push(new f(t,n)),1!==p.length||d||i(c)},f.prototype.run=function(){this.fun.apply(null,this.array)},h.title="browser",h.browser=!0,h.env={},h.argv=[],h.version="",h.versions={},h.on=a,h.addListener=a,h.once=a,h.off=a,h.removeListener=a,h.removeAllListeners=a,h.emit=a,h.prependListener=a,h.prependOnceListener=a,h.listeners=function(t){return[]},h.binding=function(t){throw new Error("process.binding is not supported")},h.cwd=function(){return"/"},h.chdir=function(t){throw new Error("process.chdir is not supported")},h.umask=function(){return 0}},function(t,n,r){var e=r(45);t.exports=function(t,n){if("number"!=typeof t&&"Number"!=e(t))throw TypeError(n);return+t}},function(t,n,r){"use strict";var e=r(17),i=r(75),o=r(16);t.exports=[].copyWithin||function(t,n){var r=e(this),u=o(r.length),c=i(t,u),f=i(n,u),a=arguments.length>2?arguments[2]:void 0,s=Math.min((void 0===a?u:i(a,u))-f,u-c),l=1;for(f<c&&c<f+s&&(l=-1,f+=s-1,c+=s-1);s-- >0;)f in r?r[c]=r[f]:delete r[c],c+=l,f+=l;return r}},function(t,n,r){var e=r(79);t.exports=function(t,n){var r=[];return e(t,!1,r.push,r,n),r}},function(t,n,r){var e=r(26),i=r(17),o=r(115),u=r(16);t.exports=function(t,n,r,c,f){e(n);var a=i(t),s=o(a),l=u(a.length),h=f?l-1:0,v=f?-1:1;if(r<2)for(;;){if(h in s){c=s[h],h+=v;break}if(h+=v,f?h<0:l<=h)throw TypeError("Reduce of empty array with no initial value")}for(;f?h>=0:l>h;h+=v)h in s&&(c=n(c,s[h],h,a));return c}},function(t,n,r){"use strict";var e=r(26),i=r(6),o=r(121),u=[].slice,c={},f=function(t,n,r){if(!(n in c)){for(var e=[],i=0;i<n;i++)e[i]="a["+i+"]";c[n]=Function("F,a","return new F("+e.join(",")+")")}return c[n](t,r)};t.exports=Function.bind||function(t){var n=e(this),r=u.call(arguments,1),c=function(){var e=r.concat(u.call(arguments));return this instanceof c?f(n,e.length,e):o(n,e,t)};return i(n.prototype)&&(c.prototype=n.prototype),c}},function(t,n,r){"use strict";var e=r(11).f,i=r(70),o=r(73),u=r(53),c=r(68),f=r(46),a=r(79),s=r(140),l=r(170),h=r(74),v=r(10),p=r(65).fastKey,d=v?"_s":"size",y=function(t,n){var r,e=p(n);if("F"!==e)return t._i[e];for(r=t._f;r;r=r.n)if(r.k==n)return r};t.exports={getConstructor:function(t,n,r,s){var l=t(function(t,e){c(t,l,n,"_i"),t._i=i(null),t._f=void 0,t._l=void 0,t[d]=0,void 0!=e&&a(e,r,t[s],t)});return o(l.prototype,{clear:function(){for(var t=this,n=t._i,r=t._f;r;r=r.n)r.r=!0,r.p&&(r.p=r.p.n=void 0),delete n[r.i];t._f=t._l=void 0,t[d]=0},delete:function(t){var n=this,r=y(n,t);if(r){var e=r.n,i=r.p;delete n._i[r.i],r.r=!0,i&&(i.n=e),e&&(e.p=i),n._f==r&&(n._f=e),n._l==r&&(n._l=i),n[d]--}return!!r},forEach:function(t){c(this,l,"forEach");for(var n,r=u(t,arguments.length>1?arguments[1]:void 0,3);n=n?n.n:this._f;)for(r(n.v,n.k,this);n&&n.r;)n=n.p},has:function(t){return!!y(this,t)}}),v&&e(l.prototype,"size",{get:function(){return f(this[d])}}),l},def:function(t,n,r){var e,i,o=y(t,n);return o?o.v=r:(t._l=o={i:i=p(n,!0),k:n,v:r,p:e=t._l,n:void 0,r:!1},t._f||(t._f=o),e&&(e.n=o),t[d]++,"F"!==i&&(t._i[i]=o)),t},getEntry:y,setStrong:function(t,n,r){s(t,n,function(t,n){this._t=t,this._k=n,this._l=void 0},function(){for(var t=this,n=t._k,r=t._l;r&&r.r;)r=r.p;return t._t&&(t._l=r=r?r.n:t._t._f)?"keys"==n?l(0,r.k):"values"==n?l(0,r.v):l(0,[r.k,r.v]):(t._t=void 0,l(1))},r?"entries":"values",!r,!0),h(n)}}},function(t,n,r){var e=r(114),i=r(161);t.exports=function(t){return function(){if(e(this)!=t)throw TypeError(t+"#toJSON isn't generic");return i(this)}}},function(t,n,r){"use strict";var e=r(73),i=r(65).getWeak,o=r(2),u=r(6),c=r(68),f=r(79),a=r(48),s=r(24),l=a(5),h=a(6),v=0,p=function(t){return t._l||(t._l=new d)},d=function(){this.a=[]},y=function(t,n){return l(t.a,function(t){return t[0]===n})};d.prototype={get:function(t){var n=y(this,t);if(n)return n[1]},has:function(t){return!!y(this,t)},set:function(t,n){var r=y(this,t);r?r[1]=n:this.a.push([t,n])},delete:function(t){var n=h(this.a,function(n){return n[0]===t});return~n&&this.a.splice(n,1),!!~n}},t.exports={getConstructor:function(t,n,r,o){var a=t(function(t,e){c(t,a,n,"_i"),t._i=v++,t._l=void 0,void 0!=e&&f(e,r,t[o],t)});return e(a.prototype,{delete:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).delete(t):n&&s(n,this._i)&&delete n[this._i]},has:function(t){if(!u(t))return!1;var n=i(t);return!0===n?p(this).has(t):n&&s(n,this._i)}}),a},def:function(t,n,r){var e=i(o(n),!0);return!0===e?p(t).set(n,r):e[t._i]=r,t},ufstore:p}},function(t,n,r){t.exports=!r(10)&&!r(4)(function(){return 7!=Object.defineProperty(r(132)("div"),"a",{get:function(){return 7}}).a})},function(t,n,r){var e=r(6),i=Math.floor;t.exports=function(t){return!e(t)&&isFinite(t)&&i(t)===t}},function(t,n,r){var e=r(2);t.exports=function(t,n,r,i){try{return i?n(e(r)[0],r[1]):n(r)}catch(n){var o=t.return;throw void 0!==o&&e(o.call(t)),n}}},function(t,n){t.exports=function(t,n){return{value:n,done:!!t}}},function(t,n){t.exports=Math.log1p||function(t){return(t=+t)>-1e-8&&t<1e-8?t-t*t/2:Math.log(1+t)}},function(t,n,r){"use strict";var e=r(72),i=r(125),o=r(116),u=r(17),c=r(115),f=Object.assign;t.exports=!f||r(4)(function(){var t={},n={},r=Symbol(),e="abcdefghijklmnopqrst";return t[r]=7,e.split("").forEach(function(t){n[t]=t}),7!=f({},t)[r]||Object.keys(f({},n)).join("")!=e})?function(t,n){for(var r=u(t),f=arguments.length,a=1,s=i.f,l=o.f;f>a;)for(var h,v=c(arguments[a++]),p=s?e(v).concat(s(v)):e(v),d=p.length,y=0;d>y;)l.call(v,h=p[y++])&&(r[h]=v[h]);return r}:f},function(t,n,r){var e=r(11),i=r(2),o=r(72);t.exports=r(10)?Object.defineProperties:function(t,n){i(t);for(var r,u=o(n),c=u.length,f=0;c>f;)e.f(t,r=u[f++],n[r]);return t}},function(t,n,r){var e=r(30),i=r(71).f,o={}.toString,u="object"==typeof window&&window&&Object.getOwnPropertyNames?Object.getOwnPropertyNames(window):[],c=function(t){try{return i(t)}catch(t){return u.slice()}};t.exports.f=function(t){return u&&"[object Window]"==o.call(t)?c(t):i(e(t))}},function(t,n,r){var e=r(24),i=r(30),o=r(117)(!1),u=r(145)("IE_PROTO");t.exports=function(t,n){var r,c=i(t),f=0,a=[];for(r in c)r!=u&&e(c,r)&&a.push(r);for(;n.length>f;)e(c,r=n[f++])&&(~o(a,r)||a.push(r));return a}},function(t,n,r){var e=r(72),i=r(30),o=r(116).f;t.exports=function(t){return function(n){for(var r,u=i(n),c=e(u),f=c.length,a=0,s=[];f>a;)o.call(u,r=c[a++])&&s.push(t?[r,u[r]]:u[r]);return s}}},function(t,n,r){var e=r(71),i=r(125),o=r(2),u=r(3).Reflect;t.exports=u&&u.ownKeys||function(t){var n=e.f(o(t)),r=i.f;return r?n.concat(r(t)):n}},function(t,n,r){var e=r(3).parseFloat,i=r(82).trim;t.exports=1/e(r(150)+"-0")!=-1/0?function(t){var n=i(String(t),3),r=e(n);return 0===r&&"-"==n.charAt(0)?-0:r}:e},function(t,n,r){var e=r(3).parseInt,i=r(82).trim,o=r(150),u=/^[\-+]?0[xX]/;t.exports=8!==e(o+"08")||22!==e(o+"0x16")?function(t,n){var r=i(String(t),3);return e(r,n>>>0||(u.test(r)?16:10))}:e},function(t,n){t.exports=Object.is||function(t,n){return t===n?0!==t||1/t==1/n:t!=t&&n!=n}},function(t,n,r){var e=r(16),i=r(149),o=r(46);t.exports=function(t,n,r,u){var c=String(o(t)),f=c.length,a=void 0===r?" ":String(r),s=e(n);if(s<=f||""==a)return c;var l=s-f,h=i.call(a,Math.ceil(l/a.length));return h.length>l&&(h=h.slice(0,l)),u?h+c:c+h}},function(t,n,r){n.f=r(7)},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Map",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{get:function(t){var n=e.getEntry(this,t);return n&&n.v},set:function(t,n){return e.def(this,0===t?0:t,n)}},e,!0)},function(t,n,r){r(10)&&"g"!=/./g.flags&&r(11).f(RegExp.prototype,"flags",{configurable:!0,get:r(120)})},function(t,n,r){"use strict";var e=r(164);t.exports=r(118)("Set",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t=0===t?0:t,t)}},e)},function(t,n,r){"use strict";var e,i=r(48)(0),o=r(28),u=r(65),c=r(172),f=r(166),a=r(6),s=u.getWeak,l=Object.isExtensible,h=f.ufstore,v={},p=function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},d={get:function(t){if(a(t)){var n=s(t);return!0===n?h(this).get(t):n?n[this._i]:void 0}},set:function(t,n){return f.def(this,t,n)}},y=t.exports=r(118)("WeakMap",p,d,f,!0,!0);7!=(new y).set((Object.freeze||Object)(v),7).get(v)&&(e=f.getConstructor(p),c(e.prototype,d),u.NEED=!0,i(["delete","has","get","set"],function(t){var n=y.prototype,r=n[t];o(n,t,function(n,i){if(a(n)&&!l(n)){this._f||(this._f=new e);var o=this._f[t](n,i);return"set"==t?this:o}return r.call(this,n,i)})}))},,,,function(t,n){"use strict";function r(){var t=document.querySelector("#page-nav");if(t&&!document.querySelector("#page-nav .extend.prev")&&(t.innerHTML='<a class="extend prev disabled" rel="prev">&laquo; Prev</a>'+t.innerHTML),t&&!document.querySelector("#page-nav .extend.next")&&(t.innerHTML=t.innerHTML+'<a class="extend next disabled" rel="next">Next &raquo;</a>'),yiliaConfig&&yiliaConfig.open_in_new){document.querySelectorAll(".article-entry a:not(.article-more-a)").forEach(function(t){var n=t.getAttribute("target");n&&""!==n||t.setAttribute("target","_blank")})}if(yiliaConfig&&yiliaConfig.toc_hide_index){document.querySelectorAll(".toc-number").forEach(function(t){t.style.display="none"})}var n=document.querySelector("#js-aboutme");n&&0!==n.length&&(n.innerHTML=n.innerText)}t.exports={init:r}},function(t,n,r){"use strict";function e(t){return t&&t.__esModule?t:{default:t}}function i(t,n){var r=/\/|index.html/g;return t.replace(r,"")===n.replace(r,"")}function o(){for(var t=document.querySelectorAll(".js-header-menu li a"),n=window.location.pathname,r=0,e=t.length;r<e;r++){var o=t[r];i(n,o.getAttribute("href"))&&(0,h.default)(o,"active")}}function u(t){for(var n=t.offsetLeft,r=t.offsetParent;null!==r;)n+=r.offsetLeft,r=r.offsetParent;return n}function c(t){for(var n=t.offsetTop,r=t.offsetParent;null!==r;)n+=r.offsetTop,r=r.offsetParent;return n}function f(t,n,r,e,i){var o=u(t),f=c(t)-n;if(f-r<=i){var a=t.$newDom;a||(a=t.cloneNode(!0),(0,d.default)(t,a),t.$newDom=a,a.style.position="fixed",a.style.top=(r||f)+"px",a.style.left=o+"px",a.style.zIndex=e||2,a.style.width="100%",a.style.color="#fff"),a.style.visibility="visible",t.style.visibility="hidden"}else{t.style.visibility="visible";var s=t.$newDom;s&&(s.style.visibility="hidden")}}function a(){var t=document.querySelector(".js-overlay"),n=document.querySelector(".js-header-menu");f(t,document.body.scrollTop,-63,2,0),f(n,document.body.scrollTop,1,3,0)}function s(){document.querySelector("#container").addEventListener("scroll",function(t){a()}),window.addEventListener("scroll",function(t){a()}),a()}var l=r(156),h=e(l),v=r(157),p=(e(v),r(382)),d=e(p),y=r(128),g=e(y),b=r(190),m=e(b),x=r(129);(function(){g.default.versions.mobile&&window.screen.width<800&&(o(),s())})(),(0,x.addLoadEvent)(function(){m.default.init()}),t.exports={}},,,,function(t,n,r){(function(t){"use strict";function n(t,n,r){t[n]||Object[e](t,n,{writable:!0,configurable:!0,value:r})}if(r(381),r(391),r(198),t._babelPolyfill)throw new Error("only one instance of babel-polyfill is allowed");t._babelPolyfill=!0;var e="defineProperty";n(String.prototype,"padLeft","".padStart),n(String.prototype,"padRight","".padEnd),"pop,reverse,shift,keys,values,entries,indexOf,every,some,forEach,map,filter,find,findIndex,includes,join,slice,concat,push,splice,unshift,sort,lastIndexOf,reduce,reduceRight,copyWithin,fill".split(",").forEach(function(t){[][t]&&n(Array,t,Function.call.bind([][t]))})}).call(n,function(){return this}())},,,function(t,n,r){r(210),t.exports=r(52).RegExp.escape},,,,function(t,n,r){var e=r(6),i=r(138),o=r(7)("species");t.exports=function(t){var n;return i(t)&&(n=t.constructor,"function"!=typeof n||n!==Array&&!i(n.prototype)||(n=void 0),e(n)&&null===(n=n[o])&&(n=void 0)),void 0===n?Array:n}},function(t,n,r){var e=r(202);t.exports=function(t,n){return new(e(t))(n)}},function(t,n,r){"use strict";var e=r(2),i=r(50),o="number";t.exports=function(t){if("string"!==t&&t!==o&&"default"!==t)throw TypeError("Incorrect hint");return i(e(this),t!=o)}},function(t,n,r){var e=r(72),i=r(125),o=r(116);t.exports=function(t){var n=e(t),r=i.f;if(r)for(var u,c=r(t),f=o.f,a=0;c.length>a;)f.call(t,u=c[a++])&&n.push(u);return n}},function(t,n,r){var e=r(72),i=r(30);t.exports=function(t,n){for(var r,o=i(t),u=e(o),c=u.length,f=0;c>f;)if(o[r=u[f++]]===n)return r}},function(t,n,r){"use strict";var e=r(208),i=r(121),o=r(26);t.exports=function(){for(var t=o(this),n=arguments.length,r=Array(n),u=0,c=e._,f=!1;n>u;)(r[u]=arguments[u++])===c&&(f=!0);return function(){var e,o=this,u=arguments.length,a=0,s=0;if(!f&&!u)return i(t,r,o);if(e=r.slice(),f)for(;n>a;a++)e[a]===c&&(e[a]=arguments[s++]);for(;u>s;)e.push(arguments[s++]);return i(t,e,o)}}},function(t,n,r){t.exports=r(3)},function(t,n){t.exports=function(t,n){var r=n===Object(n)?function(t){return n[t]}:n;return function(n){return String(n).replace(t,r)}}},function(t,n,r){var e=r(1),i=r(209)(/[\\^$*+?.()|[\]{}]/g,"\\$&");e(e.S,"RegExp",{escape:function(t){return i(t)}})},function(t,n,r){var e=r(1);e(e.P,"Array",{copyWithin:r(160)}),r(78)("copyWithin")},function(t,n,r){"use strict";var e=r(1),i=r(48)(4);e(e.P+e.F*!r(47)([].every,!0),"Array",{every:function(t){return i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.P,"Array",{fill:r(130)}),r(78)("fill")},function(t,n,r){"use strict";var e=r(1),i=r(48)(2);e(e.P+e.F*!r(47)([].filter,!0),"Array",{filter:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(6),o="findIndex",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{findIndex:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(5),o="find",u=!0;o in[]&&Array(1)[o](function(){u=!1}),e(e.P+e.F*u,"Array",{find:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)(o)},function(t,n,r){"use strict";var e=r(1),i=r(48)(0),o=r(47)([].forEach,!0);e(e.P+e.F*!o,"Array",{forEach:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(53),i=r(1),o=r(17),u=r(169),c=r(137),f=r(16),a=r(131),s=r(154);i(i.S+i.F*!r(123)(function(t){Array.from(t)}),"Array",{from:function(t){var n,r,i,l,h=o(t),v="function"==typeof this?this:Array,p=arguments.length,d=p>1?arguments[1]:void 0,y=void 0!==d,g=0,b=s(h);if(y&&(d=e(d,p>2?arguments[2]:void 0,2)),void 0==b||v==Array&&c(b))for(n=f(h.length),r=new v(n);n>g;g++)a(r,g,y?d(h[g],g):h[g]);else for(l=b.call(h),r=new v;!(i=l.next()).done;g++)a(r,g,y?u(l,d,[i.value,g],!0):i.value);return r.length=g,r}})},function(t,n,r){"use strict";var e=r(1),i=r(117)(!1),o=[].indexOf,u=!!o&&1/[1].indexOf(1,-0)<0;e(e.P+e.F*(u||!r(47)(o)),"Array",{indexOf:function(t){return u?o.apply(this,arguments)||0:i(this,t,arguments[1])}})},function(t,n,r){var e=r(1);e(e.S,"Array",{isArray:r(138)})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=[].join;e(e.P+e.F*(r(115)!=Object||!r(47)(o)),"Array",{join:function(t){return o.call(i(this),void 0===t?",":t)}})},function(t,n,r){"use strict";var e=r(1),i=r(30),o=r(67),u=r(16),c=[].lastIndexOf,f=!!c&&1/[1].lastIndexOf(1,-0)<0;e(e.P+e.F*(f||!r(47)(c)),"Array",{lastIndexOf:function(t){if(f)return c.apply(this,arguments)||0;var n=i(this),r=u(n.length),e=r-1;for(arguments.length>1&&(e=Math.min(e,o(arguments[1]))),e<0&&(e=r+e);e>=0;e--)if(e in n&&n[e]===t)return e||0;return-1}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(1);e(e.P+e.F*!r(47)([].map,!0),"Array",{map:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(131);e(e.S+e.F*r(4)(function(){function t(){}return!(Array.of.call(t)instanceof t)}),"Array",{of:function(){for(var t=0,n=arguments.length,r=new("function"==typeof this?this:Array)(n);n>t;)i(r,t,arguments[t++]);return r.length=n,r}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduceRight,!0),"Array",{reduceRight:function(t){return i(this,t,arguments.length,arguments[1],!0)}})},function(t,n,r){"use strict";var e=r(1),i=r(162);e(e.P+e.F*!r(47)([].reduce,!0),"Array",{reduce:function(t){return i(this,t,arguments.length,arguments[1],!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(135),o=r(45),u=r(75),c=r(16),f=[].slice;e(e.P+e.F*r(4)(function(){i&&f.call(i)}),"Array",{slice:function(t,n){var r=c(this.length),e=o(this);if(n=void 0===n?r:n,"Array"==e)return f.call(this,t,n);for(var i=u(t,r),a=u(n,r),s=c(a-i),l=Array(s),h=0;h<s;h++)l[h]="String"==e?this.charAt(i+h):this[i+h];return l}})},function(t,n,r){"use strict";var e=r(1),i=r(48)(3);e(e.P+e.F*!r(47)([].some,!0),"Array",{some:function(t){return i(this,t,arguments[1])}})},function(t,n,r){"use strict";var e=r(1),i=r(26),o=r(17),u=r(4),c=[].sort,f=[1,2,3];e(e.P+e.F*(u(function(){f.sort(void 0)})||!u(function(){f.sort(null)})||!r(47)(c)),"Array",{sort:function(t){return void 0===t?c.call(o(this)):c.call(o(this),i(t))}})},function(t,n,r){r(74)("Array")},function(t,n,r){var e=r(1);e(e.S,"Date",{now:function(){return(new Date).getTime()}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=Date.prototype.getTime,u=function(t){return t>9?t:"0"+t};e(e.P+e.F*(i(function(){return"0385-07-25T07:06:39.999Z"!=new Date(-5e13-1).toISOString()})||!i(function(){new Date(NaN).toISOString()})),"Date",{toISOString:function(){
if(!isFinite(o.call(this)))throw RangeError("Invalid time value");var t=this,n=t.getUTCFullYear(),r=t.getUTCMilliseconds(),e=n<0?"-":n>9999?"+":"";return e+("00000"+Math.abs(n)).slice(e?-6:-4)+"-"+u(t.getUTCMonth()+1)+"-"+u(t.getUTCDate())+"T"+u(t.getUTCHours())+":"+u(t.getUTCMinutes())+":"+u(t.getUTCSeconds())+"."+(r>99?r:"0"+u(r))+"Z"}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50);e(e.P+e.F*r(4)(function(){return null!==new Date(NaN).toJSON()||1!==Date.prototype.toJSON.call({toISOString:function(){return 1}})}),"Date",{toJSON:function(t){var n=i(this),r=o(n);return"number"!=typeof r||isFinite(r)?n.toISOString():null}})},function(t,n,r){var e=r(7)("toPrimitive"),i=Date.prototype;e in i||r(27)(i,e,r(204))},function(t,n,r){var e=Date.prototype,i="Invalid Date",o="toString",u=e[o],c=e.getTime;new Date(NaN)+""!=i&&r(28)(e,o,function(){var t=c.call(this);return t===t?u.call(this):i})},function(t,n,r){var e=r(1);e(e.P,"Function",{bind:r(163)})},function(t,n,r){"use strict";var e=r(6),i=r(32),o=r(7)("hasInstance"),u=Function.prototype;o in u||r(11).f(u,o,{value:function(t){if("function"!=typeof this||!e(t))return!1;if(!e(this.prototype))return t instanceof this;for(;t=i(t);)if(this.prototype===t)return!0;return!1}})},function(t,n,r){var e=r(11).f,i=r(66),o=r(24),u=Function.prototype,c="name",f=Object.isExtensible||function(){return!0};c in u||r(10)&&e(u,c,{configurable:!0,get:function(){try{var t=this,n=(""+t).match(/^\s*function ([^ (]*)/)[1];return o(t,c)||!f(t)||e(t,c,i(5,n)),n}catch(t){return""}}})},function(t,n,r){var e=r(1),i=r(171),o=Math.sqrt,u=Math.acosh;e(e.S+e.F*!(u&&710==Math.floor(u(Number.MAX_VALUE))&&u(1/0)==1/0),"Math",{acosh:function(t){return(t=+t)<1?NaN:t>94906265.62425156?Math.log(t)+Math.LN2:i(t-1+o(t-1)*o(t+1))}})},function(t,n,r){function e(t){return isFinite(t=+t)&&0!=t?t<0?-e(-t):Math.log(t+Math.sqrt(t*t+1)):t}var i=r(1),o=Math.asinh;i(i.S+i.F*!(o&&1/o(0)>0),"Math",{asinh:e})},function(t,n,r){var e=r(1),i=Math.atanh;e(e.S+e.F*!(i&&1/i(-0)<0),"Math",{atanh:function(t){return 0==(t=+t)?t:Math.log((1+t)/(1-t))/2}})},function(t,n,r){var e=r(1),i=r(142);e(e.S,"Math",{cbrt:function(t){return i(t=+t)*Math.pow(Math.abs(t),1/3)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{clz32:function(t){return(t>>>=0)?31-Math.floor(Math.log(t+.5)*Math.LOG2E):32}})},function(t,n,r){var e=r(1),i=Math.exp;e(e.S,"Math",{cosh:function(t){return(i(t=+t)+i(-t))/2}})},function(t,n,r){var e=r(1),i=r(141);e(e.S+e.F*(i!=Math.expm1),"Math",{expm1:i})},function(t,n,r){var e=r(1),i=r(142),o=Math.pow,u=o(2,-52),c=o(2,-23),f=o(2,127)*(2-c),a=o(2,-126),s=function(t){return t+1/u-1/u};e(e.S,"Math",{fround:function(t){var n,r,e=Math.abs(t),o=i(t);return e<a?o*s(e/a/c)*a*c:(n=(1+c/u)*e,r=n-(n-e),r>f||r!=r?o*(1/0):o*r)}})},function(t,n,r){var e=r(1),i=Math.abs;e(e.S,"Math",{hypot:function(t,n){for(var r,e,o=0,u=0,c=arguments.length,f=0;u<c;)r=i(arguments[u++]),f<r?(e=f/r,o=o*e*e+1,f=r):r>0?(e=r/f,o+=e*e):o+=r;return f===1/0?1/0:f*Math.sqrt(o)}})},function(t,n,r){var e=r(1),i=Math.imul;e(e.S+e.F*r(4)(function(){return-5!=i(4294967295,5)||2!=i.length}),"Math",{imul:function(t,n){var r=65535,e=+t,i=+n,o=r&e,u=r&i;return 0|o*u+((r&e>>>16)*u+o*(r&i>>>16)<<16>>>0)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log10:function(t){return Math.log(t)/Math.LN10}})},function(t,n,r){var e=r(1);e(e.S,"Math",{log1p:r(171)})},function(t,n,r){var e=r(1);e(e.S,"Math",{log2:function(t){return Math.log(t)/Math.LN2}})},function(t,n,r){var e=r(1);e(e.S,"Math",{sign:r(142)})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S+e.F*r(4)(function(){return-2e-17!=!Math.sinh(-2e-17)}),"Math",{sinh:function(t){return Math.abs(t=+t)<1?(i(t)-i(-t))/2:(o(t-1)-o(-t-1))*(Math.E/2)}})},function(t,n,r){var e=r(1),i=r(141),o=Math.exp;e(e.S,"Math",{tanh:function(t){var n=i(t=+t),r=i(-t);return n==1/0?1:r==1/0?-1:(n-r)/(o(t)+o(-t))}})},function(t,n,r){var e=r(1);e(e.S,"Math",{trunc:function(t){return(t>0?Math.floor:Math.ceil)(t)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(45),u=r(136),c=r(50),f=r(4),a=r(71).f,s=r(31).f,l=r(11).f,h=r(82).trim,v="Number",p=e[v],d=p,y=p.prototype,g=o(r(70)(y))==v,b="trim"in String.prototype,m=function(t){var n=c(t,!1);if("string"==typeof n&&n.length>2){n=b?n.trim():h(n,3);var r,e,i,o=n.charCodeAt(0);if(43===o||45===o){if(88===(r=n.charCodeAt(2))||120===r)return NaN}else if(48===o){switch(n.charCodeAt(1)){case 66:case 98:e=2,i=49;break;case 79:case 111:e=8,i=55;break;default:return+n}for(var u,f=n.slice(2),a=0,s=f.length;a<s;a++)if((u=f.charCodeAt(a))<48||u>i)return NaN;return parseInt(f,e)}}return+n};if(!p(" 0o1")||!p("0b1")||p("+0x1")){p=function(t){var n=arguments.length<1?0:t,r=this;return r instanceof p&&(g?f(function(){y.valueOf.call(r)}):o(r)!=v)?u(new d(m(n)),r,p):m(n)};for(var x,w=r(10)?a(d):"MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger".split(","),S=0;w.length>S;S++)i(d,x=w[S])&&!i(p,x)&&l(p,x,s(d,x));p.prototype=y,y.constructor=p,r(28)(e,v,p)}},function(t,n,r){var e=r(1);e(e.S,"Number",{EPSILON:Math.pow(2,-52)})},function(t,n,r){var e=r(1),i=r(3).isFinite;e(e.S,"Number",{isFinite:function(t){return"number"==typeof t&&i(t)}})},function(t,n,r){var e=r(1);e(e.S,"Number",{isInteger:r(168)})},function(t,n,r){var e=r(1);e(e.S,"Number",{isNaN:function(t){return t!=t}})},function(t,n,r){var e=r(1),i=r(168),o=Math.abs;e(e.S,"Number",{isSafeInteger:function(t){return i(t)&&o(t)<=9007199254740991}})},function(t,n,r){var e=r(1);e(e.S,"Number",{MAX_SAFE_INTEGER:9007199254740991})},function(t,n,r){var e=r(1);e(e.S,"Number",{MIN_SAFE_INTEGER:-9007199254740991})},function(t,n,r){var e=r(1),i=r(178);e(e.S+e.F*(Number.parseFloat!=i),"Number",{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.S+e.F*(Number.parseInt!=i),"Number",{parseInt:i})},function(t,n,r){"use strict";var e=r(1),i=r(67),o=r(159),u=r(149),c=1..toFixed,f=Math.floor,a=[0,0,0,0,0,0],s="Number.toFixed: incorrect invocation!",l="0",h=function(t,n){for(var r=-1,e=n;++r<6;)e+=t*a[r],a[r]=e%1e7,e=f(e/1e7)},v=function(t){for(var n=6,r=0;--n>=0;)r+=a[n],a[n]=f(r/t),r=r%t*1e7},p=function(){for(var t=6,n="";--t>=0;)if(""!==n||0===t||0!==a[t]){var r=String(a[t]);n=""===n?r:n+u.call(l,7-r.length)+r}return n},d=function(t,n,r){return 0===n?r:n%2==1?d(t,n-1,r*t):d(t*t,n/2,r)},y=function(t){for(var n=0,r=t;r>=4096;)n+=12,r/=4096;for(;r>=2;)n+=1,r/=2;return n};e(e.P+e.F*(!!c&&("0.000"!==8e-5.toFixed(3)||"1"!==.9.toFixed(0)||"1.25"!==1.255.toFixed(2)||"1000000000000000128"!==(0xde0b6b3a7640080).toFixed(0))||!r(4)(function(){c.call({})})),"Number",{toFixed:function(t){var n,r,e,c,f=o(this,s),a=i(t),g="",b=l;if(a<0||a>20)throw RangeError(s);if(f!=f)return"NaN";if(f<=-1e21||f>=1e21)return String(f);if(f<0&&(g="-",f=-f),f>1e-21)if(n=y(f*d(2,69,1))-69,r=n<0?f*d(2,-n,1):f/d(2,n,1),r*=4503599627370496,(n=52-n)>0){for(h(0,r),e=a;e>=7;)h(1e7,0),e-=7;for(h(d(10,e,1),0),e=n-1;e>=23;)v(1<<23),e-=23;v(1<<e),h(1,1),v(2),b=p()}else h(0,r),h(1<<-n,0),b=p()+u.call(l,a);return a>0?(c=b.length,b=g+(c<=a?"0."+u.call(l,a-c)+b:b.slice(0,c-a)+"."+b.slice(c-a))):b=g+b,b}})},function(t,n,r){"use strict";var e=r(1),i=r(4),o=r(159),u=1..toPrecision;e(e.P+e.F*(i(function(){return"1"!==u.call(1,void 0)})||!i(function(){u.call({})})),"Number",{toPrecision:function(t){var n=o(this,"Number#toPrecision: incorrect invocation!");return void 0===t?u.call(n):u.call(n,t)}})},function(t,n,r){var e=r(1);e(e.S+e.F,"Object",{assign:r(172)})},function(t,n,r){var e=r(1);e(e.S,"Object",{create:r(70)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperties:r(173)})},function(t,n,r){var e=r(1);e(e.S+e.F*!r(10),"Object",{defineProperty:r(11).f})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("freeze",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(30),i=r(31).f;r(49)("getOwnPropertyDescriptor",function(){return function(t,n){return i(e(t),n)}})},function(t,n,r){r(49)("getOwnPropertyNames",function(){return r(174).f})},function(t,n,r){var e=r(17),i=r(32);r(49)("getPrototypeOf",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6);r(49)("isExtensible",function(t){return function(n){return!!e(n)&&(!t||t(n))}})},function(t,n,r){var e=r(6);r(49)("isFrozen",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(6);r(49)("isSealed",function(t){return function(n){return!e(n)||!!t&&t(n)}})},function(t,n,r){var e=r(1);e(e.S,"Object",{is:r(180)})},function(t,n,r){var e=r(17),i=r(72);r(49)("keys",function(){return function(t){return i(e(t))}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("preventExtensions",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(6),i=r(65).onFreeze;r(49)("seal",function(t){return function(n){return t&&e(n)?t(i(n)):n}})},function(t,n,r){var e=r(1);e(e.S,"Object",{setPrototypeOf:r(144).set})},function(t,n,r){"use strict";var e=r(114),i={};i[r(7)("toStringTag")]="z",i+""!="[object z]"&&r(28)(Object.prototype,"toString",function(){return"[object "+e(this)+"]"},!0)},function(t,n,r){var e=r(1),i=r(178);e(e.G+e.F*(parseFloat!=i),{parseFloat:i})},function(t,n,r){var e=r(1),i=r(179);e(e.G+e.F*(parseInt!=i),{parseInt:i})},function(t,n,r){"use strict";var e,i,o,u=r(69),c=r(3),f=r(53),a=r(114),s=r(1),l=r(6),h=r(26),v=r(68),p=r(79),d=r(146),y=r(151).set,g=r(143)(),b="Promise",m=c.TypeError,x=c.process,w=c[b],x=c.process,S="process"==a(x),_=function(){},O=!!function(){try{var t=w.resolve(1),n=(t.constructor={})[r(7)("species")]=function(t){t(_,_)};return(S||"function"==typeof PromiseRejectionEvent)&&t.then(_)instanceof n}catch(t){}}(),E=function(t,n){return t===n||t===w&&n===o},P=function(t){var n;return!(!l(t)||"function"!=typeof(n=t.then))&&n},j=function(t){return E(w,t)?new F(t):new i(t)},F=i=function(t){var n,r;this.promise=new t(function(t,e){if(void 0!==n||void 0!==r)throw m("Bad Promise constructor");n=t,r=e}),this.resolve=h(n),this.reject=h(r)},M=function(t){try{t()}catch(t){return{error:t}}},A=function(t,n){if(!t._n){t._n=!0;var r=t._c;g(function(){for(var e=t._v,i=1==t._s,o=0;r.length>o;)!function(n){var r,o,u=i?n.ok:n.fail,c=n.resolve,f=n.reject,a=n.domain;try{u?(i||(2==t._h&&I(t),t._h=1),!0===u?r=e:(a&&a.enter(),r=u(e),a&&a.exit()),r===n.promise?f(m("Promise-chain cycle")):(o=P(r))?o.call(r,c,f):c(r)):f(e)}catch(t){f(t)}}(r[o++]);t._c=[],t._n=!1,n&&!t._h&&N(t)})}},N=function(t){y.call(c,function(){var n,r,e,i=t._v;if(T(t)&&(n=M(function(){S?x.emit("unhandledRejection",i,t):(r=c.onunhandledrejection)?r({promise:t,reason:i}):(e=c.console)&&e.error&&e.error("Unhandled promise rejection",i)}),t._h=S||T(t)?2:1),t._a=void 0,n)throw n.error})},T=function(t){if(1==t._h)return!1;for(var n,r=t._a||t._c,e=0;r.length>e;)if(n=r[e++],n.fail||!T(n.promise))return!1;return!0},I=function(t){y.call(c,function(){var n;S?x.emit("rejectionHandled",t):(n=c.onrejectionhandled)&&n({promise:t,reason:t._v})})},k=function(t){var n=this;n._d||(n._d=!0,n=n._w||n,n._v=t,n._s=2,n._a||(n._a=n._c.slice()),A(n,!0))},L=function(t){var n,r=this;if(!r._d){r._d=!0,r=r._w||r;try{if(r===t)throw m("Promise can't be resolved itself");(n=P(t))?g(function(){var e={_w:r,_d:!1};try{n.call(t,f(L,e,1),f(k,e,1))}catch(t){k.call(e,t)}}):(r._v=t,r._s=1,A(r,!1))}catch(t){k.call({_w:r,_d:!1},t)}}};O||(w=function(t){v(this,w,b,"_h"),h(t),e.call(this);try{t(f(L,this,1),f(k,this,1))}catch(t){k.call(this,t)}},e=function(t){this._c=[],this._a=void 0,this._s=0,this._d=!1,this._v=void 0,this._h=0,this._n=!1},e.prototype=r(73)(w.prototype,{then:function(t,n){var r=j(d(this,w));return r.ok="function"!=typeof t||t,r.fail="function"==typeof n&&n,r.domain=S?x.domain:void 0,this._c.push(r),this._a&&this._a.push(r),this._s&&A(this,!1),r.promise},catch:function(t){return this.then(void 0,t)}}),F=function(){var t=new e;this.promise=t,this.resolve=f(L,t,1),this.reject=f(k,t,1)}),s(s.G+s.W+s.F*!O,{Promise:w}),r(81)(w,b),r(74)(b),o=r(52)[b],s(s.S+s.F*!O,b,{reject:function(t){var n=j(this);return(0,n.reject)(t),n.promise}}),s(s.S+s.F*(u||!O),b,{resolve:function(t){if(t instanceof w&&E(t.constructor,this))return t;var n=j(this);return(0,n.resolve)(t),n.promise}}),s(s.S+s.F*!(O&&r(123)(function(t){w.all(t).catch(_)})),b,{all:function(t){var n=this,r=j(n),e=r.resolve,i=r.reject,o=M(function(){var r=[],o=0,u=1;p(t,!1,function(t){var c=o++,f=!1;r.push(void 0),u++,n.resolve(t).then(function(t){f||(f=!0,r[c]=t,--u||e(r))},i)}),--u||e(r)});return o&&i(o.error),r.promise},race:function(t){var n=this,r=j(n),e=r.reject,i=M(function(){p(t,!1,function(t){n.resolve(t).then(r.resolve,e)})});return i&&e(i.error),r.promise}})},function(t,n,r){var e=r(1),i=r(26),o=r(2),u=(r(3).Reflect||{}).apply,c=Function.apply;e(e.S+e.F*!r(4)(function(){u(function(){})}),"Reflect",{apply:function(t,n,r){var e=i(t),f=o(r);return u?u(e,n,f):c.call(e,n,f)}})},function(t,n,r){var e=r(1),i=r(70),o=r(26),u=r(2),c=r(6),f=r(4),a=r(163),s=(r(3).Reflect||{}).construct,l=f(function(){function t(){}return!(s(function(){},[],t)instanceof t)}),h=!f(function(){s(function(){})});e(e.S+e.F*(l||h),"Reflect",{construct:function(t,n){o(t),u(n);var r=arguments.length<3?t:o(arguments[2]);if(h&&!l)return s(t,n,r);if(t==r){switch(n.length){case 0:return new t;case 1:return new t(n[0]);case 2:return new t(n[0],n[1]);case 3:return new t(n[0],n[1],n[2]);case 4:return new t(n[0],n[1],n[2],n[3])}var e=[null];return e.push.apply(e,n),new(a.apply(t,e))}var f=r.prototype,v=i(c(f)?f:Object.prototype),p=Function.apply.call(t,v,n);return c(p)?p:v}})},function(t,n,r){var e=r(11),i=r(1),o=r(2),u=r(50);i(i.S+i.F*r(4)(function(){Reflect.defineProperty(e.f({},1,{value:1}),1,{value:2})}),"Reflect",{defineProperty:function(t,n,r){o(t),n=u(n,!0),o(r);try{return e.f(t,n,r),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(31).f,o=r(2);e(e.S,"Reflect",{deleteProperty:function(t,n){var r=i(o(t),n);return!(r&&!r.configurable)&&delete t[n]}})},function(t,n,r){"use strict";var e=r(1),i=r(2),o=function(t){this._t=i(t),this._i=0;var n,r=this._k=[];for(n in t)r.push(n)};r(139)(o,"Object",function(){var t,n=this,r=n._k;do{if(n._i>=r.length)return{value:void 0,done:!0}}while(!((t=r[n._i++])in n._t));return{value:t,done:!1}}),e(e.S,"Reflect",{enumerate:function(t){return new o(t)}})},function(t,n,r){var e=r(31),i=r(1),o=r(2);i(i.S,"Reflect",{getOwnPropertyDescriptor:function(t,n){return e.f(o(t),n)}})},function(t,n,r){var e=r(1),i=r(32),o=r(2);e(e.S,"Reflect",{getPrototypeOf:function(t){return i(o(t))}})},function(t,n,r){function e(t,n){var r,c,s=arguments.length<3?t:arguments[2];return a(t)===s?t[n]:(r=i.f(t,n))?u(r,"value")?r.value:void 0!==r.get?r.get.call(s):void 0:f(c=o(t))?e(c,n,s):void 0}var i=r(31),o=r(32),u=r(24),c=r(1),f=r(6),a=r(2);c(c.S,"Reflect",{get:e})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{has:function(t,n){return n in t}})},function(t,n,r){var e=r(1),i=r(2),o=Object.isExtensible;e(e.S,"Reflect",{isExtensible:function(t){return i(t),!o||o(t)}})},function(t,n,r){var e=r(1);e(e.S,"Reflect",{ownKeys:r(177)})},function(t,n,r){var e=r(1),i=r(2),o=Object.preventExtensions;e(e.S,"Reflect",{preventExtensions:function(t){i(t);try{return o&&o(t),!0}catch(t){return!1}}})},function(t,n,r){var e=r(1),i=r(144);i&&e(e.S,"Reflect",{setPrototypeOf:function(t,n){i.check(t,n);try{return i.set(t,n),!0}catch(t){return!1}}})},function(t,n,r){function e(t,n,r){var f,h,v=arguments.length<4?t:arguments[3],p=o.f(s(t),n);if(!p){if(l(h=u(t)))return e(h,n,r,v);p=a(0)}return c(p,"value")?!(!1===p.writable||!l(v)||(f=o.f(v,n)||a(0),f.value=r,i.f(v,n,f),0)):void 0!==p.set&&(p.set.call(v,r),!0)}var i=r(11),o=r(31),u=r(32),c=r(24),f=r(1),a=r(66),s=r(2),l=r(6);f(f.S,"Reflect",{set:e})},function(t,n,r){var e=r(3),i=r(136),o=r(11).f,u=r(71).f,c=r(122),f=r(120),a=e.RegExp,s=a,l=a.prototype,h=/a/g,v=/a/g,p=new a(h)!==h;if(r(10)&&(!p||r(4)(function(){return v[r(7)("match")]=!1,a(h)!=h||a(v)==v||"/a/i"!=a(h,"i")}))){a=function(t,n){var r=this instanceof a,e=c(t),o=void 0===n;return!r&&e&&t.constructor===a&&o?t:i(p?new s(e&&!o?t.source:t,n):s((e=t instanceof a)?t.source:t,e&&o?f.call(t):n),r?this:l,a)};for(var d=u(s),y=0;d.length>y;)!function(t){t in a||o(a,t,{configurable:!0,get:function(){return s[t]},set:function(n){s[t]=n}})}(d[y++]);l.constructor=a,a.prototype=l,r(28)(e,"RegExp",a)}r(74)("RegExp")},function(t,n,r){r(119)("match",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("replace",2,function(t,n,r){return[function(e,i){"use strict";var o=t(this),u=void 0==e?void 0:e[n];return void 0!==u?u.call(e,o,i):r.call(String(o),e,i)},r]})},function(t,n,r){r(119)("search",1,function(t,n,r){return[function(r){"use strict";var e=t(this),i=void 0==r?void 0:r[n];return void 0!==i?i.call(r,e):new RegExp(r)[n](String(e))},r]})},function(t,n,r){r(119)("split",2,function(t,n,e){"use strict";var i=r(122),o=e,u=[].push,c="split",f="length",a="lastIndex";if("c"=="abbc"[c](/(b)*/)[1]||4!="test"[c](/(?:)/,-1)[f]||2!="ab"[c](/(?:ab)*/)[f]||4!="."[c](/(.?)(.?)/)[f]||"."[c](/()()/)[f]>1||""[c](/.?/)[f]){var s=void 0===/()??/.exec("")[1];e=function(t,n){var r=String(this);if(void 0===t&&0===n)return[];if(!i(t))return o.call(r,t,n);var e,c,l,h,v,p=[],d=(t.ignoreCase?"i":"")+(t.multiline?"m":"")+(t.unicode?"u":"")+(t.sticky?"y":""),y=0,g=void 0===n?4294967295:n>>>0,b=new RegExp(t.source,d+"g");for(s||(e=new RegExp("^"+b.source+"$(?!\\s)",d));(c=b.exec(r))&&!((l=c.index+c[0][f])>y&&(p.push(r.slice(y,c.index)),!s&&c[f]>1&&c[0].replace(e,function(){for(v=1;v<arguments[f]-2;v++)void 0===arguments[v]&&(c[v]=void 0)}),c[f]>1&&c.index<r[f]&&u.apply(p,c.slice(1)),h=c[0][f],y=l,p[f]>=g));)b[a]===c.index&&b[a]++;return y===r[f]?!h&&b.test("")||p.push(""):p.push(r.slice(y)),p[f]>g?p.slice(0,g):p}}else"0"[c](void 0,0)[f]&&(e=function(t,n){return void 0===t&&0===n?[]:o.call(this,t,n)});return[function(r,i){var o=t(this),u=void 0==r?void 0:r[n];return void 0!==u?u.call(r,o,i):e.call(String(o),r,i)},e]})},function(t,n,r){"use strict";r(184);var e=r(2),i=r(120),o=r(10),u="toString",c=/./[u],f=function(t){r(28)(RegExp.prototype,u,t,!0)};r(4)(function(){return"/a/b"!=c.call({source:"a",flags:"b"})})?f(function(){var t=e(this);return"/".concat(t.source,"/","flags"in t?t.flags:!o&&t instanceof RegExp?i.call(t):void 0)}):c.name!=u&&f(function(){return c.call(this)})},function(t,n,r){"use strict";r(29)("anchor",function(t){return function(n){return t(this,"a","name",n)}})},function(t,n,r){"use strict";r(29)("big",function(t){return function(){return t(this,"big","","")}})},function(t,n,r){"use strict";r(29)("blink",function(t){return function(){return t(this,"blink","","")}})},function(t,n,r){"use strict";r(29)("bold",function(t){return function(){return t(this,"b","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!1);e(e.P,"String",{codePointAt:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="endsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{endsWith:function(t){var n=o(this,t,u),r=arguments.length>1?arguments[1]:void 0,e=i(n.length),f=void 0===r?e:Math.min(i(r),e),a=String(t);return c?c.call(n,a,f):n.slice(f-a.length,f)===a}})},function(t,n,r){"use strict";r(29)("fixed",function(t){return function(){return t(this,"tt","","")}})},function(t,n,r){"use strict";r(29)("fontcolor",function(t){return function(n){return t(this,"font","color",n)}})},function(t,n,r){"use strict";r(29)("fontsize",function(t){return function(n){return t(this,"font","size",n)}})},function(t,n,r){var e=r(1),i=r(75),o=String.fromCharCode,u=String.fromCodePoint;e(e.S+e.F*(!!u&&1!=u.length),"String",{fromCodePoint:function(t){for(var n,r=[],e=arguments.length,u=0;e>u;){if(n=+arguments[u++],i(n,1114111)!==n)throw RangeError(n+" is not a valid code point");r.push(n<65536?o(n):o(55296+((n-=65536)>>10),n%1024+56320))}return r.join("")}})},function(t,n,r){"use strict";var e=r(1),i=r(148),o="includes";e(e.P+e.F*r(134)(o),"String",{includes:function(t){return!!~i(this,t,o).indexOf(t,arguments.length>1?arguments[1]:void 0)}})},function(t,n,r){"use strict";r(29)("italics",function(t){return function(){return t(this,"i","","")}})},function(t,n,r){"use strict";var e=r(147)(!0);r(140)(String,"String",function(t){this._t=String(t),this._i=0},function(){var t,n=this._t,r=this._i;return r>=n.length?{value:void 0,done:!0}:(t=e(n,r),this._i+=t.length,{value:t,done:!1})})},function(t,n,r){"use strict";r(29)("link",function(t){return function(n){return t(this,"a","href",n)}})},function(t,n,r){var e=r(1),i=r(30),o=r(16);e(e.S,"String",{raw:function(t){for(var n=i(t.raw),r=o(n.length),e=arguments.length,u=[],c=0;r>c;)u.push(String(n[c++])),c<e&&u.push(String(arguments[c]));return u.join("")}})},function(t,n,r){var e=r(1);e(e.P,"String",{repeat:r(149)})},function(t,n,r){"use strict";r(29)("small",function(t){return function(){return t(this,"small","","")}})},function(t,n,r){"use strict";var e=r(1),i=r(16),o=r(148),u="startsWith",c=""[u];e(e.P+e.F*r(134)(u),"String",{startsWith:function(t){var n=o(this,t,u),r=i(Math.min(arguments.length>1?arguments[1]:void 0,n.length)),e=String(t);return c?c.call(n,e,r):n.slice(r,r+e.length)===e}})},function(t,n,r){"use strict";r(29)("strike",function(t){return function(){return t(this,"strike","","")}})},function(t,n,r){"use strict";r(29)("sub",function(t){return function(){return t(this,"sub","","")}})},function(t,n,r){"use strict";r(29)("sup",function(t){return function(){return t(this,"sup","","")}})},function(t,n,r){"use strict";r(82)("trim",function(t){return function(){return t(this,3)}})},function(t,n,r){"use strict";var e=r(3),i=r(24),o=r(10),u=r(1),c=r(28),f=r(65).KEY,a=r(4),s=r(126),l=r(81),h=r(76),v=r(7),p=r(182),d=r(153),y=r(206),g=r(205),b=r(138),m=r(2),x=r(30),w=r(50),S=r(66),_=r(70),O=r(174),E=r(31),P=r(11),j=r(72),F=E.f,M=P.f,A=O.f,N=e.Symbol,T=e.JSON,I=T&&T.stringify,k="prototype",L=v("_hidden"),R=v("toPrimitive"),C={}.propertyIsEnumerable,D=s("symbol-registry"),U=s("symbols"),W=s("op-symbols"),G=Object[k],B="function"==typeof N,V=e.QObject,z=!V||!V[k]||!V[k].findChild,q=o&&a(function(){return 7!=_(M({},"a",{get:function(){return M(this,"a",{value:7}).a}})).a})?function(t,n,r){var e=F(G,n);e&&delete G[n],M(t,n,r),e&&t!==G&&M(G,n,e)}:M,K=function(t){var n=U[t]=_(N[k]);return n._k=t,n},J=B&&"symbol"==typeof N.iterator?function(t){return"symbol"==typeof t}:function(t){return t instanceof N},Y=function(t,n,r){return t===G&&Y(W,n,r),m(t),n=w(n,!0),m(r),i(U,n)?(r.enumerable?(i(t,L)&&t[L][n]&&(t[L][n]=!1),r=_(r,{enumerable:S(0,!1)})):(i(t,L)||M(t,L,S(1,{})),t[L][n]=!0),q(t,n,r)):M(t,n,r)},H=function(t,n){m(t);for(var r,e=g(n=x(n)),i=0,o=e.length;o>i;)Y(t,r=e[i++],n[r]);return t},$=function(t,n){return void 0===n?_(t):H(_(t),n)},X=function(t){var n=C.call(this,t=w(t,!0));return!(this===G&&i(U,t)&&!i(W,t))&&(!(n||!i(this,t)||!i(U,t)||i(this,L)&&this[L][t])||n)},Q=function(t,n){if(t=x(t),n=w(n,!0),t!==G||!i(U,n)||i(W,n)){var r=F(t,n);return!r||!i(U,n)||i(t,L)&&t[L][n]||(r.enumerable=!0),r}},Z=function(t){for(var n,r=A(x(t)),e=[],o=0;r.length>o;)i(U,n=r[o++])||n==L||n==f||e.push(n);return e},tt=function(t){for(var n,r=t===G,e=A(r?W:x(t)),o=[],u=0;e.length>u;)!i(U,n=e[u++])||r&&!i(G,n)||o.push(U[n]);return o};B||(N=function(){if(this instanceof N)throw TypeError("Symbol is not a constructor!");var t=h(arguments.length>0?arguments[0]:void 0),n=function(r){this===G&&n.call(W,r),i(this,L)&&i(this[L],t)&&(this[L][t]=!1),q(this,t,S(1,r))};return o&&z&&q(G,t,{configurable:!0,set:n}),K(t)},c(N[k],"toString",function(){return this._k}),E.f=Q,P.f=Y,r(71).f=O.f=Z,r(116).f=X,r(125).f=tt,o&&!r(69)&&c(G,"propertyIsEnumerable",X,!0),p.f=function(t){return K(v(t))}),u(u.G+u.W+u.F*!B,{Symbol:N});for(var nt="hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables".split(","),rt=0;nt.length>rt;)v(nt[rt++]);for(var nt=j(v.store),rt=0;nt.length>rt;)d(nt[rt++]);u(u.S+u.F*!B,"Symbol",{for:function(t){return i(D,t+="")?D[t]:D[t]=N(t)},keyFor:function(t){if(J(t))return y(D,t);throw TypeError(t+" is not a symbol!")},useSetter:function(){z=!0},useSimple:function(){z=!1}}),u(u.S+u.F*!B,"Object",{create:$,defineProperty:Y,defineProperties:H,getOwnPropertyDescriptor:Q,getOwnPropertyNames:Z,getOwnPropertySymbols:tt}),T&&u(u.S+u.F*(!B||a(function(){var t=N();return"[null]"!=I([t])||"{}"!=I({a:t})||"{}"!=I(Object(t))})),"JSON",{stringify:function(t){if(void 0!==t&&!J(t)){for(var n,r,e=[t],i=1;arguments.length>i;)e.push(arguments[i++]);return n=e[1],"function"==typeof n&&(r=n),!r&&b(n)||(n=function(t,n){if(r&&(n=r.call(this,t,n)),!J(n))return n}),e[1]=n,I.apply(T,e)}}}),N[k][R]||r(27)(N[k],R,N[k].valueOf),l(N,"Symbol"),l(Math,"Math",!0),l(e.JSON,"JSON",!0)},function(t,n,r){"use strict";var e=r(1),i=r(127),o=r(152),u=r(2),c=r(75),f=r(16),a=r(6),s=r(3).ArrayBuffer,l=r(146),h=o.ArrayBuffer,v=o.DataView,p=i.ABV&&s.isView,d=h.prototype.slice,y=i.VIEW,g="ArrayBuffer";e(e.G+e.W+e.F*(s!==h),{ArrayBuffer:h}),e(e.S+e.F*!i.CONSTR,g,{isView:function(t){return p&&p(t)||a(t)&&y in t}}),e(e.P+e.U+e.F*r(4)(function(){return!new h(2).slice(1,void 0).byteLength}),g,{slice:function(t,n){if(void 0!==d&&void 0===n)return d.call(u(this),t);for(var r=u(this).byteLength,e=c(t,r),i=c(void 0===n?r:n,r),o=new(l(this,h))(f(i-e)),a=new v(this),s=new v(o),p=0;e<i;)s.setUint8(p++,a.getUint8(e++));return o}}),r(74)(g)},function(t,n,r){var e=r(1);e(e.G+e.W+e.F*!r(127).ABV,{DataView:r(152).DataView})},function(t,n,r){r(55)("Float32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Float64",8,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Int8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint16",2,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint32",4,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}})},function(t,n,r){r(55)("Uint8",1,function(t){return function(n,r,e){return t(this,n,r,e)}},!0)},function(t,n,r){"use strict";var e=r(166);r(118)("WeakSet",function(t){return function(){return t(this,arguments.length>0?arguments[0]:void 0)}},{add:function(t){return e.def(this,t,!0)}},e,!1,!0)},function(t,n,r){"use strict";var e=r(1),i=r(117)(!0);e(e.P,"Array",{includes:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0)}}),r(78)("includes")},function(t,n,r){var e=r(1),i=r(143)(),o=r(3).process,u="process"==r(45)(o);e(e.G,{asap:function(t){var n=u&&o.domain;i(n?n.bind(t):t)}})},function(t,n,r){var e=r(1),i=r(45);e(e.S,"Error",{isError:function(t){return"Error"===i(t)}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Map",{toJSON:r(165)("Map")})},function(t,n,r){var e=r(1);e(e.S,"Math",{iaddh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o+(e>>>0)+((i&u|(i|u)&~(i+u>>>0))>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{imulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>16,f=i>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>16)+((o*f>>>0)+(a&r)>>16)}})},function(t,n,r){var e=r(1);e(e.S,"Math",{isubh:function(t,n,r,e){var i=t>>>0,o=n>>>0,u=r>>>0;return o-(e>>>0)-((~i&u|~(i^u)&i-u>>>0)>>>31)|0}})},function(t,n,r){var e=r(1);e(e.S,"Math",{umulh:function(t,n){var r=65535,e=+t,i=+n,o=e&r,u=i&r,c=e>>>16,f=i>>>16,a=(c*u>>>0)+(o*u>>>16);return c*f+(a>>>16)+((o*f>>>0)+(a&r)>>>16)}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineGetter__:function(t,n){u.f(i(this),t,{get:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(26),u=r(11);r(10)&&e(e.P+r(124),"Object",{__defineSetter__:function(t,n){u.f(i(this),t,{set:o(n),enumerable:!0,configurable:!0})}})},function(t,n,r){var e=r(1),i=r(176)(!0);e(e.S,"Object",{entries:function(t){return i(t)}})},function(t,n,r){var e=r(1),i=r(177),o=r(30),u=r(31),c=r(131);e(e.S,"Object",{getOwnPropertyDescriptors:function(t){for(var n,r=o(t),e=u.f,f=i(r),a={},s=0;f.length>s;)c(a,n=f[s++],e(r,n));return a}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupGetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.get}while(r=u(r))}})},function(t,n,r){"use strict";var e=r(1),i=r(17),o=r(50),u=r(32),c=r(31).f;r(10)&&e(e.P+r(124),"Object",{__lookupSetter__:function(t){var n,r=i(this),e=o(t,!0);do{if(n=c(r,e))return n.set}while(r=u(r))}})},function(t,n,r){var e=r(1),i=r(176)(!1);e(e.S,"Object",{values:function(t){return i(t)}})},function(t,n,r){"use strict";var e=r(1),i=r(3),o=r(52),u=r(143)(),c=r(7)("observable"),f=r(26),a=r(2),s=r(68),l=r(73),h=r(27),v=r(79),p=v.RETURN,d=function(t){return null==t?void 0:f(t)},y=function(t){var n=t._c;n&&(t._c=void 0,n())},g=function(t){return void 0===t._o},b=function(t){g(t)||(t._o=void 0,y(t))},m=function(t,n){a(t),this._c=void 0,this._o=t,t=new x(this);try{var r=n(t),e=r;null!=r&&("function"==typeof r.unsubscribe?r=function(){e.unsubscribe()}:f(r),this._c=r)}catch(n){return void t.error(n)}g(this)&&y(this)};m.prototype=l({},{unsubscribe:function(){b(this)}});var x=function(t){this._s=t};x.prototype=l({},{next:function(t){var n=this._s;if(!g(n)){var r=n._o;try{var e=d(r.next);if(e)return e.call(r,t)}catch(t){try{b(n)}finally{throw t}}}},error:function(t){var n=this._s;if(g(n))throw t;var r=n._o;n._o=void 0;try{var e=d(r.error);if(!e)throw t;t=e.call(r,t)}catch(t){try{y(n)}finally{throw t}}return y(n),t},complete:function(t){var n=this._s;if(!g(n)){var r=n._o;n._o=void 0;try{var e=d(r.complete);t=e?e.call(r,t):void 0}catch(t){try{y(n)}finally{throw t}}return y(n),t}}});var w=function(t){s(this,w,"Observable","_f")._f=f(t)};l(w.prototype,{subscribe:function(t){return new m(t,this._f)},forEach:function(t){var n=this;return new(o.Promise||i.Promise)(function(r,e){f(t);var i=n.subscribe({next:function(n){try{return t(n)}catch(t){e(t),i.unsubscribe()}},error:e,complete:r})})}}),l(w,{from:function(t){var n="function"==typeof this?this:w,r=d(a(t)[c]);if(r){var e=a(r.call(t));return e.constructor===n?e:new n(function(t){return e.subscribe(t)})}return new n(function(n){var r=!1;return u(function(){if(!r){try{if(v(t,!1,function(t){if(n.next(t),r)return p})===p)return}catch(t){if(r)throw t;return void n.error(t)}n.complete()}}),function(){r=!0}})},of:function(){for(var t=0,n=arguments.length,r=Array(n);t<n;)r[t]=arguments[t++];return new("function"==typeof this?this:w)(function(t){var n=!1;return u(function(){if(!n){for(var e=0;e<r.length;++e)if(t.next(r[e]),n)return;t.complete()}}),function(){n=!0}})}}),h(w.prototype,c,function(){return this}),e(e.G,{Observable:w}),r(74)("Observable")},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.set;e.exp({defineMetadata:function(t,n,r,e){u(t,n,i(r),o(e))}})},function(t,n,r){var e=r(54),i=r(2),o=e.key,u=e.map,c=e.store;e.exp({deleteMetadata:function(t,n){var r=arguments.length<3?void 0:o(arguments[2]),e=u(i(n),r,!1);if(void 0===e||!e.delete(t))return!1;if(e.size)return!0;var f=c.get(n);return f.delete(r),!!f.size||c.delete(n)}})},function(t,n,r){var e=r(185),i=r(161),o=r(54),u=r(2),c=r(32),f=o.keys,a=o.key,s=function(t,n){var r=f(t,n),o=c(t);if(null===o)return r;var u=s(o,n);return u.length?r.length?i(new e(r.concat(u))):u:r};o.exp({getMetadataKeys:function(t){return s(u(t),arguments.length<2?void 0:a(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.get,f=e.key,a=function(t,n,r){if(u(t,n,r))return c(t,n,r);var e=o(n);return null!==e?a(t,e,r):void 0};e.exp({getMetadata:function(t,n){return a(t,i(n),arguments.length<3?void 0:f(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.keys,u=e.key;e.exp({getOwnMetadataKeys:function(t){
return o(i(t),arguments.length<2?void 0:u(arguments[1]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.get,u=e.key;e.exp({getOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(32),u=e.has,c=e.key,f=function(t,n,r){if(u(t,n,r))return!0;var e=o(n);return null!==e&&f(t,e,r)};e.exp({hasMetadata:function(t,n){return f(t,i(n),arguments.length<3?void 0:c(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=e.has,u=e.key;e.exp({hasOwnMetadata:function(t,n){return o(t,i(n),arguments.length<3?void 0:u(arguments[2]))}})},function(t,n,r){var e=r(54),i=r(2),o=r(26),u=e.key,c=e.set;e.exp({metadata:function(t,n){return function(r,e){c(t,n,(void 0!==e?i:o)(r),u(e))}}})},function(t,n,r){var e=r(1);e(e.P+e.R,"Set",{toJSON:r(165)("Set")})},function(t,n,r){"use strict";var e=r(1),i=r(147)(!0);e(e.P,"String",{at:function(t){return i(this,t)}})},function(t,n,r){"use strict";var e=r(1),i=r(46),o=r(16),u=r(122),c=r(120),f=RegExp.prototype,a=function(t,n){this._r=t,this._s=n};r(139)(a,"RegExp String",function(){var t=this._r.exec(this._s);return{value:t,done:null===t}}),e(e.P,"String",{matchAll:function(t){if(i(this),!u(t))throw TypeError(t+" is not a regexp!");var n=String(this),r="flags"in f?String(t.flags):c.call(t),e=new RegExp(t.source,~r.indexOf("g")?r:"g"+r);return e.lastIndex=o(t.lastIndex),new a(e,n)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padEnd:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!1)}})},function(t,n,r){"use strict";var e=r(1),i=r(181);e(e.P,"String",{padStart:function(t){return i(this,t,arguments.length>1?arguments[1]:void 0,!0)}})},function(t,n,r){"use strict";r(82)("trimLeft",function(t){return function(){return t(this,1)}},"trimStart")},function(t,n,r){"use strict";r(82)("trimRight",function(t){return function(){return t(this,2)}},"trimEnd")},function(t,n,r){r(153)("asyncIterator")},function(t,n,r){r(153)("observable")},function(t,n,r){var e=r(1);e(e.S,"System",{global:r(3)})},function(t,n,r){for(var e=r(155),i=r(28),o=r(3),u=r(27),c=r(80),f=r(7),a=f("iterator"),s=f("toStringTag"),l=c.Array,h=["NodeList","DOMTokenList","MediaList","StyleSheetList","CSSRuleList"],v=0;v<5;v++){var p,d=h[v],y=o[d],g=y&&y.prototype;if(g){g[a]||u(g,a,l),g[s]||u(g,s,d),c[d]=l;for(p in e)g[p]||i(g,p,e[p],!0)}}},function(t,n,r){var e=r(1),i=r(151);e(e.G+e.B,{setImmediate:i.set,clearImmediate:i.clear})},function(t,n,r){var e=r(3),i=r(1),o=r(121),u=r(207),c=e.navigator,f=!!c&&/MSIE .\./.test(c.userAgent),a=function(t){return f?function(n,r){return t(o(u,[].slice.call(arguments,2),"function"==typeof n?n:Function(n)),r)}:t};i(i.G+i.B+i.F*f,{setTimeout:a(e.setTimeout),setInterval:a(e.setInterval)})},function(t,n,r){r(330),r(269),r(271),r(270),r(273),r(275),r(280),r(274),r(272),r(282),r(281),r(277),r(278),r(276),r(268),r(279),r(283),r(284),r(236),r(238),r(237),r(286),r(285),r(256),r(266),r(267),r(257),r(258),r(259),r(260),r(261),r(262),r(263),r(264),r(265),r(239),r(240),r(241),r(242),r(243),r(244),r(245),r(246),r(247),r(248),r(249),r(250),r(251),r(252),r(253),r(254),r(255),r(317),r(322),r(329),r(320),r(312),r(313),r(318),r(323),r(325),r(308),r(309),r(310),r(311),r(314),r(315),r(316),r(319),r(321),r(324),r(326),r(327),r(328),r(231),r(233),r(232),r(235),r(234),r(220),r(218),r(224),r(221),r(227),r(229),r(217),r(223),r(214),r(228),r(212),r(226),r(225),r(219),r(222),r(211),r(213),r(216),r(215),r(230),r(155),r(302),r(307),r(184),r(303),r(304),r(305),r(306),r(287),r(183),r(185),r(186),r(342),r(331),r(332),r(337),r(340),r(341),r(335),r(338),r(336),r(339),r(333),r(334),r(288),r(289),r(290),r(291),r(292),r(295),r(293),r(294),r(296),r(297),r(298),r(299),r(301),r(300),r(343),r(369),r(372),r(371),r(373),r(374),r(370),r(375),r(376),r(354),r(357),r(353),r(351),r(352),r(355),r(356),r(346),r(368),r(377),r(345),r(347),r(349),r(348),r(350),r(359),r(360),r(362),r(361),r(364),r(363),r(365),r(366),r(367),r(344),r(358),r(380),r(379),r(378),t.exports=r(52)},function(t,n){function r(t,n){if("string"==typeof n)return t.insertAdjacentHTML("afterend",n);var r=t.nextSibling;return r?t.parentNode.insertBefore(n,r):t.parentNode.appendChild(n)}t.exports=r},,,,,,,,,function(t,n,r){(function(n,r){!function(n){"use strict";function e(t,n,r,e){var i=n&&n.prototype instanceof o?n:o,u=Object.create(i.prototype),c=new p(e||[]);return u._invoke=s(t,r,c),u}function i(t,n,r){try{return{type:"normal",arg:t.call(n,r)}}catch(t){return{type:"throw",arg:t}}}function o(){}function u(){}function c(){}function f(t){["next","throw","return"].forEach(function(n){t[n]=function(t){return this._invoke(n,t)}})}function a(t){function n(r,e,o,u){var c=i(t[r],t,e);if("throw"!==c.type){var f=c.arg,a=f.value;return a&&"object"==typeof a&&m.call(a,"__await")?Promise.resolve(a.__await).then(function(t){n("next",t,o,u)},function(t){n("throw",t,o,u)}):Promise.resolve(a).then(function(t){f.value=t,o(f)},u)}u(c.arg)}function e(t,r){function e(){return new Promise(function(e,i){n(t,r,e,i)})}return o=o?o.then(e,e):e()}"object"==typeof r&&r.domain&&(n=r.domain.bind(n));var o;this._invoke=e}function s(t,n,r){var e=P;return function(o,u){if(e===F)throw new Error("Generator is already running");if(e===M){if("throw"===o)throw u;return y()}for(r.method=o,r.arg=u;;){var c=r.delegate;if(c){var f=l(c,r);if(f){if(f===A)continue;return f}}if("next"===r.method)r.sent=r._sent=r.arg;else if("throw"===r.method){if(e===P)throw e=M,r.arg;r.dispatchException(r.arg)}else"return"===r.method&&r.abrupt("return",r.arg);e=F;var a=i(t,n,r);if("normal"===a.type){if(e=r.done?M:j,a.arg===A)continue;return{value:a.arg,done:r.done}}"throw"===a.type&&(e=M,r.method="throw",r.arg=a.arg)}}}function l(t,n){var r=t.iterator[n.method];if(r===g){if(n.delegate=null,"throw"===n.method){if(t.iterator.return&&(n.method="return",n.arg=g,l(t,n),"throw"===n.method))return A;n.method="throw",n.arg=new TypeError("The iterator does not provide a 'throw' method")}return A}var e=i(r,t.iterator,n.arg);if("throw"===e.type)return n.method="throw",n.arg=e.arg,n.delegate=null,A;var o=e.arg;return o?o.done?(n[t.resultName]=o.value,n.next=t.nextLoc,"return"!==n.method&&(n.method="next",n.arg=g),n.delegate=null,A):o:(n.method="throw",n.arg=new TypeError("iterator result is not an object"),n.delegate=null,A)}function h(t){var n={tryLoc:t[0]};1 in t&&(n.catchLoc=t[1]),2 in t&&(n.finallyLoc=t[2],n.afterLoc=t[3]),this.tryEntries.push(n)}function v(t){var n=t.completion||{};n.type="normal",delete n.arg,t.completion=n}function p(t){this.tryEntries=[{tryLoc:"root"}],t.forEach(h,this),this.reset(!0)}function d(t){if(t){var n=t[w];if(n)return n.call(t);if("function"==typeof t.next)return t;if(!isNaN(t.length)){var r=-1,e=function n(){for(;++r<t.length;)if(m.call(t,r))return n.value=t[r],n.done=!1,n;return n.value=g,n.done=!0,n};return e.next=e}}return{next:y}}function y(){return{value:g,done:!0}}var g,b=Object.prototype,m=b.hasOwnProperty,x="function"==typeof Symbol?Symbol:{},w=x.iterator||"@@iterator",S=x.asyncIterator||"@@asyncIterator",_=x.toStringTag||"@@toStringTag",O="object"==typeof t,E=n.regeneratorRuntime;if(E)return void(O&&(t.exports=E));E=n.regeneratorRuntime=O?t.exports:{},E.wrap=e;var P="suspendedStart",j="suspendedYield",F="executing",M="completed",A={},N={};N[w]=function(){return this};var T=Object.getPrototypeOf,I=T&&T(T(d([])));I&&I!==b&&m.call(I,w)&&(N=I);var k=c.prototype=o.prototype=Object.create(N);u.prototype=k.constructor=c,c.constructor=u,c[_]=u.displayName="GeneratorFunction",E.isGeneratorFunction=function(t){var n="function"==typeof t&&t.constructor;return!!n&&(n===u||"GeneratorFunction"===(n.displayName||n.name))},E.mark=function(t){return Object.setPrototypeOf?Object.setPrototypeOf(t,c):(t.__proto__=c,_ in t||(t[_]="GeneratorFunction")),t.prototype=Object.create(k),t},E.awrap=function(t){return{__await:t}},f(a.prototype),a.prototype[S]=function(){return this},E.AsyncIterator=a,E.async=function(t,n,r,i){var o=new a(e(t,n,r,i));return E.isGeneratorFunction(n)?o:o.next().then(function(t){return t.done?t.value:o.next()})},f(k),k[_]="Generator",k.toString=function(){return"[object Generator]"},E.keys=function(t){var n=[];for(var r in t)n.push(r);return n.reverse(),function r(){for(;n.length;){var e=n.pop();if(e in t)return r.value=e,r.done=!1,r}return r.done=!0,r}},E.values=d,p.prototype={constructor:p,reset:function(t){if(this.prev=0,this.next=0,this.sent=this._sent=g,this.done=!1,this.delegate=null,this.method="next",this.arg=g,this.tryEntries.forEach(v),!t)for(var n in this)"t"===n.charAt(0)&&m.call(this,n)&&!isNaN(+n.slice(1))&&(this[n]=g)},stop:function(){this.done=!0;var t=this.tryEntries[0],n=t.completion;if("throw"===n.type)throw n.arg;return this.rval},dispatchException:function(t){function n(n,e){return o.type="throw",o.arg=t,r.next=n,e&&(r.method="next",r.arg=g),!!e}if(this.done)throw t;for(var r=this,e=this.tryEntries.length-1;e>=0;--e){var i=this.tryEntries[e],o=i.completion;if("root"===i.tryLoc)return n("end");if(i.tryLoc<=this.prev){var u=m.call(i,"catchLoc"),c=m.call(i,"finallyLoc");if(u&&c){if(this.prev<i.catchLoc)return n(i.catchLoc,!0);if(this.prev<i.finallyLoc)return n(i.finallyLoc)}else if(u){if(this.prev<i.catchLoc)return n(i.catchLoc,!0)}else{if(!c)throw new Error("try statement without catch or finally");if(this.prev<i.finallyLoc)return n(i.finallyLoc)}}}},abrupt:function(t,n){for(var r=this.tryEntries.length-1;r>=0;--r){var e=this.tryEntries[r];if(e.tryLoc<=this.prev&&m.call(e,"finallyLoc")&&this.prev<e.finallyLoc){var i=e;break}}i&&("break"===t||"continue"===t)&&i.tryLoc<=n&&n<=i.finallyLoc&&(i=null);var o=i?i.completion:{};return o.type=t,o.arg=n,i?(this.method="next",this.next=i.finallyLoc,A):this.complete(o)},complete:function(t,n){if("throw"===t.type)throw t.arg;return"break"===t.type||"continue"===t.type?this.next=t.arg:"return"===t.type?(this.rval=this.arg=t.arg,this.method="return",this.next="end"):"normal"===t.type&&n&&(this.next=n),A},finish:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.finallyLoc===t)return this.complete(r.completion,r.afterLoc),v(r),A}},catch:function(t){for(var n=this.tryEntries.length-1;n>=0;--n){var r=this.tryEntries[n];if(r.tryLoc===t){var e=r.completion;if("throw"===e.type){var i=e.arg;v(r)}return i}}throw new Error("illegal catch attempt")},delegateYield:function(t,n,r){return this.delegate={iterator:d(t),resultName:n,nextLoc:r},"next"===this.method&&(this.arg=g),A}}}("object"==typeof n?n:"object"==typeof window?window:"object"==typeof self?self:this)}).call(n,function(){return this}(),r(158))}])</script><script src="/./main.0cf68a.js"></script><script>!function(){!function(e){var t=document.createElement("script");document.getElementsByTagName("body")[0].appendChild(t),t.setAttribute("src",e)}("/slider.e37972.js")}()</script>


    
<div class="tools-col" q-class="show:isShow,hide:isShow|isFalse" q-on="click:stop(e)">
  <div class="tools-nav header-menu">
    
    
      
      
      
    
      
      
      
    
      
      
      
    
    

    <ul style="width: 70%">
    
    
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'innerArchive')"><a href="javascript:void(0)" q-class="active:innerArchive">所有文章</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'friends')"><a href="javascript:void(0)" q-class="active:friends">友链</a></li>
      
        
      
      <li style="width: 33.333333333333336%" q-on="click: openSlider(e, 'aboutme')"><a href="javascript:void(0)" q-class="active:aboutme">关于我</a></li>
      
        
    </ul>
  </div>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all" q-show="innerArchive">
        <div class="search-wrap">
          <input class="search-ipt" q-model="search" type="text" placeholder="find something…">
          <i class="icon-search icon" q-show="search|isEmptyStr"></i>
          <i class="icon-close icon" q-show="search|isNotEmptyStr" q-on="click:clearChose(e)"></i>
        </div>
        <div class="widget tagcloud search-tag">
          <p class="search-tag-wording">tag:</p>
          <label class="search-switch">
            <input type="checkbox" q-on="click:toggleTag(e)" q-attr="checked:showTags">
          </label>
          <ul class="article-tag-list" q-show="showTags">
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">大数据</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">cpp</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">应用实践</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color5">图形图像</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color1">linux</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color4">数据库</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color3">算法</a>
              </li>
             
              <li class="article-tag-list-item">
                <a href="javascript:void(0)" class="js-tag color2">C</a>
              </li>
            
            <div class="clearfix"></div>
          </ul>
        </div>
        <ul class="search-ul">
          <p q-show="jsonFail" style="padding: 20px; font-size: 12px;">
            缺失模块。<br/>1、请确保node版本大于6.2<br/>2、在博客根目录（注意不是yilia根目录）执行以下命令：<br/> npm i hexo-generator-json-content --save<br/><br/>
            3、在根目录_config.yml里添加配置：
<pre style="font-size: 12px;" q-show="jsonFail">
  jsonContent:
    meta: false
    pages: false
    posts:
      title: true
      date: true
      path: true
      text: false
      raw: false
      content: false
      slug: false
      updated: false
      comments: false
      link: false
      permalink: false
      excerpt: false
      categories: false
      tags: true
</pre>
          </p>
          <li class="search-li" q-repeat="items" q-show="isShow">
            <a q-attr="href:path|urlformat" class="search-title"><i class="icon-quo-left icon"></i><span q-text="title"></span></a>
            <p class="search-time">
              <i class="icon-calendar icon"></i>
              <span q-text="date|dateformat"></span>
            </p>
            <p class="search-tag">
              <i class="icon-price-tags icon"></i>
              <span q-repeat="tags" q-on="click:choseTag(e, name)" q-text="name|tagformat"></span>
            </p>
          </li>
        </ul>
    	</section>
    

    
    	<section class="tools-section tools-section-friends" q-show="friends">
  		
        <ul class="search-ul">
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接1</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接2</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接3</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接4</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接5</a>
            </li>
          
            <li class="search-li">
              <a href="http://localhost:4000/" target="_blank" class="search-title"><i class="icon-quo-left icon"></i>友情链接6</a>
            </li>
          
        </ul>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me" q-show="aboutme">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">出生在东北松花江边。。。&lt;br&gt;在北京工作了二十余载。。。&lt;br&gt;&lt;br&gt;立志成为一名合格的程序员。。。&lt;br&gt;家庭是我学习工作的原动力。。。&lt;br&gt;身体是我的本钱。。。&lt;br&gt;自我实现、追求幸福是我的人生目标。。。&lt;br&gt;自律、勤思考是我工作学习的方法。。。&lt;br&gt;&lt;br&gt;这就是我。。。</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>